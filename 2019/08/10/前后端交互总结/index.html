<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="Lililich&#39;s Blog">
    
    
    
    
    
    
    <title>前后端交互总结 | Lililich&#39;s Blog</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
</head></html>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="lrc-control">Open Lyrics</a>
        </li>
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" /images/background.jpg " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">小畅童鞋的学习笔记</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('/images/background.jpg');
            background-repeat: no-repeat;
            background-position: center -656px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('/images/background.jpg');
            background-position: center -700px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">小畅童鞋的学习笔记</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '2000',
                height: '1250'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            <div class="cube-article">
    <h1 class="title">前后端交互总结</h1>
    
    <div class="cube-article-header">
        <div class="cube-article-date">
            <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
            <!-- moment.js对象 -->
            2019-08-10
        </div>
        <div class="cube-article-tags">
    <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
    
    <a href="/tags/前端/">#前端</a>
    
    <a href="/tags/面经/">#面经</a>
    
</div>
    </div>
    
    <div class="cube-article-content cube-markdown">
        
        <p>秋招季，总结一下前后端交互部分面经~</p>
<h3 id="一-跨域问题："><a href="#一-跨域问题：" class="headerlink" title="一. 跨域问题："></a>一. 跨域问题：</h3><h4 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h4><p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。<br>所谓同源是指，协议，域名，端口均相同。<br>注意：<br>如果是协议和端口造成的跨域问题“前台”是无能为力的；<br>在跨域问题上，域仅仅是通过“URL的首部”来识别</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p><strong>特别注意两点：</strong><br>第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，<br>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。<br><strong>1. JSONP方式解决跨域问题</strong><br>script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。<br><strong>2. CORS解决跨域问题</strong><br>对后台进行配置，例如：PHP端修改header，然后配置Apache web服务器跨域<br><strong>3. 代理请求方式解决接口跨域问题</strong><br>前端对接口进行代理：（前端ajax请求的是本地接口；本地接口接收到请求后向实际的接口请求数据，然后再将信息返回给前端；一般用node.js即可代理；）<br>详情参考<a href>https://segmentfault.com/a/1190000012469713</a><br><a id="more"></a></p>
<h3 id="二-Jsonp实现原理"><a href="#二-Jsonp实现原理" class="headerlink" title="二. Jsonp实现原理"></a>二. Jsonp实现原理</h3><ol>
<li>拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;\script&gt;、&lt;\img&gt;、&lt;\iframe&gt;<br>当需要通讯时，本站脚本创建一个script元素，地址指向第三方的API网址，形如：</li>
</ol>
<pre><code>&lt;script src=&quot;http://www.example.net/api?param1=1¶m2=2&quot;&gt;&lt;/script&gt;
</code></pre><p>并提供一个回调函数localHandler来接收数据（函数名可约定，或通过地址参数传递）。</p>
<pre><code>&lt;script src=&quot;http://www.example.net/api?param1=1&amp;callback=localHandler&quot; type=&quot;text/javascript&quot;&gt;
var localHandler = function(data){
    alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result);
};
&lt;/script&gt;
</code></pre><ol start="2">
<li>第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：</li>
</ol>
<pre><code>localHandler(
    {
        &quot;result&quot;:&quot;hax&quot;,
        &quot;gender&quot;:&quot;Male&quot;
    }
)
</code></pre><ol start="3">
<li>这样浏览器会调用localHandler函数，并传递解析后json对象作为参数。</li>
</ol>
<h3 id="三-前后端分离的好处"><a href="#三-前后端分离的好处" class="headerlink" title="三. 前后端分离的好处"></a>三. 前后端分离的好处</h3><ol>
<li>最大的好处就是前端JS可以做很大部分的数据处理工作，对服务器的压力减小到最小。</li>
<li>后台错误不会直接反映到前台，错误接秒较为友好。</li>
<li>由于后台是很难去探知前台页面的分布情况，而这又是JS的强项，而JS又是无法独立和服务器进行通讯的。所以单单用后台去控制整体页面，又或者只靠JS完成效果，都会难度加大，前后台各尽其职可以最大程度的减少开发难度。</li>
</ol>
<h3 id="四-从输入一个URL到页面加载完成的过程中都发生了什么事情？"><a href="#四-从输入一个URL到页面加载完成的过程中都发生了什么事情？" class="headerlink" title="四. 从输入一个URL到页面加载完成的过程中都发生了什么事情？"></a>四. 从输入一个URL到页面加载完成的过程中都发生了什么事情？</h3><p>  主要分为6步：</p>
<ol>
<li>DNS域名解析</li>
<li>浏览器与服务器建立TCP连接（3次握手过程）</li>
<li>浏览器向服务器发起HTTP请求</li>
<li>服务器接受请求，进行响应结果，将生成的html返回给客户端</li>
<li>浏览器解析HTML,并请求html代码中的资源</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ol>
<h4 id="网络通信的整个流程："><a href="#网络通信的整个流程：" class="headerlink" title="网络通信的整个流程："></a>网络通信的整个流程：</h4><p>流程描述：<br>    第一步：打开浏览器，想要请求访问京东，在地址栏输入了网址：<a href="http://www.jd.com。（www.jd.com是域名就是一个IP地址的名称，IP地址不好记，所有有了域名。）" target="_blank" rel="noopener">www.jd.com。（www.jd.com是域名就是一个IP地址的名称，IP地址不好记，所有有了域名。）</a><br>    第二步：先将请求信息发给了交换机，然后交给了路由器，路由发给DNS服务器，通过DNS协议去找我们要访问的京东的IP地址：<br>　　第三步：查到的京东服务器对应的IP地址之后，路由器通过路由协议找到一个路由转发的最优路径，将你的请求信息还送给这个IP地址的京东的路由器<br>　　第四步：京东的路由器发给了京东网站的服务器上<br>　　第五步：京东网站服务器按照来的时候的路径，在返回给你他自己的网站<br>　　第六步：当你打开浏览器的时候，你的电脑给你的浏览器这个运行起来的程序给了一个编号，叫做端口号，当你的电脑收到京东发送过来的消息的时候，你的电脑通过端口号找到你的浏览器，你的浏览器拿到了京东的网站信息，然后将网站呈现在了自己的浏览器上</p>
<h3 id="五-进程和线程的区别"><a href="#五-进程和线程的区别" class="headerlink" title="五. 进程和线程的区别"></a>五. 进程和线程的区别</h3><ul>
<li><code>进程</code>：是<strong>并发执行的程序</strong>在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。</li>
<li><p><code>线程</code>：是进程的一个<strong>执行单元</strong>，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。<br><strong>一个程序至少一个进程，一个进程至少一个线程。</strong></p>
</li>
<li><p>对资源的管理和保护要求高，不限制开销和效率时，使用<code>多进程</code>。<br>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用<code>多线程</code>。</p>
</li>
<li><p><code>线程共享进程资源，进程之间的资源独立</code><br>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。进程切换时，消耗的资源大，效率高</p>
</li>
<li><p><code>线程与进程的区别：</code><br>a. 一个程序至少有一个进程，一个进程至少有一个线程<br>b. 线程的划分尺度小于进程，使得多线程程序的并发性高<br>c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率<br>d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制<br>e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配</p>
</li>
</ul>
<h3 id="六-队列和栈介绍"><a href="#六-队列和栈介绍" class="headerlink" title="六. 队列和栈介绍"></a>六. 队列和栈介绍</h3><ul>
<li><p><code>队列</code>：先进先出，表尾插入，表头删除。<br>队列可以模拟很多现实的生产环境，例如排队，队列是先进先出，不允许有任何元素插队，这对于解决现实生产问题有很大帮助。<br><code>栈</code>：先进后出，表尾删除插入。<br>可以很好的控制访问，栈的数据访问是有很严格的，只能访问最后加入的数据，这对数据访问控制严格的应用很有好处。现实中，字符串倒序输出，使用栈的原理就可以很好的实现。</p>
</li>
<li><p><strong>栈与队列的相同点：</strong><br>  1.都是线性结构。<br>  2.插入操作都是限定在表尾进行。<br>  3.都可以通过顺序结构和链式结构实现。<br>  4.插入与删除的时间复杂度都是O(1)，效率非常高，在空间复杂度上两者也一样。<br>  5.多链栈和多链队列的管理模式可以相同。</p>
</li>
<li><p><strong>栈与队列的不同点：</strong></p>
<ol>
<li>队列先进先出，栈先进后出。</li>
<li>对插入和删除操作的”限定”不同。<br><code>栈</code>是限定只能在表的一端进行插入和删除操作的线性表。<br><code>队列</code>是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。</li>
<li>遍历数据速度不同。<br><code>栈</code>只能从头部取数据，也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性。<br><code>队列</code>则不同，它基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的</li>
</ol>
</li>
</ul>
<h3 id="七-HTTP状态码及常见举例"><a href="#七-HTTP状态码及常见举例" class="headerlink" title="七. HTTP状态码及常见举例"></a>七. HTTP状态码及常见举例</h3><p><code>1** ：信息，服务器收到请求，需要请求者继续执行操作</code><br><code>2** ：成功，操作被成功接收并处理</code><br><code>3** ：重定向，需要进一步的操作以完成请求</code><br><code>4** ：客户端错误，请求包含语法错误或无法完成请求</code><br><code>5** ：服务器错误，服务器在处理请求的过程中发生了错误</code><br>100 ：继续。客户端应继续其请求。<br>101 ：切换协议，服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议<br><code>200 ：OK。请求成功，一般用于Get和post请求。</code><br>201 ：已创建。成功请求并创建了新的资源。<br>202 ：已接受。已经接受请求，但未处理完成<br>203 ：非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本。<br>204：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。<br>300：多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。<br>301 ：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。<br>302：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。<br><code>304：服务端资源无变化，可使用缓存资源</code><br>307：临时重定向。与302类似。使用GET请求重定向。<br><code>400：客户端请求的语法错误，服务器无法理解</code><br><code>401：请求要求用户的身份认证</code><br><code>403：服务端禁止访问该资源</code><br><code>404：服务器无法根据客户端的请求找到资源（网页）。</code><br>408：服务器等待客户端发送的请求时间过长，超时。<br>410：客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置。<br>411：服务器无法处理客户端发送的不带Content-Length的请求信息<br>414：请求的URI过长（URI通常为网址），服务器无法处理<br>417：服务器无法满足Expect的请求头信息。<br><code>500：服务器内部错误，无法完成请求。</code><br>501：服务器不支持请求的功能，无法完成请求。<br>502：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求<br>503：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。<br>504：充当网关或代理的服务器，未及时从远端服务器获取请求。<br>505：服务器不支持请求的HTTP协议的版本，无法完成处理。</p>
<h3 id="八-Http请求方法"><a href="#八-Http请求方法" class="headerlink" title="八. Http请求方法"></a>八. Http请求方法</h3><ul>
<li>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE，对URL地址（网络上的资源）的查，改，增，删4个操作。5、HEAD；6、TRACE；7、OPTIONS；</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>GET</td>
<td>发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。另外get支持快取、缓存、可保留书签等。幂等</td>
</tr>
<tr>
<td>2</td>
<td>POST</td>
<td>和get一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中。不支持快取。非幂等</td>
</tr>
<tr>
<td>3</td>
<td>HEAD</td>
<td>本质和get一样，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。</td>
</tr>
<tr>
<td>4</td>
<td>PUT</td>
<td>和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知道该位置；比如post是在一个集合上（/province），而put是具体某一个资源上（/province/123）。所以put是安全的，无论请求多少次，都是在123上更改，而post可能请求几次创建了几次资源。幂等</td>
</tr>
<tr>
<td>5</td>
<td>DELETE</td>
<td>请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。幂等</td>
</tr>
<tr>
<td>6</td>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。</td>
</tr>
<tr>
<td>7</td>
<td>OPTIONS</td>
<td>获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>GET与POST方法有以下区别：</strong>  <ol>
<li>在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTTP包的body中。</li>
<li>GET方式提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST则没有此限制。</li>
<li>安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。</li>
<li>服务器取值方式不一样。GET方式取值，如php可以使用<code>$_GET</code>来取得变量的值，而POST方式通过<code>$_POST</code>来获取变量的值。<br><img src="//lililich.work/2019/08/10/前后端交互总结/Image1.png" alt="Image1.png"></li>
</ol>
</li>
<li><code>Post和put区别</code><br>PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）<br>Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）</li>
</ul>
<h3 id="九-计算机网络的七层OSI"><a href="#九-计算机网络的七层OSI" class="headerlink" title="九. 计算机网络的七层OSI"></a>九. 计算机网络的七层OSI</h3><p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层<br><img src="//lililich.work/2019/08/10/前后端交互总结/Image2.png" alt="Image2.png"></p>
<h3 id="十-TCP-IP五层模型的协议"><a href="#十-TCP-IP五层模型的协议" class="headerlink" title="十. TCP/IP五层模型的协议"></a>十. TCP/IP五层模型的协议</h3><p>应用层、传输层、网络层、数据链路层、物理层</p>
<h3 id="十一-TCP和UDP的区别是什么"><a href="#十一-TCP和UDP的区别是什么" class="headerlink" title="十一. TCP和UDP的区别是什么"></a>十一. TCP和UDP的区别是什么</h3><p>UDP协议和TCP协议都是传输层协议。</p>
<h4 id="TCP（Transmission-Control-Protocol，传输控制协议）"><a href="#TCP（Transmission-Control-Protocol，传输控制协议）" class="headerlink" title="TCP（Transmission Control Protocol，传输控制协议）"></a>TCP（Transmission Control Protocol，传输控制协议）</h4><ul>
<li><p><code>TCP</code>（Transmission Control Protocol，传输控制协议）提供的是面向连接，可靠的字节流服务。即客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</p>
<ol>
<li><strong>优点：<code>可靠，稳定</code></strong>　<br>TCP的可靠性体现在传输数据之前，三次握手建立连接（四次挥手释放连接），并且在数据传递时，有确认、窗口、重传、拥塞控制机制，数据传完之后，断开连接用来节省系统资源。</li>
<li><strong>缺点：<code>慢，效率低，占用系统资源高，易被攻击</code></strong>　<br>传数据之前建立连接，这样会消耗时间，而且在消息传递时，确认机制、重传机制和拥塞控制机制都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。而每个连接都会占用系统的CPU、内存等硬件软件资源。并且TCP的取而机制、三次握手，这些也导致TCP容易被人利用，实现DOS，DDOS攻击。</li>
<li><strong>协议：</strong><ul>
<li>HTTP </li>
<li>HTTPS </li>
<li>SSH </li>
<li>Telnet </li>
<li>FTP </li>
<li>SMTP</li>
</ul>
</li>
<li><strong>TCP应用场景：</strong> <ul>
<li>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li>
</ul>
</li>
<li><strong>TCP粘包问题</strong><ul>
<li>首先要明确, 粘包问题中的 “包” , 是指的应用层的数据包；</li>
<li>在TCP的协议头中, 没有如同UDP一样的 “报文长度” 这样的字段, 但是有一个序号这样的字段；</li>
<li>站在传输层的角度, TCP是一个一个报文过来的，按照序号排好序放在缓冲区中；</li>
<li>站在应用层的角度, 看到的只是一串连续的字节数据. 那么应用程序看到了这么一连串的字节数据, 就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。</li>
</ul>
</li>
<li><strong>那么如何避免粘包问题呢?</strong> <ul>
<li>归根结底就是一句话, 明确两个包之间的边界.</li>
</ul>
<ol>
<li>对于定长的包, 保证每次都按固定大小读取即可; </li>
<li>对于变长的包, 可以在报头的位置, 约定一个包总长度的字段, 从而就知道了包的结束位置; </li>
<li>对于变长的包, 还可以在包和包之间使用明确的分隔符。 </li>
<li>TLV格式的数据传输</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="UDP（User-Data-Protocol，用户数据报协议）"><a href="#UDP（User-Data-Protocol，用户数据报协议）" class="headerlink" title="UDP（User Data Protocol，用户数据报协议）"></a>UDP（User Data Protocol，用户数据报协议）</h4><ul>
<li><p><code>UDP</code>（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。</p>
<ol>
<li><strong>优点：<code>快，比TCP稍安全</code></strong>　<br>UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，udp是一个无状态的传输协议，所以他在传输数据时非常快。M没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。UDP也是无法避免攻击的，比如：UDP flood攻击</li>
<li><strong>缺点：<code>不可靠，不稳定</code></strong><br>因为UDP没有TCP的那些可靠机制，在网络质量<br>不好时很容易丢包。</li>
<li><strong>协议：</strong><ul>
<li>NFS: 网络文件系统 </li>
<li>TFTP: 简单文件传输协议 </li>
<li>DHCP: 动态主机配置协议 </li>
<li>BOOTP: 启动协议(用于无盘设备启动) </li>
<li>DNS: 域名解析协议</li>
</ul>
</li>
<li><strong>UDP应用场景：</strong> <ul>
<li>效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="TCP与UDP区别总结："><a href="#TCP与UDP区别总结：" class="headerlink" title="TCP与UDP区别总结："></a>TCP与UDP区别总结：</h4><pre><code>1. `TCP面向连接`（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2. `TCP提供可靠的服务`。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3. `TCP面向字节流`，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
</code></pre><p><code>UDP没有拥塞控制</code>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p>
<pre><code>4. 每一条`TCP连接只能是点到点的`;UDP支持一对一，一对多，多对一和多对多的交互通信
5. TCP`首部开销`20字节;UDP的首部开销小，只有8个字节
6. TCP的逻辑通信信道是`全双工`的`可靠信道`，UDP则是不可靠信道
</code></pre><p><img src="//lililich.work/2019/08/10/前后端交互总结/Image3.png" alt="Image3.png"></p>
<h3 id="十二-TCP与HTTP的不同，HTTP是什么，HTTPS是什么"><a href="#十二-TCP与HTTP的不同，HTTP是什么，HTTPS是什么" class="headerlink" title="十二. TCP与HTTP的不同，HTTP是什么，HTTPS是什么"></a>十二. TCP与HTTP的不同，HTTP是什么，HTTPS是什么</h3><ul>
<li><code>HTTP协议即超文本传送协议</code>(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</li>
<li><code>HTTPS即加密的HTTP</code>，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间。</li>
<li><code>TCP是传输层，而http是应用层，http是要基于TCP连接基础上的</code>。<br>TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。<br>http是用来收发数据，即实际应用上来的。</li>
</ul>
<h3 id="十三-TCP的三次握手-为什么不是两次？"><a href="#十三-TCP的三次握手-为什么不是两次？" class="headerlink" title="十三. TCP的三次握手,为什么不是两次？"></a>十三. TCP的三次握手,为什么不是两次？</h3><ul>
<li>三次握手：请求，确认，建立连接<br>第一次：客户端C发送一个请求连接的位码SYN(1)和一个随机产生的序列号Seq(x)给服务器S，C进入SYN_SEND状等待服务器确认。<br>第二次：S收到了这个请求连接的位码SYN(1)，实现确认一下，发送了一个确认码ACK（x+1)+SYN(1)+Seq（y）给进入SYN_RECV状态。<br>第三次：C收到了SYN＋ACK，一比较一样，于是他又发送了一个ACK(y+1)+Seq(z)给S，S收到以后就确定建立连接，C和S进入ESTABLISHED状态，TCP连接建立完成。</li>
<li><strong>为什么不是两次？</strong><br>三次是①C能和S通信②S能和C通信③S和C建立连接，<br>两次的话，不能确定S和C是否能通信，会产生问题<br><img src="//lililich.work/2019/08/10/前后端交互总结/Image4.png" alt="Image4.png"></li>
</ul>
<h3 id="十四-四次挥手：确保数据能够完整传输。"><a href="#十四-四次挥手：确保数据能够完整传输。" class="headerlink" title="十四. 四次挥手：确保数据能够完整传输。"></a>十四. 四次挥手：确保数据能够完整传输。</h3><ol>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。C没数据传输了</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。S说我也没了</li>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。C请求关闭</li>
<li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。S同意并关闭</li>
</ol>
<h3 id="十五-一次js请求一般情况下有哪些地方会有缓存处理？"><a href="#十五-一次js请求一般情况下有哪些地方会有缓存处理？" class="headerlink" title="十五. 一次js请求一般情况下有哪些地方会有缓存处理？"></a>十五. 一次js请求一般情况下有哪些地方会有缓存处理？</h3><ol>
<li>浏览器端存储</li>
<li>浏览器端文件缓存</li>
<li>HTTP缓存304</li>
<li>服务器端文件类型缓存</li>
<li>表现层&amp;DOM缓存</li>
</ol>
<h3 id="十六-HTTP缓存机制"><a href="#十六-HTTP缓存机制" class="headerlink" title="十六. HTTP缓存机制"></a>十六. HTTP缓存机制</h3><p>Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。</p>
<p>浏览器缓存分类浏览器缓存分为<code>强缓存</code>和<code>协商缓存</code>，浏览器加载一个页面的简单流程如下：</p>
<ol>
<li>浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。</li>
<li>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。</li>
<li>如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。</li>
</ol>
<h4 id="缓存规则解析"><a href="#缓存规则解析" class="headerlink" title="缓存规则解析"></a>缓存规则解析</h4><p>为方便大家理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。　　<br><img src="//lililich.work/2019/08/10/前后端交互总结/Image5.png" alt="Image5.png"><br>　　HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，协商缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。　　已存在缓存数据时，仅基于强制缓存，请求数据的流程如下：　　<br><img src="//lililich.work/2019/08/10/前后端交互总结/Image6.png" alt="Image6.png"><br>  　　已存在缓存数据时，仅基于协商缓存，请求数据的流程如下：<br><img src="//lililich.work/2019/08/10/前后端交互总结/Image7.png" alt="Image7.png"><br>    　　对缓存机制不太了解的同学可能会问，基于协商缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。　　我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。</p>
<h4 id="1-强缓存"><a href="#1-强缓存" class="headerlink" title="1. 强缓存"></a>1. 强缓存</h4><ul>
<li><p>强缓存命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。</p>
</li>
<li><p>强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。</p>
</li>
</ul>
<p><strong>Expires</strong></p>
<ul>
<li><code>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点</code>。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</li>
<li>该字段会返回一个时间，比如Expires:Thu,31 Dec 2037 23:59:59 GMT。这个时间代表着这个资源的失效时间，也就是说在2037年12月31日23点59分59秒之前都是有效的，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当客户端本地时间被修改以后，服务器与客户端时间偏差变大以后，就会导致缓存混乱。于是发展出了Cache-Control。</li>
</ul>
<p><strong>Cache-Control</strong></p>
<ul>
<li><code>Cache-Control是一个相对时间</code>，例如Cache-Control:3600，代表着资源的有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。<br>Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候<code>Cache-Control优先级高。</code></li>
</ul>
<h4 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2. 协商缓存"></a>2. 协商缓存</h4><ul>
<li>若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。</li>
</ul>
<p><strong>Last-Modify/If-Modify-Since</strong></p>
<ul>
<li>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</li>
<li>当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</li>
<li>如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。</li>
</ul>
<p><strong>ETag/If-None-Match</strong></p>
<ul>
<li>与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</li>
</ul>
<h3 id="十七-CDN（内容分发网络，Content-Distribute-Network）的概念以及使用CDN加速的优点。"><a href="#十七-CDN（内容分发网络，Content-Distribute-Network）的概念以及使用CDN加速的优点。" class="headerlink" title="十七. CDN（内容分发网络，Content Distribute Network）的概念以及使用CDN加速的优点。"></a>十七. CDN（内容分发网络，Content Distribute Network）的概念以及使用CDN加速的优点。</h3><p><strong>cdn加速是什么？</strong></p>
<ul>
<li>CDN解决的是如何将数据快速可靠从源站传递到用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。</li>
<li>简单来讲云服务商会在全国各地部署节点服务器，当你的网站购买使用了他们的cdn，那么会把你网站可以缓存的内容都缓存在各地区的节点服务器上。这样不同地区的用户访问你的网站时，就可以在它最近的节点上访问，不需要到你的主站，通过这个方式达到加速的效果。</li>
<li>在通俗一点讲，比如京东自营，当你在网站上购买一件商品，需要快递到厦门，如果是从北京发货那么3天时间是需要的，但京东在厦门设立了仓库，并且提前把货存在仓库中，这时就可以直接从厦门仓发货，当天或隔天就可以收到商品，速度跟体验都非常好。</li>
</ul>
<p><strong>那么除了速度加快，使用cdn还有什么好处呢？</strong></p>
<ol>
<li>网站不容易宕机<br>如果你的网站没有使用cdn，当同个时间出现巨大的访问量时，网站很可能会宕机，比如双十一，凌晨过后突然有大量用户访问，如果不做负载处理那么页面打开会非常缓慢，在使用cdn后，就可以减少网站宕机的情况，承载更多的流量。</li>
<li>保障网站安全<br>cdn的负载均衡和分布式存储技术，加上节点之间的智能冗余机制，可以有效应对大部份的黑客入侵以及ddos的攻击，无形中给网站增加了一把保护伞，避免由于攻击带给网站的巨大损失。</li>
<li>异地备援更可靠<br>使用了cdn加速，当某一个节点服务器发生故障时，不会影响多数用户的访问，系统会判断并调用其它临近正常运行的服务器，这样的机制可以提供接近100%的可靠性，让你的网站做到永不宕机。</li>
<li>减轻原服务器负载<br>当内容分发自动缓存到其它服务器后，用户在访问网站时从临近的服务器上读取数据，减少原web服务器的带宽使用，分担网络流量、减少负载等好处。</li>
</ol>
<ul>
<li>不仅如此，cdn还有很多的优点，比如计费合理，平衡节点流量输出，减少费用开支等， 那么对SEO来讲好处主要是网站打开速度优化，稳定性更强，能承载大量蜘蛛访问抓取。</li>
</ul>
<h3 id="十八-前端开发常见安全问题（SQL注入、XSS攻击、CSRF攻击）"><a href="#十八-前端开发常见安全问题（SQL注入、XSS攻击、CSRF攻击）" class="headerlink" title="十八. 前端开发常见安全问题（SQL注入、XSS攻击、CSRF攻击）"></a>十八. 前端开发常见安全问题（SQL注入、XSS攻击、CSRF攻击）</h3><h4 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1. SQL注入"></a>1. SQL注入</h4><ul>
<li><p><code>SQL攻击（SQL injection）</code>，简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。</p>
</li>
<li><p><code>SQL注入攻击原理</code></p>
<ol>
<li>寻找到SQL注入的位置</li>
<li>判断服务器类型和后台数据库类型</li>
<li>针对不通的服务器和数据库特点进行SQL注入攻击 </li>
</ol>
</li>
<li><p><code>防御措施</code>：</p>
<ol>
<li><p><strong>永远不要信任用户的输入</strong><br>对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双“-”进行转换等</p>
</li>
<li><p><strong>永远不要使用动态拼装sql</strong><br>可以使用参数化的sql或者直接使用存储过程进行数据查询存取。哪怕参数是常量，也请用预编译语句PreparedStatement，同时用占位符，如： “select * from table where comment like ?”。<br>注意：如果参数不是使用的占位符，即使用PreparedStatement执行时也并不是预编译。</p>
</li>
<li><p><strong>永远不要使用管理员权限的数据库连接</strong><br>为每个应用使用单独的有权限的数据库连接，这样能降低数据库密码被泄漏而带来的破坏。</p>
</li>
<li><p><strong>不要把机密信息直接存放</strong><br>加密或者hash掉密码和敏感的信息；如数据库连接密码、用户密码、设备密码需要加密存储。</p>
</li>
<li><p><strong>应用的异常信息应该给出尽可能少的提示</strong><br>最好使用自定义的错误信息对原始错误信息进行包装。</p>
</li>
</ol>
</li>
</ul>
<h4 id="2-XSS跨站脚本攻击"><a href="#2-XSS跨站脚本攻击" class="headerlink" title="2. XSS跨站脚本攻击"></a>2. XSS跨站脚本攻击</h4><ul>
<li><p><code>XSS(Cross Site Scripting)</code>跨站脚本攻击指攻击者在网页中嵌入客户端脚本(例如JavaScript)，当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的，比如获取用户的Cookie，导航到恶意网站，携带木马等</p>
</li>
<li><p><code>防御措施</code>：</p>
<ol>
<li><p><strong>在cookie中不要存放一些敏感信息</strong><br>比如用户名、密码等安全信息，或者cookie中的信息采用加密的方式。最为有效的方式是将重要的cookie标记为http only，这样脚本中就不能访问这个cookie，就避免了XSS攻击利用JavaScript的document.cookie获取cookie：</p>
</li>
<li><p><strong>输入过滤校验，对用户提交的数据进行有效性验证</strong><br>仅接受指定长度范围内并符合我们期望格式的的内容提交，阻止或者忽略除此外的其他任何数据。比如：电话号码必须是数字和中划线组成，而且要设定长度上限。过滤一些些常见的敏感字符，例如：&lt; &gt; ‘ “ &amp; # \；过滤或移除特殊的Html标签， 例如: <code>&lt;script&gt;, &lt;iframe&gt; , &amp;lt; for &lt;, &amp;gt; for &gt;, &amp;quot for</code>；过滤JavaScript 事件的标签，例如<code>&quot;οnclick=&quot;</code>,<code>&quot;onfocus&quot;</code>等等。这里的数据校验除了前台要做，后台也要做。</p>
</li>
<li><p><strong>DOM型的XSS攻击防御</strong><br>把变量输出到页面时要做好相关的编码转义工作，如要输出到<code>&lt;script&gt;</code>中，可以进行JS编码；要输出到HTML内容或属性，则进行HTML编码处理。根据不同的语境采用不同的编码处理方式。</p>
</li>
</ol>
</li>
</ul>
<h4 id="3-CSRF（-Cross-site-request-forgery-）跨站点请求伪造"><a href="#3-CSRF（-Cross-site-request-forgery-）跨站点请求伪造" class="headerlink" title="3. CSRF（ Cross-site request forgery ）跨站点请求伪造"></a>3. CSRF（ Cross-site request forgery ）跨站点请求伪造</h4><ul>
<li><p><code>CSRF（ Cross-site request forgery ）</code>也被称为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来很像XSS跨站脚本攻击，但是它于XSS完全不同。XSS是利用站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的站点，从而在并未授权的情况下执行在权限保护之下的操作。与XSS相比，CSRF攻击不大流行和难以防范，所以比XSS更具危险性。</p>
</li>
<li><p><code>CSRF攻击原理</code><br>CSRF攻击原理比较简单，假设Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p>
<ol>
<li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； </li>
<li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li>
<li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li>
<li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li>
<li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li>
</ol>
</li>
<li><p><code>防御措施</code>：</p>
<ol>
<li><p><strong>合理使用POST和GET</strong><br>GET方法提交数据很容易被拿来做CSRF攻击，使用POST只能降低攻击风险，并不能杜绝，攻击者在第三方页面构造一个form就可以用POST提交数据构成CSRF攻击。</p>
</li>
<li><p><strong>使用验证码</strong><br>在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。</p>
</li>
<li><p><strong>检查Referer字段</strong><br>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于<a href="http://www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问" target="_blank" rel="noopener">www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问</a></p>
</li>
<li><p><strong>添加校验token</strong><br>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p>
</li>
</ol>
</li>
</ul>
<h3 id="十九-Ajax工作原理"><a href="#十九-Ajax工作原理" class="headerlink" title="十九. Ajax工作原理"></a>十九. Ajax工作原理</h3><ol>
<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li>
<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li>
<li>设置响应HTTP请求状态变化的函数.</li>
<li>发送HTTP请求.</li>
<li>获取异步调用返回的数据.</li>
<li>使用JavaScript和DOM实现局部刷新.</li>
</ol>
<h3 id="二十-死锁是什么"><a href="#二十-死锁是什么" class="headerlink" title="二十. 死锁是什么"></a>二十. 死锁是什么</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。永远在互相等待的进程称为死锁进程。</p>
<h3 id="二十一-自适应和响应式区别"><a href="#二十一-自适应和响应式区别" class="headerlink" title="二十一. 自适应和响应式区别"></a>二十一. 自适应和响应式区别</h3><p>两者都是优化适应互联网中越来越分化的视口.<br>应该说响应式的范畴更广一些。<br><strong>响应式可以自动适应不同尺寸的屏幕，无论你的设备尺寸多么奇葩。</strong>响应式使用CSS media queries的方法，根据目标设备自动改变风格如显示类型,宽度、高度等，这能很好解决不同屏幕尺寸的显示问题。<br>是一个网站能够兼容多个终端而不是为每个终端做一个特定的版本，这个概念是为移动互联网浏览而诞生。<br><strong>自适应设计是基于断点使用静态布局，一旦页面被加载就无法再进行自动适应，自适应会自动检测屏幕的大小来加载适当的工作布局</strong>，也就是说，当你要采用自适应设计网站时，你得一个一个设计6种常见的屏幕布局。[自适应设计要求为每一个布局单独开发和维护HTML和CSS代码]<br>1、320   2、480  3、760  4、960  5、1200   6、1600<br>自适应设计需要做更多的工作，你必须至少设计6种常见的布局。而响应式设计可以更好地适应复杂的媒体设备要求，能很好地解决显示和性能问题，修改相当麻烦。修改相当麻烦。</p>
<h3 id="二十二-谈谈你对前端性能优化的理解"><a href="#二十二-谈谈你对前端性能优化的理解" class="headerlink" title="二十二. 谈谈你对前端性能优化的理解"></a>二十二. 谈谈你对前端性能优化的理解</h3><ol>
<li><code>请求数量</code>：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</li>
<li><code>请求带宽</code>：开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体</li>
<li><code>缓存利用</code>：使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</li>
<li><code>页面结构</code>：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</li>
<li><code>代码校验</code>：避免CSS表达式，避免重定向</li>
</ol>
<h3 id="二十三-请说出三种减少页面加载时间的方法"><a href="#二十三-请说出三种减少页面加载时间的方法" class="headerlink" title="二十三. 请说出三种减少页面加载时间的方法"></a>二十三. 请说出三种减少页面加载时间的方法</h3><ol>
<li>尽量减少页面中重复的HTTP请求数量</li>
<li>服务器开启gzip压缩</li>
<li>css样式的定义放置在文件头部</li>
<li>Javascript脚本放在文件末尾</li>
<li>压缩合并Javascript、CSS代码</li>
<li>使用多域名负载网页内的多个文件、图片</li>
</ol>
<h3 id="二十四-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验-性能优化-。"><a href="#二十四-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验-性能优化-。" class="headerlink" title="二十四. 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验[性能优化]。"></a>二十四. 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验[性能优化]。</h3><ol>
<li>图片懒加载，滚动到相应位置才加载图片。</li>
<li>图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。</li>
<li>使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。</li>
<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>
</ol>
<h3 id="二十五-什么叫优雅降级和渐进增强？"><a href="#二十五-什么叫优雅降级和渐进增强？" class="headerlink" title="二十五. 什么叫优雅降级和渐进增强？"></a>二十五. 什么叫优雅降级和渐进增强？</h3><ul>
<li><code>渐进增强 progressive enhancement：</code><br>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>
<li><code>优雅降级 graceful degradation：</code><br>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。<h4 id="渐进增强和优雅降级的区别："><a href="#渐进增强和优雅降级的区别：" class="headerlink" title="渐进增强和优雅降级的区别："></a>渐进增强和优雅降级的区别：</h4></li>
</ul>
<ol>
<li>优雅降级是从复杂的现状开始，并试图减少用户体验的供给</li>
<li>渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</li>
<li>降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</li>
</ol>
<h3 id="二十六-网站重构的理解"><a href="#二十六-网站重构的理解" class="headerlink" title="二十六. 网站重构的理解"></a>二十六. 网站重构的理解</h3><p>重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。</p>
<ol>
<li>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</li>
<li>对于移动平台的优化，针对于SEO进行优化</li>
<li>减少代码间的耦合，让代码保持弹性</li>
<li>压缩或合并JS、CSS、image等前端资源</li>
</ol>
<h3 id="二十七-谈谈以前端角度出发做好SEO需要考虑什么？"><a href="#二十七-谈谈以前端角度出发做好SEO需要考虑什么？" class="headerlink" title="二十七. 谈谈以前端角度出发做好SEO需要考虑什么？"></a>二十七. 谈谈以前端角度出发做好SEO需要考虑什么？</h3><ol>
<li>了解搜索引擎如何抓取网页和如何索引网页</li>
<li>meta标签优化</li>
<li>关键词分析</li>
<li>付费给搜索引擎</li>
<li>链接交换和链接广泛度（Link Popularity）</li>
<li>合理的标签使用</li>
</ol>
<h3 id="二十八-前端页面有哪三层构成，分别是什么？作用是什么？"><a href="#二十八-前端页面有哪三层构成，分别是什么？作用是什么？" class="headerlink" title="二十八. 前端页面有哪三层构成，分别是什么？作用是什么？"></a>二十八. 前端页面有哪三层构成，分别是什么？作用是什么？</h3><ol>
<li>结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。</li>
<li>表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。</li>
<li>行为层：由脚本负责。解决了页面上“内容应该如何对事件作出反应”的问题。</li>
</ol>
<h3 id="二十九-系统访问量变高了，速度变慢了怎么办？"><a href="#二十九-系统访问量变高了，速度变慢了怎么办？" class="headerlink" title="二十九. 系统访问量变高了，速度变慢了怎么办？"></a>二十九. 系统访问量变高了，速度变慢了怎么办？</h3><p>优化。<br>优化方式很多，如：读写分离、负载均衡<br>资源服务器和应用服务器分离，即应用部署在应用服务器上，资源部署在资源服务器上。这时候，js和css的引用就需要更改为绝对URL，指向对应的资源服务器。</p>
<h3 id="三十-WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#三十-WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="三十. WEB应用从服务器主动推送Data到客户端有那些方式？"></a>三十. WEB应用从服务器主动推送Data到客户端有那些方式？</h3><ol>
<li>html5 websoket</li>
<li>WebSocket 通过 Flash</li>
<li>XHR长时间连接</li>
<li>XHR Multipart Streaming</li>
<li>不可见的Iframe</li>
<li>标签的长时间连接(可跨域)</li>
</ol>
<h3 id="三十一-知道的网页制作会用到的图片格式有哪些？"><a href="#三十一-知道的网页制作会用到的图片格式有哪些？" class="headerlink" title="三十一. 知道的网页制作会用到的图片格式有哪些？"></a>三十一. 知道的网页制作会用到的图片格式有哪些？</h3><p>png-8，png-24，jpeg，gif，svg<br>Webp：谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。<br>Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准。</p>
<h3 id="三十二-AMD和CMD-规范的区别？"><a href="#三十二-AMD和CMD-规范的区别？" class="headerlink" title="三十二. AMD和CMD 规范的区别？"></a>三十二. AMD和CMD 规范的区别？</h3><p>AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现<br>CMD 按需执行依赖 - 懒执行，seaJS 是它的实现</p>
<h3 id="三十三-前端-MV-框架的意义"><a href="#三十三-前端-MV-框架的意义" class="headerlink" title="三十三. 前端 MV*框架的意义"></a>三十三. 前端 MV*框架的意义</h3><ul>
<li>早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，基本不太需要框架。</li>
<li>随着 AJAX 的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了。</li>
<li>如果是页面型产品，多数确实不太需要它，因为页面中的 JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。</li>
<li>长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。</li>
<li>从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的 MV框架，这个状况会大有改观。</li>
<li>之所以感受不到 MV*框架的重要性，是因为Model部分代码较少，View的相对多一些。如果主要在操作View和Controller，那当然 jQuery 这类库比较好用了。</li>
</ul>
<h3 id="三十四-对前端工程师这个职位是怎么看的？"><a href="#三十四-对前端工程师这个职位是怎么看的？" class="headerlink" title="三十四. 对前端工程师这个职位是怎么看的？"></a>三十四. 对前端工程师这个职位是怎么看的？</h3><p><strong>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</strong></p>
<ol>
<li>实现界面交互</li>
<li>提升用户体验</li>
<li>有了Node.js，前端可以实现服务端的一些事情</li>
</ol>
<p><strong>前景：</strong></p>
<ol>
<li>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更??</li>
<li>参与项目，快速高质量完成实现效果图，精确到1px；</li>
<li>与团队成员，UI设计，产品经理的沟通；</li>
<li>做好的页面结构，页面重构和用户体验；</li>
<li>处理hack，兼容、写出优美的代码格式；</li>
<li>针对服务器的优化、拥抱最新前端技术。</li>
</ol>
<h3 id="三十五-平时如何管理你的项目？"><a href="#三十五-平时如何管理你的项目？" class="headerlink" title="三十五. 平时如何管理你的项目？"></a>三十五. 平时如何管理你的项目？</h3><ol>
<li>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</li>
<li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li>
<li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li>
<li>页面进行标注（例如 页面 模块 开始和结束）；</li>
<li>CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</li>
<li>JS 分文件夹存放 命名以该JS功能为准的英文翻译。</li>
<li>图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</li>
</ol>
<h3 id="三十六-说说最近最流行的一些东西吧？常去哪些网站？"><a href="#三十六-说说最近最流行的一些东西吧？常去哪些网站？" class="headerlink" title="三十六. 说说最近最流行的一些东西吧？常去哪些网站？"></a>三十六. 说说最近最流行的一些东西吧？常去哪些网站？</h3><p>CSDN、SegmentFault、php.net、MDN、css参考手册、iconfont、underscore、github、Bootstrap、W3Shool、W3Cplus、caniuse</p>

    </div>
</div>

<div class="cube-article-nav">
    <ul>
        
        <li class="prev">
            <a href="/2019/08/15/Vue总结/">
                <i class="cube-icon cube-prev" aria-hidden="true"></i>
                Vue总结
            </a>
        </li>
        
        
        <li class="next">
            <a href="/2019/08/08/Javascript总结/">
                Javascript总结
                <i class="cube-icon cube-next" aria-hidden="true"></i>
            </a>
        </li>
        
    </ul>
</div>


<!-- TODO 根据theme.comment的内容进行入口选择 -->



        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>Lililich&#39;s Blog</span>
    
    
    <div class="count">
        <a class="count articles"><span>35</span>Article</a>
        <a class="count tags"><span>18</span>Tags</a>
        <a class="count categories"><span>5</span>Categories</a>
    </div>
</div>



<div class="cube-music cube-sidebar" id="cube-music">
    <div class="cube-player aplayer" id="cube-player"></div>
</div>
<script>
    (function (window) {
        window.musicModule = {}
        window.musicModule.musicConfig = '{"narrow":false,"autoplay":false,"showlrc":3,"theme":"#b7daff","mutex":true,"mode":"circulation","preload":"auto","listmaxheight":"513px","music":[{"title":"Dear friends","author":"TRIPLANE","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/TRIPLANE - Dear friends.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Dear friends - TRIPLANE.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/TRIPLANE - Dear friends.jpg"},{"title":"Butter-Fly","author":"和田光司","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/和田光司 - Butter-Fly (ピアノヴァージョン).mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Butter-Fly (ピアノヴァージョン) - 和田光司.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/和田光司 - Butter-Fly (ピアノヴァージョン).jpg"},{"title":"宵闇花火","author":"葉月ゆら","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/葉月ゆら - 宵闇花火.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/宵闇花火 - 葉月ゆら.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/葉月ゆら - 宵闇花火.jpg"}]}'
        window.musicModule.lrcConfig = {
            open: 'Open Lyrics',
            close: 'Close Lyrics'
        }
    })(window)
</script>



<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/2019/10/24/正则表达式详解/" title="正则表达式详解">正则表达式详解</a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/2019/09/20/EventLoop详解/" title="EventLoop详解">EventLoop详解</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/2019/09/18/webpack基本原理/" title="webpack基本原理">webpack基本原理</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/2019/09/06/js实现继承/" title="js实现继承">js实现继承</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/2019/09/06/CSS经典布局——圣杯布局和双飞翼布局/" title="CSS经典布局——圣杯布局和双飞翼布局">CSS经典布局——圣杯布局和双飞翼布局</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>



<div class="cube-categories cube-sidebar" id="cube-categories">
    <div class="title">
        <a href="/categories">Categories</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/categories/前端工具/">#前端工具</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/语法/">#语法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/算法/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/工程/">#工程</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/面经/">#面经</a>
        </div>
        
    </div>
</div>



<div class="cube-tagcloud cube-sidebar" id="cube-tagcloud">
    <div class="title">
        <a href="/tags">Tagcloud</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/tags/前端/">#前端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Echarts/">#Echarts</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/js/">#js</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/html/">#html</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Hexo/">#Hexo</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Markdown/">#Markdown</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/编程/">#编程</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/二叉树/">#二叉树</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/flex/">#flex</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/跨域/">#跨域</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/CSS/">#CSS</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/布局/">#布局</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Github/">#Github</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Git/">#Git</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/面经/">#面经</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/Vue/">#Vue</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/webpack/">#webpack</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/排序/">#排序</a>
        </div>
        
    </div>
</div>



<div class="cube-links cube-sidebar" id="cube-links">
    <div class="title">
        <a>Links</a>
    </div>
    <ul class="list">
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/GitHub.png">
            
            <a href="https://github.com/lililich" target="_blank">GitHub</a>
        </li>
        
        <li>
            
            
            <img src="/images/weibo.jpg">
            
            <a href="https://weibo.com/2046576567/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" target="_blank">Weibo</a>
        </li>
        
    </ul>
</div>



<div class="cube-friend-links cube-sidebar" id="cube-friend-links">
    <div class="title">
        <a>Friend Links</a>
    </div>
    <ul class="list">
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/Friendlink/Shuki.jpg">
            <a href="https://shuki.top/" target="_blank">Shuki</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/Friendlink/Rayshell.png">
            <a href="https://www.Rayshell.work/" target="_blank">Rayshell</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/Friendlink/Vikeezan.jpg">
            <a href="http://vikeezan.club/" target="_blank">Vikeezan</a>
        </li>
        
    </ul>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 Lililich&#39;s Blog

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>