{"pages":[{"title":"categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"},{"title":"about-me","text":"关于我本人小姑娘，小硕一枚，年龄成谜。技术平平，相貌尚可，人品不错；但是吧，由于大木桶原理，不能让技术成为自己的短板吧，于是奋发图强，从此小小的博客页面产生了，我会勤奋刻苦的。在我自己眼里，也许我就是一个小渣渣，但是，记住是在自己眼里，绝对不允许别人这么说哈哈哈。 马上就要开始找暑期实习了，最好是找一个可以爱上的工作，然后沉迷技术，无法自拔哈哈哈哈哈 座右铭一天要做三件事：第一要笑，第二要微笑，第三要哈哈大笑 个人爱好喜欢听音乐，看韩剧，运动，练瑜伽，十字绣也很厉害哦顺便提一句，如果去了KTV，那KTV麦霸就是我hhh 自我描述• 我是一个踏实认真，责任心强，敢于吃苦，从以前的工作经历中总结到，一个好的团队要有较强的团队精神，不能自己单打独斗，要知道一个团队的重要性；• 有较强的沟通和理解能力，思维活跃敢于创新，可以提出自己的看法，多交流才能多进步；• 热情开朗，自信大方，擅长与人交流，会成为团队的开心果，有较强的动手能力和学习能力。 联系我Weibo：莪叫_小畅Github：lililichEmail：lililich94@163.comBlog：https://lililich.work 搭建博客的初衷作为一名技术小白，一直秉承着极高的热情向技术大佬们学习，可是学着学着就发现学过的东西很容易忘记，所以打算创建一个个人博客来进行记录总结，一方面可以总结学习过程中遇到的错误和困难，一方面也可以方便其他童鞋进行参考，让我们一起加油吧。","path":"about-me/index.html"}],"posts":[{"title":"js实现数字滚动","text":"最近做年度奋斗轨迹项目的时候，用到了数字滚动效果，记录一下~学习参考：https://blog.csdn.net/weixin_53259688/article/details/113659936 实例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;snow&lt;/title&gt; &lt;script src=&quot;./js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/numScroll.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .box { line-height: 24px; height: 24px; overflow: hidden; display: inline-block; position: relative; margin-top: 2px; } /* 该样式必须有 */ .mt-number-animate .mt-number-animate-dom { width: 11px; text-align: center; float: left; position: relative; top: 0; } /* 该样式必须有 */ .mt-number-animate .mt-number-animate-dom .mt-number-animate-span { width: 100%; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; var plnum = 368; //幸运数字(不要直接写在页面上) //调用numberAnimate方法，传入num（数字）、speed（动画执行时间） $(&apos;.box&apos;).numberAnimate({ num: plnum, speed: 1000 }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; numScroll.js: ;(function($) { $.fn.numberAnimate = function(setting) { var defaults = { speed : 1000,//动画速度 num : &quot;&quot;, //初始化值 iniAnimate : true, //是否要初始化动画效果 symbol : &apos;&apos;,//默认的分割符号，千，万，千万 dot : 0 //保留几位小数点 } //如果setting为空，就取default的值 var setting = $.extend(defaults, setting); //如果对象有多个，提示出错 if($(this).length &gt; 1){ alert(&quot;just only one obj!&quot;); return; } //如果未设置初始化值。提示出错 if(setting.num === &quot;&quot;){ alert(&quot;must set a num!&quot;); return; } var nHtml = &apos;&lt;div class=&quot;mt-number-animate-dom&quot; data-num=&quot;{{num}}&quot;&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;0&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;1&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;2&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;3&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;4&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;5&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;6&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;7&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;8&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;9&lt;/span&gt;\\ &lt;span class=&quot;mt-number-animate-span&quot;&gt;.&lt;/span&gt;\\ &lt;/div&gt;&apos;; //数字处理 var numToArr = function(num){ num = parseFloat(num).toFixed(setting.dot); if(typeof(num) == &apos;number&apos;){ var arrStr = num.toString().split(&quot;&quot;); }else{ var arrStr = num.split(&quot;&quot;); } return arrStr; } //设置DOM symbol:分割符号 var setNumDom = function(arrStr){ var shtml = &apos;&lt;div class=&quot;mt-number-animate&quot;&gt;&apos;; for(var i=0,len=arrStr.length; i&lt;len; i++){ if(i != 0 &amp;&amp; (len-i)%4 == 0 &amp;&amp; setting.symbol != &quot;&quot; &amp;&amp; arrStr[i]!=&quot;.&quot;){ shtml += &apos;&lt;div class=&quot;mt-number-animate-dot&quot;&gt;&apos;+setting.symbol+&apos;&lt;/div&gt;&apos;+nHtml.replace(&quot;{{num}}&quot;,arrStr[i]); }else if(i==0 &amp;&amp; arrStr[i]==&quot;-&quot;){ shtml += &apos;&lt;div class=&quot;mt-number-animate-dot&quot;&gt;&apos;+arrStr[i]+&apos;&lt;/div&gt;&apos;; }else{ shtml += nHtml.replace(&quot;{{num}}&quot;,arrStr[i]); } } shtml += &apos;&lt;/div&gt;&apos;; return shtml; } //执行动画 var runAnimate = function($parent){ $parent.find(&quot;.mt-number-animate-dom&quot;).each(function() { var num = $(this).attr(&quot;data-num&quot;); if(num != &quot;-&quot;) { num = (num==&quot;.&quot;?10:num); var spanHei = $(this).height()/11; //11为元素个数 var thisTop = -num*spanHei+&quot;px&quot;; if(thisTop != $(this).css(&quot;top&quot;)){ if(setting.iniAnimate){ //HTML5不支持 if(!window.applicationCache){ $(this).animate({ top : thisTop }, setting.speed); }else{ $(this).css({ &apos;transform&apos;:&apos;translateY(&apos;+thisTop+&apos;)&apos;, &apos;-ms-transform&apos;:&apos;translateY(&apos;+thisTop+&apos;)&apos;, /* IE 9 */ &apos;-moz-transform&apos;:&apos;translateY(&apos;+thisTop+&apos;)&apos;, /* Firefox */ &apos;-webkit-transform&apos;:&apos;translateY(&apos;+thisTop+&apos;)&apos;, /* Safari 和 Chrome */ &apos;-o-transform&apos;:&apos;translateY(&apos;+thisTop+&apos;)&apos;, &apos;-ms-transition&apos;:setting.speed/1000+&apos;s&apos;, &apos;-moz-transition&apos;:setting.speed/1000+&apos;s&apos;, &apos;-webkit-transition&apos;:setting.speed/1000+&apos;s&apos;, &apos;-o-transition&apos;:setting.speed/1000+&apos;s&apos;, &apos;transition&apos;:setting.speed/1000+&apos;s&apos; }); } }else{ setting.iniAnimate = true; $(this).css({ top : thisTop }); } } } }); } //初始化 var init = function($parent){ //初始化 $parent.html(setNumDom(numToArr(setting.num))); runAnimate($parent); }; //重置参数 this.resetData = function(num){ var newArr = numToArr(num); var $dom = $(this).find(&quot;.mt-number-animate-dom&quot;); if($dom.length &lt; newArr.length){ $(this).html(setNumDom(numToArr(num))); }else{ $dom.each(function(index, el) { $(this).attr(&quot;data-num&quot;,newArr[index]); }); } runAnimate($(this)); } //init init($(this)); return this; } })(jQuery); 实现效果：","path":"2022/01/08/js实现数字滚动/"},{"title":"js实现雪花效果","text":"最近做年度奋斗轨迹项目的时候，用到了雪花飘落效果，记录一下~学习参考：https://blog.csdn.net/hhzzcc_/article/details/79867154 改编完的实例： 实例1（效果较好）&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;snow&lt;/title&gt; &lt;style&gt; body,html{ margin: 0; padding: 0; overflow: hidden; height: 100%; background: black; } .snow{ //background: white; position: absolute; color:#FFF; font-size:20px; //width: 20px; //height: 20px; //border-radius: 50%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //获取屏幕宽高 var windowWidth = window.screen.width; var windowHeight = window.screen.height; //创建雪花 function createSnow(){ var left = 0; var top = 0; //定义一个初始化随机数,使雪花在屏幕中 var left_random = Math.random() * windowWidth; var top_random = Math.random()* windowHeight; var div = document.createElement(&apos;div&apos;); div.innerHTML=&quot;✽&quot;; //div的内容 div.className = &apos;snow&apos;; div.style.transform = &apos;scale(&apos;+(Math.random())+&apos;)&apos; document.body.appendChild(div); //雪花飘落 setInterval(function () { div.style.left = left_random + left +&apos;px&apos;; div.style.top = top_random + top +&apos;px&apos; left += 0.2; top += 0.2; //如果雪花跑到屏幕外面了,让雪花重新返回屏幕顶部 if(left_random + left &gt;= windowWidth){ left_random = Math.random(); left = 0; } if(top_random + top &gt;= windowHeight){ top_random = Math.random(); top = 0; } },10) } for(var i = 0 ; i &lt; 200 ; i++){ createSnow() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 其中，可以通过调节number的大小来控制雪花的多少 for(var i = 0 ; i &lt; number ; i++){ createSnow() } 通过调节top、和left的自增大小x和y、来调整雪花飘落的方向和飘落快慢 div.style.left = left_random + left +&apos;px&apos;; div.style.top = top_random + top+&apos;px&apos; left += x; top += y; 实例2&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;snow&lt;/title&gt; &lt;style&gt; *{padding: 0;margin: 0;} body{ background:#000; width: 100%; height: 100%; overflow:hidden; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;flame&quot;&gt;&lt;/div&gt; &lt;script&gt; function Obj(){} //创建一个对象 /*为这个对象添加一个具有一个参数的原型方法*/ Obj.prototype.draw=function(o){ var speed=0; //雪花每次下落的数值（10px） var startPosLeft=Math.ceil(Math.random()*document.documentElement.clientWidth);//设置雪花随机的开始x值的大小 o.style.opacity=(Math.ceil(Math.random()*3)+7)/10; //设置透明度 o.style.left=startPosLeft+&apos;px&apos;; o.style.color=&quot;#fff&quot;; o.style.fontSize=12+Math.ceil(Math.random()*14)+&apos;px&apos;; setInterval(function(){ //雪花下落的top值小鱼屏幕的可视区域高时执行下列 if(speed&lt;document.documentElement.clientHeight){ o.style.top=speed+&apos;px&apos;; o.style.left=startPosLeft+Math.ceil(Math.random()*8)+&apos;px&apos;; speed+=10; } else{ o.style.display=&apos;none&apos;; } },400); } var flame=document.getElementById(&apos;flame&apos;); /*使用setInterval定时器每800毫秒创建一个雪花*/ setInterval(function(){ var odiv=document.createElement(&apos;div&apos;); //创建div odiv.innerHTML=&quot;✽&quot;; //div的内容 odiv.style.position=&apos;absolute&apos;; //div的绝对定位 flame.appendChild(odiv); //把创建好的div放进flame中 var obj=new Obj(); //创建函数 obj.draw(odiv); //执行obj的draw方法 },800); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","path":"2022/01/08/js实现雪花效果/"},{"title":"H5视频、音频不能自动播放","text":"H5视频、音频不能自动播放,Uncaught (in promise) DOMException: play() failed because the user didn’t Uncaught (in promise) DOMException: play() failed because the user didn’t interact with the document 未捕获(承诺中)DOMException: play()失败，因为用户没有首先与文档交互。 错误原因：Chrome的autoplay政策在2018年4月做了更改。在最新版的Chrome浏览器（以及所有以Chromium为内核的浏览器）中，已不再允许自动播放音频和视频。。就算你为video或audio标签设置了autoplay属性也一样不能自动播放。 解决办法一：修改浏览器默认设置第一步，在chrome浏览器中输入：chrome://flags/#autoplay-policy 第二步，在Autoplay policy中将Default改为No user gesture is required 第三步，点击下方的“RELAUNCH NOW”,就大功告成了！ 解决方法二：设置一个按钮， 按钮点击后触发自动播放官方说的是为了移动端的带宽和仿扰民阻止了自动播放，因此，只要用户在页面上有交互动作后，就可以自动播放了；设置一个按钮， 按钮点击后触发自动播放js $(&quot;#start&quot;).click(function(){ vMP3 = document.getElementById(&quot;myAudio&quot;); vMP3.play(); }) html &lt;audio id=&quot;myAudio&quot; src=&quot;./music/dayDreamingPilot.mp3&quot; controls&gt; &lt;source src=&quot;6&quot; type=&quot;audio/mpeg&quot;&gt; 您的浏览器不支持audio元素 &lt;/audio&gt; &lt;button id=&quot;start&quot;&gt;开启&lt;/button&gt;","path":"2022/01/06/H5视频、音频不能自动播放/"},{"title":"几种页面滑动插件（swiper、fullPage、hammer）","text":"最近做年度奋斗轨迹项目的时候，需要引用页面滑动插件，刚开始用的fullPage插件，做的差不多了才发现引用fullPage在ios机上滑动会出现卡顿的现象，于是乎又含泪重新换成swiper插件，因此记录一下几个滑动插件的差别~学习参考：https://www.cnblogs.com/rachelch/p/9331054.html 1、使用hammer，自己实现滑动垂直切换页面（不推荐！！）&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;意礴足型护照&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1&quot;&gt; &lt;meta name=&quot;MobileOptimized&quot; content=&quot;360&quot;/&gt; &lt;style&gt; *{ padding: 0; margin: 0; } .swiper-container{position:relative;} .swiper-slide{ width: 100%; height: 100%; background: #fff; position: absolute; top:0; left:0; } .slide1{ background: pink; } .slide2{ background: lightgreen; } .slide3{background: dodgerblue} .slide4{background:mediumpurple} .slide5{background:darkorange} .slide6{ background: orangered; } .font-size{ height: 10%; box-shadow: 0px 0px 20px 0px #E6E6E6; } .font-long{ height: 27%; margin-top: 1vh; display: flex; display: -webkit-flex; flex-direction: column; -webkit-flex-direction: column; box-shadow: 0px 0px 20px 0px #E6E6E6; } .font-long-title{ height: 34px; line-height: 34px; background-color: rgba(249,249,249,1); flex: none; -webkit-flex: none; } .foot-scale{ flex: auto; -webkit-flex: auto; display: flex; display: -webkit-flex; align-items: center; -webkit-align-items: center; justify-content: space-between; -webkit-justify-content: space-between; } .font-weight{ height: 28%; margin-top: 1vh; display: flex; display: -webkit-flex; flex-direction: column; -webkit-flex-direction: column; box-shadow: 0px 0px 20px 0px #E6E6E6; } .arch-turn{ height: 32%; margin-top: 1vh; } .arch-turn-title{ height: 34px; line-height: 34px; background-color: rgba(249,249,249,1); } .arch-turn&gt;ul{ width: 100%; height: 100%; } .arch-turn li{ width: 49%; height: 100%; float: left; box-shadow: 0px 0px 20px 0px #E6E6E6; } .arch-turn li:first-child{ margin-right: 2%; } .arch-turn li&gt;div{ width: 100%; } .foot-arch{ width: 100%; height: 19vh; background-position: center; background-repeat: no-repeat; background-size: contain; margin-top: 1vh; } .fs-16{ font-size: 16px; } .fs-12{ font-size: 12px; } .hide{ display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--滑动页面--&gt; &lt;div class=&quot;swiper-container&quot; id=&quot;swiperContainer&quot;&gt; &lt;!-- 第一页--&gt; &lt;div class=&quot;swiper-slide slide1&quot; id=&quot;slide1&quot; data-name=&quot;slide&quot;&gt; &lt;div style=&quot;height: 50%;background: white;&quot;&gt;1111&lt;/div&gt; &lt;/div&gt; &lt;!-- 第二页--&gt; &lt;div class=&quot;swiper-slide slide2&quot; id=&quot;slide2&quot; data-name=&quot;slide&quot;&gt; &lt;div style=&quot;height: 70%;background: white;&quot;&gt;2222&lt;/div&gt; &lt;/div&gt; &lt;!-- 第三页--&gt; &lt;div class=&quot;swiper-slide slide3&quot; id=&quot;slide3&quot; data-name=&quot;slide&quot;&gt; 33333 &lt;/div&gt; &lt;!-- 第四页--&gt; &lt;div class=&quot;swiper-slide slide4&quot; id=&quot;slide4&quot; data-name=&quot;slide&quot;&gt; 4444 &lt;/div&gt; &lt;!-- 第五页--&gt; &lt;div class=&quot;swiper-slide slide5&quot; id=&quot;slide5&quot; data-name=&quot;slide&quot;&gt; 55555 &lt;/div&gt; &lt;!-- 第六页 --&gt; &lt;div class=&quot;swiper-slide slide6&quot; id=&quot;slide6&quot; data-name=&quot;slide&quot;&gt; 66666 &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/hammer.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var main= { height:$(window).height(), width:$(window).width(), init:function(){ function fixPagesHeight() { $(&apos;.swiper-slide&apos;).css({&apos;height&apos;: main.height}); var length = $(&quot;.swiper-container&gt;.swiper-slide&quot;).length; $(&apos;.swiper-container&apos;).css({&apos;height&apos;: length*main.height}); } $(window).on(&apos;resize&apos;, function() { fixPagesHeight(); }) fixPagesHeight(); var swiperTotal=$(&quot;.swiper-container&gt;.swiper-slide&quot;); var length=swiperTotal.length; $.each(swiperTotal,function(i,item){ swiperTotal.eq(i).css(&quot;z-index&quot;,length-i).attr(&quot;data-num&quot;,i+1); var dataNum = swiperTotal.eq(i).attr(&apos;data-num&apos;); swiperTotal.eq(i).css(&quot;top&quot;, (dataNum-1) * main.height); }) function loop(k){ for(var i=0; i&lt; length; i++){ if(k&lt; length+k){ swiperTotal.eq(i).animate({&apos;top&apos;: main.height*k+&apos;px&apos;}); k++; }else{ return false; } } } function setTop(num){ var k = 0; if(num){ k = 2 - num; loop(k); } } function setTop2(num){ var k = 0; if(num){ k = -num; loop(k); } } //为了解决swiper-slide里面很多元素的时候，查找不到swiper-slide的data-num function getparentele(ele){ if(ele.dataset &amp;&amp; ele.dataset.name){ if(ele.dataset.name == &apos;slide&apos;){ return ele }else{ return getparentele(ele.parentNode) } }else{ return getparentele(ele.parentNode) } } //默认行为只支持左右，上下操作还需要额外设置 var element = document.getElementById(&apos;swiperContainer&apos;); var hammertime = new Hammer(element); hammertime.get(&apos;swipe&apos;).set({ direction: Hammer.DIRECTION_ALL }); hammertime .on(&apos;swipedown&apos;, function(e){ var num = parseInt(getparentele(e.target).dataset.num); if(num&gt;1){ setTop(num); } }) .on(&apos;swipeup&apos;, function(e){ var num = parseInt(getparentele(e.target).dataset.num); if(num&lt;6){ setTop2(num); } }); /* *上述虽然能滑动切换页面，但是会存在一个问题，当快速滑动的时候，会滑动好几个页面。 * swiper滑动就相对稳定。 * fullPage再ios手机上滑动切页，很不稳定。没有swiper稳定 * * */ } } $(window).load(function(){ main.init(); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 缺点：上述虽然能滑动切换页面，但是会存在一个问题，当快速滑动的时候，会滑动好几个页面。 2、使用fullPage（不推荐！！）教学官网：http://fullpage.81hu.com/实例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta name=&apos;viewport&apos; content=&apos;width=device-width, initial-scale=1.0, user-scalable=no&apos;/&gt; &lt;meta name=&quot;MobileOptimized&quot; content=&quot;360&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/jquery.fullPage.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;dowebok&quot;&gt; &lt;div class=&quot;section&quot; id=&quot;page1&quot; style=&quot;background: hotpink;&quot;&gt; 1 &lt;/div&gt; &lt;div class=&quot;section&quot; id=&quot;page2&quot; style=&quot;background: pink;&quot;&gt; 2 &lt;/div&gt; &lt;div class=&quot;section&quot; id=&quot;page3&quot; style=&quot;background: lightgreen;&quot;&gt; 3 &lt;/div&gt; &lt;div class=&quot;section&quot; id=&quot;page4&quot; style=&quot;background: dodgerblue&quot;&gt; 4 &lt;/div&gt; &lt;div class=&quot;section&quot; id=&quot;page5&quot; style=&quot;background:mediumpurple&quot;&gt; 5 &lt;/div&gt; &lt;div class=&quot;section&quot; id=&quot;page6&quot; style=&quot;background:darkorange&quot;&gt; 6 &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.fullPage.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&apos;#dowebok&apos;).fullpage({ afterLoad : function (anchorLink, index) { }, onLeave : function (index, direction) { console.log(index, direction) } }); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 缺点：fullPage在ios手机上滑动切页，很不稳定。滑动切换的时候，波动比较大 3、swiper（推荐！！）教学官网：https://www.swiper.com.cn/实例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta name=&apos;viewport&apos; content=&apos;width=device-width, initial-scale=1.0, maximum-scale=1.0&apos;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/swiper.min.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;swiper-container&quot; id=&quot;swiperContainer&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;!-------------slide1-----------------&gt; &lt;section class=&quot;swiper-slide&quot; style=&quot;background:pink;&quot;&gt; 1 &lt;/section&gt; &lt;!---------------slide2--------------&gt; &lt;section class=&quot;swiper-slide&quot; style=&quot;background:yellow;&quot;&gt; 2 &lt;/section&gt; &lt;!----------------slide3--------------&gt; &lt;section class=&quot;swiper-slide&quot;&gt; 3 &lt;/section&gt; &lt;!-------------slide4-----------------&gt; &lt;section class=&quot;swiper-slide&quot;&gt; 4 &lt;/section&gt; &lt;!-------------slide5-----------------&gt; &lt;section class=&quot;swiper-slide&quot;&gt; 5 &lt;/section&gt; &lt;!-------------slide6-----------------&gt; &lt;section class=&quot;swiper-slide&quot;&gt; 6 &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/swiper.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var mySwiper = new Swiper (&apos;.swiper-container&apos;, { direction : &apos;vertical&apos;, on: { //滑动到最后一个slide触发 reachEnd: function(){ console.log(&apos;到了最后一个slide&apos;); }, //判断滑动到了哪一页 slideChangeTransitionEnd: function(){ console.log(this.activeIndex); if(this.activeIndex == 6){ $(&apos;#array&apos;).css(&apos;display&apos;,&apos;none&apos;); }else{ $(&apos;#array&apos;).css(&apos;display&apos;,&apos;block&apos;); } } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 优点：稳定！相比上面两种，swiper在ios上滑动也没有出现晃动的问题，特别的稳定","path":"2022/01/05/几种页面滑动插件（swiper、fullPage、hammer）/"},{"title":"Echarts-地图-各城市经纬度总结","text":"学习参考：https://zhuanlan.zhihu.com/p/28653697 province 吉林 通化 [125.94265, 41.736397]吉林市 [126.564544, 43.871988]白山 [126.435798, 41.945859]辽源 [125.133686, 42.923303]白城 [122.840777, 45.621086]长春 [125.313642, 43.898338]延边 [129.485902, 42.896414]四平 [124.391382, 43.175525]松原 [124.832995, 45.136049] province 黑龙江 七台河 [131.019048, 45.775005]鸡西 [130.941767, 45.32154]齐齐哈尔 [123.987289, 47.3477]黑河 [127.50083, 50.25069]哈尔滨 [126.657717, 45.773225]大庆 [125.02184, 46.596709]鹤岗 [130.292472, 47.338666]大兴安岭地区 [124.196104, 51.991789]伊春 [128.910766, 47.734685]佳木斯 [130.284735, 46.81378]牡丹江 [129.608035, 44.588521]绥化 [126.989095, 46.646064]双鸭山 [131.171402, 46.655102] province 安徽 巢湖 [117.88049, 31.608733]安庆 [117.058739, 30.537898]淮南 [117.018639, 32.642812]淮北 [116.791447, 33.960023]蚌埠 [117.35708, 32.929499]宿州 [116.988692, 33.636772]合肥 [117.282699, 31.866942]阜阳 [115.820932, 32.901211]池州 [117.494477, 30.660019]六安 [116.505253, 31.755558]亳州 [115.787928, 33.871211]黄山 [118.29357, 29.734435]马鞍山 [118.515882, 31.688528]铜陵 [117.819429, 30.94093]滁州 [118.32457, 32.317351] province 贵州 安顺 [105.92827, 26.228595]黔东南州 [107.985353, 26.583992]六盘水 [104.852087, 26.591866]贵阳 [106.709177, 26.629907]黔西南州 [104.900558, 25.095148]毕节地区 [105.300492, 27.302612]黔南州 [107.523205, 26.264536]遵义 [106.93126, 27.699961]铜仁地区 [109.196161, 27.726271] province 天津 天津 [117.2, 39.13] province 北京 北京 [116.46, 39.92] province 澳门 澳门 [113.54, 22.19] province 内蒙古 兴安盟 [122.048167, 46.083757]呼伦贝尔 [119.760822, 49.201636]赤峰 [118.930761, 42.297112]鄂尔多斯 [109.993706, 39.81649]乌兰察布 [113.112846, 41.022363]锡林郭勒盟 [116.02734, 43.939705]包头 [109.846239, 40.647119]阿拉善盟 [105.695683, 38.843075]乌海 [106.831999, 39.683177]呼和浩特 [111.660351, 40.828319]巴彦淖尔 [107.423807, 40.76918]通辽 [122.260363, 43.633756] province 广西 桂林 [110.26092, 25.262901]河池 [108.069948, 24.699521]防城港 [108.351791, 21.617398]贺州 [111.552594, 24.411054]柳州 [109.422402, 24.329053]玉林 [110.151676, 22.643974]北海 [109.122628, 21.472718]来宾 [109.231817, 23.741166]梧州 [111.305472, 23.485395]南宁 [108.297234, 22.806493]百色 [106.631821, 23.901512]崇左 [107.357322, 22.415455]钦州 [108.638798, 21.97335]贵港 [109.613708, 23.103373] province 宁夏 固原 [106.285268, 36.021523]吴忠 [106.208254, 37.993561]石嘴山 [106.379337, 39.020223]银川 [106.206479, 38.502621]中卫 [105.196754, 37.521124] province 江苏 宿迁 [118.296893, 33.95205]镇江 [119.455835, 32.204409]泰州 [119.919606, 32.476053]盐城 [120.148872, 33.379862]南通 [120.873801, 32.014665]常州 [119.981861, 31.771397]苏州 [120.619907, 31.317987]徐州 [117.188107, 34.271553]淮安 [119.030186, 33.606513]无锡 [120.305456, 31.570037]连云港 [119.173872, 34.601549]南京 [118.778074, 32.057236]扬州 [119.427778, 32.408505] province 广东 肇庆 [112.479653, 23.078663]潮州 [116.630076, 23.661812]阳江 [111.97701, 21.871517]河源 [114.713721, 23.757251]佛山 [113.134026, 23.035095]清远 [113.040773, 23.698469]惠州 [114.410658, 23.11354]江门 [113.078125, 22.575117]云浮 [112.050946, 22.937976]茂名 [110.931245, 21.668226]湛江 [110.365067, 21.257463]中山 [113.42206, 22.545178]珠海 [113.562447, 22.256915]汕尾 [115.372924, 22.778731]揭阳 [116.379501, 23.547999]梅州 [116.126403, 24.304571]深圳 [114.025974, 22.546054]汕头 [116.72865, 23.383908]韶关 [113.594461, 24.80296]东莞 [113.763434, 23.043024]广州 [113.30765, 23.120049] province 辽宁 阜新 [121.660822, 42.01925]锦州 [121.147749, 41.130879]沈阳 [123.432791, 41.808645]鞍山 [123.007763, 41.118744]朝阳 [120.446163, 41.571828]铁岭 [123.85485, 42.299757]葫芦岛 [120.860758, 40.74303]抚顺 [123.92982, 41.877304]辽阳 [123.172451, 41.273339]大连 [121.593478, 38.94871]营口 [122.233391, 40.668651]丹东 [124.338543, 40.129023]盘锦 [122.073228, 41.141248]本溪 [123.778062, 41.325838] province 青海 海南州 [100.624066, 36.284364]海东地区 [102.085207, 36.51761]海北州 [100.879802, 36.960654]果洛州 [100.223723, 34.480485]黄南州 [102.0076, 35.522852]玉树州 [97.013316, 33.00624]西宁 [101.767921, 36.640739]海西州 [97.342625, 37.373799] province 云南 文山 [104.089112, 23.401781]西双版纳 [100.803038, 22.009433]丽江 [100.229628, 26.875351]红河州 [103.384065, 23.367718]大理州 [100.223675, 25.5969]楚雄州 [101.529382, 25.066356]保山 [99.177996, 25.120489]昭通 [103.725021, 27.340633]迪庆州 [99.713682, 27.831029]曲靖 [103.782539, 25.520758]临沧 [100.092613, 23.887806]普洱 [100.980058, 22.788778]德宏州 [98.589434, 24.44124]玉溪 [102.545068, 24.370447]怒江州 [98.859932, 25.860677]昆明 [102.714601, 25.049153] province 湖南 湘西州 [109.745746, 28.317951]张家界 [110.48162, 29.124889]株洲 [113.131695, 27.827433]长沙 [112.979353, 28.213478]益阳 [112.366547, 28.588088]衡阳 [112.583819, 26.898164]娄底 [111.996396, 27.741073]湘潭 [112.935556, 27.835095]永州 [111.614648, 26.435972]常德 [111.653718, 29.012149]岳阳 [113.146196, 29.378007]郴州 [113.037704, 25.782264]邵阳 [111.461525, 27.236811]怀化 [109.986959, 27.557483] province 海南 白沙 [109.358586, 19.216056]定安 [110.32009, 19.490991]琼中 [109.861849, 19.039771]琼海 [110.414359, 19.21483]儋州 [109.413973, 19.571153]保亭 [109.656113, 18.597592]文昌 [110.780909, 19.750947]万宁 [110.292505, 18.839886]东方 [108.85101, 18.998161]乐东 [109.062698, 18.658614]陵水 [109.948661, 18.575985]临高 [109.724101, 19.805922]海口 [110.330802, 20.022071]屯昌 [110.063364, 19.347749]昌江 [109.0113, 19.222483]澄迈 [109.996736, 19.693135]五指山 [109.51775, 18.831306]三亚 [109.522771, 18.257776] province 甘肃 金昌 [102.208126, 38.516072]张掖 [100.459892, 38.93932]陇南 [104.934573, 33.39448]白银 [104.171241, 36.546682]兰州 [103.823305, 36.064226]定西 [104.626638, 35.586056]平凉 [106.688911, 35.55011]天水 [105.736932, 34.584319]庆阳 [107.644227, 35.726801]临夏州 [103.215249, 35.598514]甘南州 [102.917442, 34.992211]酒泉 [98.508415, 39.741474]嘉峪关 [98.281635, 39.802397]武威 [102.640147, 37.933172] province 山东 威海 [122.093958, 37.528787]泰安 [117.089415, 36.188078]济南 [117.024967, 36.682785]滨州 [117.968292, 37.405314]济宁 [116.600798, 35.402122]临沂 [118.340768, 35.072409]菏泽 [115.46336, 35.26244]日照 [119.50718, 35.420225]德州 [116.328161, 37.460826]聊城 [115.986869, 36.455829]莱芜 [117.684667, 36.233654]青岛 [120.384428, 36.105215]潍坊 [119.142634, 36.716115]东营 [118.583926, 37.487121]枣庄 [117.279305, 34.807883]烟台 [121.309555, 37.536562]淄博 [118.059134, 36.804685] province 山西 晋城 [112.867333, 35.499834]朔州 [112.479928, 39.337672]大同 [113.290509, 40.113744]临汾 [111.538788, 36.099745]太原 [112.550864, 37.890277]晋中 [112.738514, 37.693362]运城 [111.006854, 35.038859]阳泉 [113.569238, 37.869529]吕梁 [111.143157, 37.527316]长治 [113.120292, 36.201664]忻州 [112.727939, 38.461031] province 江西 吉安 [114.992039, 27.113848]九江 [115.999848, 29.71964]新余 [114.947117, 27.822322]抚州 [116.360919, 27.954545]宜春 [114.400039, 27.81113]南昌 [115.893528, 28.689578]上饶 [117.955464, 28.457623]鹰潭 [117.03545, 28.24131]景德镇 [117.186523, 29.303563]赣州 [114.935909, 25.845296]萍乡 [113.859917, 27.639544] province 西藏 拉萨 [91.111891, 29.662557]那曲地区 [92.067018, 31.48068]昌都地区 [97.185582, 31.140576]山南地区 [91.750644, 29.229027]林芝地区 [94.349985, 29.666941]日喀则地区 [88.891486, 29.269023]阿里地区 [81.107669, 30.404557] province 上海 上海 [121.48, 31.22] province 新疆 图木舒克 [79.198155, 39.889223]克孜勒苏州 [76.137564, 39.750346]阿勒泰地区 [88.137915, 47.839744]乌鲁木齐 [87.564988, 43.84038]阿克苏地区 [80.269846, 41.171731]克拉玛依 [84.88118, 45.594331]五家渠 [87.565449, 44.368899]巴音郭楞 [86.121688, 41.771362]伊犁州 [81.297854, 43.922248]和田地区 [79.930239, 37.116774]阿拉尔 [81.291737, 40.61568]博尔塔拉州 [82.052436, 44.913651]喀什地区 [75.992973, 39.470627]哈密地区 [93.528355, 42.858596]石河子 [86.041865, 44.308259]塔城地区 [82.974881, 46.758684]吐鲁番地区 [89.181595, 42.96047]昌吉州 [87.296038, 44.007058] province 四川 遂宁 [105.564888, 30.557491]达州 [107.494973, 31.214199]南充 [106.105554, 30.800965]广安 [106.63572, 30.463984]阿坝州 [102.228565, 31.905763]宜宾 [104.633019, 28.769675]乐山 [103.760824, 29.600958]绵阳 [104.705519, 31.504701]眉山 [103.84143, 30.061115]德阳 [104.402398, 31.13114]巴中 [106.757916, 31.869189]成都 [104.067923, 30.679943]内江 [105.073056, 29.599462]凉山州 [102.259591, 27.892393]泸州 [105.44397, 28.89593]甘孜州 [101.969232, 30.055144]攀枝花 [101.722423, 26.587571]广元 [105.819687, 32.44104]资阳 [104.63593, 30.132191]自贡 [104.776071, 29.359157]雅安 [103.009356, 29.999716] province 香港 香港 [114.17, 22.28] province 重庆 重庆 [106.54, 29.59] province 湖北 神农架林区 [110.487231, 31.595768]仙桃 [113.387448, 30.293966]天门 [113.12623, 30.649047]随州 [113.379358, 31.717858]鄂州 [114.895594, 30.384439]十堰 [110.801229, 32.636994]恩施 [109.517433, 30.308978]武汉 [114.3162, 30.581084]襄阳 [112.176326, 32.094934]黄石 [115.050683, 30.216127]宜昌 [111.310981, 30.732758]潜江 [112.768768, 30.343116]黄冈 [114.906618, 30.446109]孝感 [113.935734, 30.927955]荆州 [112.241866, 30.332591]荆门 [112.21733, 31.042611]咸宁 [114.300061, 29.880657] province 福建 厦门 [118.103886, 24.489231]南平 [118.181883, 26.643626]三明 [117.642194, 26.270835]莆田 [119.077731, 25.44845]泉州 [118.600362, 24.901652]宁德 [119.542082, 26.656527]龙岩 [117.017997, 25.078685]福州 [119.330221, 26.047125]漳州 [117.676205, 24.517065] province 台湾 台湾 [121.3, 25.03] province 河北 张家口 [114.893782, 40.811188]保定 [115.49481, 38.886565]承德 [117.933822, 40.992521]秦皇岛 [119.604368, 39.945462]沧州 [116.863806, 38.297615]廊坊 [116.703602, 39.518611]衡水 [115.686229, 37.746929]唐山 [118.183451, 39.650531]邢台 [114.520487, 37.069531]石家庄 [114.522082, 38.048958]邯郸 [114.482694, 36.609308] province 河南 安阳 [114.351807, 36.110267]信阳 [114.085491, 32.128582]周口 [114.654102, 33.623741]开封 [114.351642, 34.801854]许昌 [113.835312, 34.02674]漯河 [114.046061, 33.576279]郑州 [113.649644, 34.75661]三门峡 [111.181262, 34.78332]驻马店 [114.049154, 32.983158]洛阳 [112.447525, 34.657368]南阳 [112.542842, 33.01142]鹤壁 [114.29777, 35.755426]商丘 [115.641886, 34.438589]平顶山 [113.300849, 33.745301]新乡 [113.91269, 35.307258]焦作 [113.211836, 35.234608]濮阳 [115.026627, 35.753298] province 浙江 嘉兴 [120.760428, 30.773992]台州 [121.440613, 28.668283]舟山 [122.169872, 30.03601]丽水 [119.929576, 28.4563]宁波 [121.579006, 29.885259]衢州 [118.875842, 28.95691]绍兴 [120.592467, 30.002365]湖州 [120.137243, 30.877925]杭州 [120.219375, 30.259244]金华 [119.652576, 29.102899]温州 [120.690635, 28.002838] province 陕西 安康 [109.038045, 32.70437]延安 [109.50051, 36.60332]榆林 [109.745926, 38.279439]宝鸡 [107.170645, 34.364081]西安 [108.953098, 34.2778]汉中 [107.045478, 33.081569]咸阳 [108.707509, 34.345373]渭南 [109.483933, 34.502358]商洛 [109.934208, 33.873907]铜川 [108.968067, 34.908368]","path":"2021/12/22/Echarts-地图-各城市经纬度总结/"},{"title":"Echarts-引入地图实例","text":"最近做年度奋斗轨迹项目的时候，需要做一个功能，展示个人的出差轨迹，这里就要引入地图，选择Echarts插件来实现该功能，记录一下Echarts地图的引入方法与实例操作~学习参考（Echarts官网）：https://echarts.apache.org/zh/index.html 让我们先看下效果图： 实例：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;echarts中国地图&lt;/title&gt; &lt;style&gt; .centerItem { width: 856px; height: 640px; background-color: #003077; margin: 110px auto 0 auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 中国地图展示 --&gt; &lt;div id=&quot;mapBox&quot; class=&quot;centerItem&quot;&gt;&lt;/div&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src=&quot;echarts.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;china.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 基于准备好的dom，初始化echarts实例 var mapBoxEchart = echarts.init(document.getElementById(&apos;mapBox&apos;)); var geoCoordMap = { //可以在地图上显示的城市的坐标信息 &apos;海外&apos;: [85.8154, 20.2584], //province 吉林 &apos;吉林省&apos;: [125.313642, 43.898338], &apos;通化&apos;: [125.94265, 41.736397], &apos;吉林&apos;: [126.564544, 43.871988], &apos;白山&apos;: [126.435798, 41.945859], &apos;辽源&apos;: [125.133686, 42.923303], &apos;白城&apos;: [122.840777, 45.621086], &apos;长春&apos;: [125.313642, 43.898338], &apos;延边&apos;: [129.485902, 42.896414], &apos;四平&apos;: [124.391382, 43.175525], &apos;松原&apos;: [124.832995, 45.136049], //province 黑龙江 &apos;黑龙江省&apos;: [126.657717, 45.773225], &apos;七台河&apos;: [131.019048, 45.775005], &apos;鸡西&apos;: [130.941767, 45.32154], &apos;齐齐哈尔&apos;: [123.987289, 47.3477], &apos;黑河&apos;: [127.50083, 50.25069], &apos;哈尔滨&apos;: [126.657717, 45.773225], &apos;大庆&apos;: [125.02184, 46.596709], &apos;鹤岗&apos;: [130.292472, 47.338666], &apos;大兴安岭地区&apos;: [124.196104, 51.991789], &apos;伊春&apos;: [128.910766, 47.734685], &apos;佳木斯&apos;: [130.284735, 46.81378], &apos;牡丹江&apos;: [129.608035, 44.588521], &apos;绥化&apos;: [126.989095, 46.646064], &apos;双鸭山&apos;: [131.171402, 46.655102], //province 安徽 &apos;安徽省&apos;: [117.282699, 31.866942], &apos;巢湖&apos;: [117.88049, 31.608733], &apos;安庆&apos;: [117.058739, 30.537898], &apos;淮南&apos;: [117.018639, 32.642812], &apos;淮北&apos;: [116.791447, 33.960023], &apos;蚌埠&apos;: [117.35708, 32.929499], &apos;宿州&apos;: [116.988692, 33.636772], &apos;合肥&apos;: [117.282699, 31.866942], &apos;阜阳&apos;: [115.820932, 32.901211], &apos;池州&apos;: [117.494477, 30.660019], &apos;六安&apos;: [116.505253, 31.755558], &apos;亳州&apos;: [115.787928, 33.871211], &apos;黄山&apos;: [118.29357, 29.734435], &apos;马鞍山&apos;: [118.515882, 31.688528], &apos;铜陵&apos;: [117.819429, 30.94093], &apos;滁州&apos;: [118.32457, 32.317351], //province 贵州 &apos;贵州省&apos;: [106.709177, 26.629907], &apos;安顺&apos;: [105.92827, 26.228595], &apos;黔东南州&apos;: [107.985353, 26.583992], &apos;六盘水&apos;: [104.852087, 26.591866], &apos;贵阳&apos;: [106.709177, 26.629907], &apos;黔西南州&apos;: [104.900558, 25.095148], &apos;毕节地区&apos;: [105.300492, 27.302612], &apos;黔南州&apos;: [107.523205, 26.264536], &apos;遵义&apos;: [106.93126, 27.699961], &apos;铜仁地区&apos;: [109.196161, 27.726271], //province 天津 &apos;天津&apos;: [117.2, 39.13], //province 北京 &apos;北京&apos;: [116.46, 39.92], //province 澳门 &apos;澳门&apos;: [113.54, 22.19], //province 内蒙古 &apos;内蒙古&apos;: [111.660351, 40.828319], &apos;兴安盟&apos;: [122.048167, 46.083757], &apos;呼伦贝尔&apos;: [119.760822, 49.201636], &apos;赤峰&apos;: [118.930761, 42.297112], &apos;鄂尔多斯&apos;: [109.993706, 39.81649], &apos;乌兰察布&apos;: [113.112846, 41.022363], &apos;锡林郭勒盟&apos;: [116.02734, 43.939705], &apos;包头&apos;: [109.846239, 40.647119], &apos;阿拉善盟&apos;: [105.695683, 38.843075], &apos;乌海&apos;: [106.831999, 39.683177], &apos;呼和浩特&apos;: [111.660351, 40.828319], &apos;巴彦淖尔&apos;: [107.423807, 40.76918], &apos;通辽&apos;: [122.260363, 43.633756], //province 广西 &apos;广西省&apos;: [108.297234, 22.806493], &apos;桂林&apos;: [110.26092, 25.262901], &apos;河池&apos;: [108.069948, 24.699521], &apos;防城港&apos;: [108.351791, 21.617398], &apos;贺州&apos;: [111.552594, 24.411054], &apos;柳州&apos;: [109.422402, 24.329053], &apos;玉林&apos;: [110.151676, 22.643974], &apos;北海&apos;: [109.122628, 21.472718], &apos;来宾&apos;: [109.231817, 23.741166], &apos;梧州&apos;: [111.305472, 23.485395], &apos;南宁&apos;: [108.297234, 22.806493], &apos;百色&apos;: [106.631821, 23.901512], &apos;崇左&apos;: [107.357322, 22.415455], &apos;钦州&apos;: [108.638798, 21.97335], &apos;贵港&apos;: [109.613708, 23.103373], //province 宁夏 &apos;宁夏省&apos;: [106.206479, 38.502621], &apos;固原&apos;: [106.285268, 36.021523], &apos;吴忠&apos;: [106.208254, 37.993561], &apos;石嘴山&apos;: [106.379337, 39.020223], &apos;银川&apos;: [106.206479, 38.502621], &apos;中卫&apos;: [105.196754, 37.521124], //province 江苏 &apos;江苏省&apos;: [120.619907, 31.317987], &apos;宿迁&apos;: [118.296893, 33.95205], &apos;镇江&apos;: [119.455835, 32.204409], &apos;泰州&apos;: [119.919606, 32.476053], &apos;盐城&apos;: [120.148872, 33.379862], &apos;南通&apos;: [120.873801, 32.014665], &apos;常州&apos;: [119.981861, 31.771397], &apos;苏州&apos;: [120.619907, 31.317987], &apos;徐州&apos;: [117.188107, 34.271553], &apos;淮安&apos;: [119.030186, 33.606513], &apos;无锡&apos;: [120.305456, 31.570037], &apos;连云港&apos;: [119.173872, 34.601549], &apos;南京&apos;: [118.778074, 32.057236], &apos;扬州&apos;: [119.427778, 32.408505], //province 广东 &apos;广东省&apos;: [113.30765, 23.120049], &apos;肇庆&apos;: [112.479653, 23.078663], &apos;潮州&apos;: [116.630076, 23.661812], &apos;阳江&apos;: [111.97701, 21.871517], &apos;河源&apos;: [114.713721, 23.757251], &apos;佛山&apos;: [113.134026, 23.035095], &apos;清远&apos;: [113.040773, 23.698469], &apos;惠州&apos;: [114.410658, 23.11354], &apos;江门&apos;: [113.078125, 22.575117], &apos;云浮&apos;: [112.050946, 22.937976], &apos;茂名&apos;: [110.931245, 21.668226], &apos;湛江&apos;: [110.365067, 21.257463], &apos;中山&apos;: [113.42206, 22.545178], &apos;珠海&apos;: [113.562447, 22.256915], &apos;汕尾&apos;: [115.372924, 22.778731], &apos;揭阳&apos;: [116.379501, 23.547999], &apos;梅州&apos;: [116.126403, 24.304571], &apos;深圳&apos;: [114.025974, 22.546054], &apos;汕头&apos;: [116.72865, 23.383908], &apos;韶关&apos;: [113.594461, 24.80296], &apos;东莞&apos;: [113.763434, 23.043024], &apos;广州&apos;: [113.30765, 23.120049], //province 辽宁 &apos;辽宁省&apos;: [123.432791, 41.808645], &apos;阜新&apos;: [121.660822, 42.01925], &apos;锦州&apos;: [121.147749, 41.130879], &apos;沈阳&apos;: [123.432791, 41.808645], &apos;鞍山&apos;: [123.007763, 41.118744], &apos;朝阳&apos;: [120.446163, 41.571828], &apos;铁岭&apos;: [123.85485, 42.299757], &apos;葫芦岛&apos;: [120.860758, 40.74303], &apos;抚顺&apos;: [123.92982, 41.877304], &apos;辽阳&apos;: [123.172451, 41.273339], &apos;大连&apos;: [121.593478, 38.94871], &apos;营口&apos;: [122.233391, 40.668651], &apos;丹东&apos;: [124.338543, 40.129023], &apos;盘锦&apos;: [122.073228, 41.141248], &apos;本溪&apos;: [123.778062, 41.325838], //province 青海 &apos;青海省&apos;: [101.767921, 36.640739], &apos;海南州&apos;: [100.624066, 36.284364], &apos;海东地区&apos;: [102.085207, 36.51761], &apos;海北州&apos;: [100.879802, 36.960654], &apos;果洛州&apos;: [100.223723, 34.480485], &apos;黄南州&apos;: [102.0076, 35.522852], &apos;玉树州&apos;: [97.013316, 33.00624], &apos;西宁&apos;: [101.767921, 36.640739], &apos;海西州&apos;: [97.342625, 37.373799], //province 云南 &apos;云南省&apos;: [102.714601, 25.049153], &apos;文山&apos;: [104.089112, 23.401781], &apos;西双版纳&apos;: [100.803038, 22.009433], &apos;丽江&apos;: [100.229628, 26.875351], &apos;红河州&apos;: [103.384065, 23.367718], &apos;大理州&apos;: [100.223675, 25.5969], &apos;楚雄州&apos;: [101.529382, 25.066356], &apos;保山&apos;: [99.177996, 25.120489], &apos;昭通&apos;: [103.725021, 27.340633], &apos;迪庆州&apos;: [99.713682, 27.831029], &apos;曲靖&apos;: [103.782539, 25.520758], &apos;临沧&apos;: [100.092613, 23.887806], &apos;普洱&apos;: [100.980058, 22.788778], &apos;德宏州&apos;: [98.589434, 24.44124], &apos;玉溪&apos;: [102.545068, 24.370447], &apos;怒江州&apos;: [98.859932, 25.860677], &apos;昆明&apos;: [102.714601, 25.049153], //province 湖南 &apos;湖南省&apos;: [112.979353, 28.213478], &apos;湘西州&apos;: [109.745746, 28.317951], &apos;张家界&apos;: [110.48162, 29.124889], &apos;株洲&apos;: [113.131695, 27.827433], &apos;长沙&apos;: [112.979353, 28.213478], &apos;益阳&apos;: [112.366547, 28.588088], &apos;衡阳&apos;: [112.583819, 26.898164], &apos;娄底&apos;: [111.996396, 27.741073], &apos;湘潭&apos;: [112.935556, 27.835095], &apos;永州&apos;: [111.614648, 26.435972], &apos;常德&apos;: [111.653718, 29.012149], &apos;岳阳&apos;: [113.146196, 29.378007], &apos;郴州&apos;: [113.037704, 25.782264], &apos;邵阳&apos;: [111.461525, 27.236811], &apos;怀化&apos;: [109.986959, 27.557483], //province 海南 &apos;海南省&apos;: [110.330802, 20.022071], &apos;白沙&apos;: [109.358586, 19.216056], &apos;定安&apos;: [110.32009, 19.490991], &apos;琼中&apos;: [109.861849, 19.039771], &apos;琼海&apos;: [110.414359, 19.21483], &apos;儋州&apos;: [109.413973, 19.571153], &apos;保亭&apos;: [109.656113, 18.597592], &apos;文昌&apos;: [110.780909, 19.750947], &apos;万宁&apos;: [110.292505, 18.839886], &apos;东方&apos;: [108.85101, 18.998161], &apos;乐东&apos;: [109.062698, 18.658614], &apos;陵水&apos;: [109.948661, 18.575985], &apos;临高&apos;: [109.724101, 19.805922], &apos;海口&apos;: [110.330802, 20.022071], &apos;屯昌&apos;: [110.063364, 19.347749], &apos;昌江&apos;: [109.0113, 19.222483], &apos;澄迈&apos;: [109.996736, 19.693135], &apos;五指山&apos;: [109.51775, 18.831306], &apos;三亚&apos;: [109.522771, 18.257776], //province 甘肃 &apos;甘肃省&apos;: [103.823305, 36.064226], &apos;金昌&apos;: [102.208126, 38.516072], &apos;张掖&apos;: [100.459892, 38.93932], &apos;陇南&apos;: [104.934573, 33.39448], &apos;白银&apos;: [104.171241, 36.546682], &apos;兰州&apos;: [103.823305, 36.064226], &apos;定西&apos;: [104.626638, 35.586056], &apos;平凉&apos;: [106.688911, 35.55011], &apos;天水&apos;: [105.736932, 34.584319], &apos;庆阳&apos;: [107.644227, 35.726801], &apos;临夏州&apos;: [103.215249, 35.598514], &apos;甘南州&apos;: [102.917442, 34.992211], &apos;酒泉&apos;: [98.508415, 39.741474], &apos;嘉峪关&apos;: [98.281635, 39.802397], &apos;武威&apos;: [102.640147, 37.933172], //province 山东 &apos;山东省&apos;: [117.024967, 36.682785], &apos;威海&apos;: [122.093958, 37.528787], &apos;泰安&apos;: [117.089415, 36.188078], &apos;济南&apos;: [117.024967, 36.682785], &apos;滨州&apos;: [117.968292, 37.405314], &apos;济宁&apos;: [116.600798, 35.402122], &apos;临沂&apos;: [118.340768, 35.072409], &apos;菏泽&apos;: [115.46336, 35.26244], &apos;日照&apos;: [119.50718, 35.420225], &apos;德州&apos;: [116.328161, 37.460826], &apos;聊城&apos;: [115.986869, 36.455829], &apos;莱芜&apos;: [117.684667, 36.233654], &apos;青岛&apos;: [120.384428, 36.105215], &apos;潍坊&apos;: [119.142634, 36.716115], &apos;东营&apos;: [118.583926, 37.487121], &apos;枣庄&apos;: [117.279305, 34.807883], &apos;烟台&apos;: [121.309555, 37.536562], &apos;淄博&apos;: [118.059134, 36.804685], //province 山西 &apos;山西省&apos;: [112.550864, 37.890277], &apos;晋城&apos;: [112.867333, 35.499834], &apos;朔州&apos;: [112.479928, 39.337672], &apos;大同&apos;: [113.290509, 40.113744], &apos;临汾&apos;: [111.538788, 36.099745], &apos;太原&apos;: [112.550864, 37.890277], &apos;晋中&apos;: [112.738514, 37.693362], &apos;运城&apos;: [111.006854, 35.038859], &apos;阳泉&apos;: [113.569238, 37.869529], &apos;吕梁&apos;: [111.143157, 37.527316], &apos;长治&apos;: [113.120292, 36.201664], &apos;忻州&apos;: [112.727939, 38.461031], //province 江西 &apos;江西省&apos;: [115.893528, 28.689578], &apos;吉安&apos;: [114.992039, 27.113848], &apos;九江&apos;: [115.999848, 29.71964], &apos;新余&apos;: [114.947117, 27.822322], &apos;抚州&apos;: [116.360919, 27.954545], &apos;宜春&apos;: [114.400039, 27.81113], &apos;南昌&apos;: [115.893528, 28.689578], &apos;上饶&apos;: [117.955464, 28.457623], &apos;鹰潭&apos;: [117.03545, 28.24131], &apos;景德镇&apos;: [117.186523, 29.303563], &apos;赣州&apos;: [114.935909, 25.845296], &apos;萍乡&apos;: [113.859917, 27.639544], //province 西藏 &apos;西藏&apos;: [91.111891, 29.662557], &apos;拉萨&apos;: [91.111891, 29.662557], &apos;那曲地区&apos;: [92.067018, 31.48068], &apos;昌都地区&apos;: [97.185582, 31.140576], &apos;山南地区&apos;: [91.750644, 29.229027], &apos;林芝地区&apos;: [94.349985, 29.666941], &apos;日喀则地区&apos;: [88.891486, 29.269023], &apos;阿里地区&apos;: [81.107669, 30.404557], //province 上海 &apos;上海&apos;: [121.48, 31.22], //province 新疆 &apos;新疆&apos;: [87.564988, 43.84038], &apos;图木舒克&apos;: [79.198155, 39.889223], &apos;克孜勒苏州&apos;: [76.137564, 39.750346], &apos;阿勒泰地区&apos;: [88.137915, 47.839744], &apos;乌鲁木齐&apos;: [87.564988, 43.84038], &apos;阿克苏地区&apos;: [80.269846, 41.171731], &apos;克拉玛依&apos;: [84.88118, 45.594331], &apos;五家渠&apos;: [87.565449, 44.368899], &apos;巴音郭楞&apos;: [86.121688, 41.771362], &apos;伊犁州&apos;: [81.297854, 43.922248], &apos;和田地区&apos;: [79.930239, 37.116774], &apos;阿拉尔&apos;: [81.291737, 40.61568], &apos;博尔塔拉州&apos;: [82.052436, 44.913651], &apos;喀什地区&apos;: [75.992973, 39.470627], &apos;哈密地区&apos;: [93.528355, 42.858596], &apos;石河子&apos;: [86.041865, 44.308259], &apos;塔城地区&apos;: [82.974881, 46.758684], &apos;吐鲁番地区&apos;: [89.181595, 42.96047], &apos;昌吉州&apos;: [87.296038, 44.007058], //province 四川 &apos;四川省&apos;: [104.067923, 30.679943], &apos;遂宁&apos;: [105.564888, 30.557491], &apos;达州&apos;: [107.494973, 31.214199], &apos;南充&apos;: [106.105554, 30.800965], &apos;广安&apos;: [106.63572, 30.463984], &apos;阿坝州&apos;: [102.228565, 31.905763], &apos;宜宾&apos;: [104.633019, 28.769675], &apos;乐山&apos;: [103.760824, 29.600958], &apos;绵阳&apos;: [104.705519, 31.504701], &apos;眉山&apos;: [103.84143, 30.061115], &apos;德阳&apos;: [104.402398, 31.13114], &apos;巴中&apos;: [106.757916, 31.869189], &apos;成都&apos;: [104.067923, 30.679943], &apos;内江&apos;: [105.073056, 29.599462], &apos;凉山州&apos;: [102.259591, 27.892393], &apos;泸州&apos;: [105.44397, 28.89593], &apos;甘孜州&apos;: [101.969232, 30.055144], &apos;攀枝花&apos;: [101.722423, 26.587571], &apos;广元&apos;: [105.819687, 32.44104], &apos;资阳&apos;: [104.63593, 30.132191], &apos;自贡&apos;: [104.776071, 29.359157], &apos;雅安&apos;: [103.009356, 29.999716], //province 香港 &apos;香港&apos;: [114.17, 22.28], //province 重庆 &apos;重庆&apos;: [106.54, 29.59], //province 湖北 &apos;湖北省&apos;: [114.3162, 30.581084], &apos;神农架林区&apos;: [110.487231, 31.595768], &apos;仙桃&apos;: [113.387448, 30.293966], &apos;天门&apos;: [113.12623, 30.649047], &apos;随州&apos;: [113.379358, 31.717858], &apos;鄂州&apos;: [114.895594, 30.384439], &apos;十堰&apos;: [110.801229, 32.636994], &apos;恩施&apos;: [109.517433, 30.308978], &apos;武汉&apos;: [114.3162, 30.581084], &apos;襄阳&apos;: [112.176326, 32.094934], &apos;黄石&apos;: [115.050683, 30.216127], &apos;宜昌&apos;: [111.310981, 30.732758], &apos;潜江&apos;: [112.768768, 30.343116], &apos;黄冈&apos;: [114.906618, 30.446109], &apos;孝感&apos;: [113.935734, 30.927955], &apos;荆州&apos;: [112.241866, 30.332591], &apos;荆门&apos;: [112.21733, 31.042611], &apos;咸宁&apos;: [114.300061, 29.880657], //province 福建 &apos;福建省&apos;: [118.103886, 24.489231], &apos;厦门&apos;: [118.103886, 24.489231], &apos;南平&apos;: [118.181883, 26.643626], &apos;三明&apos;: [117.642194, 26.270835], &apos;莆田&apos;: [119.077731, 25.44845], &apos;泉州&apos;: [118.600362, 24.901652], &apos;宁德&apos;: [119.542082, 26.656527], &apos;龙岩&apos;: [117.017997, 25.078685], &apos;福州&apos;: [119.330221, 26.047125], &apos;漳州&apos;: [117.676205, 24.517065], //province 台湾 &apos;台湾&apos;: [121.3, 25.03], //province 河北 &apos;河北省&apos;: [114.522082, 38.048958], &apos;张家口&apos;: [114.893782, 40.811188], &apos;保定&apos;: [115.49481, 38.886565], &apos;承德&apos;: [117.933822, 40.992521], &apos;秦皇岛&apos;: [119.604368, 39.945462], &apos;沧州&apos;: [116.863806, 38.297615], &apos;廊坊&apos;: [116.703602, 39.518611], &apos;衡水&apos;: [115.686229, 37.746929], &apos;唐山&apos;: [118.183451, 39.650531], &apos;邢台&apos;: [114.520487, 37.069531], &apos;石家庄&apos;: [114.522082, 38.048958], &apos;邯郸&apos;: [114.482694, 36.609308], //province 河南 &apos;河南省&apos;: [113.649644, 34.75661], &apos;安阳&apos;: [114.351807, 36.110267], &apos;信阳&apos;: [114.085491, 32.128582], &apos;周口&apos;: [114.654102, 33.623741], &apos;开封&apos;: [114.351642, 34.801854], &apos;许昌&apos;: [113.835312, 34.02674], &apos;漯河&apos;: [114.046061, 33.576279], &apos;郑州&apos;: [113.649644, 34.75661], &apos;三门峡&apos;: [111.181262, 34.78332], &apos;驻马店&apos;: [114.049154, 32.983158], &apos;洛阳&apos;: [112.447525, 34.657368], &apos;南阳&apos;: [112.542842, 33.01142], &apos;鹤壁&apos;: [114.29777, 35.755426], &apos;商丘&apos;: [115.641886, 34.438589], &apos;平顶山&apos;: [113.300849, 33.745301], &apos;新乡&apos;: [113.91269, 35.307258], &apos;焦作&apos;: [113.211836, 35.234608], &apos;濮阳&apos;: [115.026627, 35.753298], //province 浙江 &apos;浙江省&apos;: [120.219375, 30.259244], &apos;嘉兴&apos;: [120.760428, 30.773992], &apos;台州&apos;: [121.440613, 28.668283], &apos;舟山&apos;: [122.169872, 30.03601], &apos;丽水&apos;: [119.929576, 28.4563], &apos;宁波&apos;: [121.579006, 29.885259], &apos;衢州&apos;: [118.875842, 28.95691], &apos;绍兴&apos;: [120.592467, 30.002365], &apos;湖州&apos;: [120.137243, 30.877925], &apos;杭州&apos;: [120.219375, 30.259244], &apos;金华&apos;: [119.652576, 29.102899], &apos;温州&apos;: [120.690635, 28.002838], //province 陕西 &apos;陕西省&apos;: [108.953098, 34.2778], &apos;安康&apos;: [109.038045, 32.70437], &apos;延安&apos;: [109.50051, 36.60332], &apos;榆林&apos;: [109.745926, 38.279439], &apos;宝鸡&apos;: [107.170645, 34.364081], &apos;西安&apos;: [108.953098, 34.2778], &apos;汉中&apos;: [107.045478, 33.081569], &apos;咸阳&apos;: [108.707509, 34.345373], &apos;渭南&apos;: [109.483933, 34.502358], &apos;商洛&apos;: [109.934208, 33.873907], &apos;铜川&apos;: [108.968067, 34.908368], }; var HFData = [ // 数据中name的城市名称必须与geoCoordMap中城市名称一致, 不然关联不上，合肥到各地区的线路 [{name: &apos;杭州&apos;}, {name: &apos;海外&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;长春&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;长沙&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;贵阳&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;深圳&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;济南&apos;,value: 66}], [{name: &apos;杭州&apos;}, { name: &apos;海口&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;沈阳&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;武汉&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;昆明&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;合肥&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;杭州&apos;,value: 118}], [{name: &apos;杭州&apos;}, {name: &apos;成都&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;拉萨&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;天津&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;呼和浩特&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;哈尔滨&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;北京&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;南宁&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;南昌&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;乌鲁木齐&apos;,value: 66}], [{name: &apos;杭州&apos;}, {name: &apos;上海&apos;,value: 66}] ]; var planePath = &apos;arrow&apos;; // 箭头的svg // push进去线路开始-结束地点-经纬度 var convertData = function(data) { var res = []; for (var i = 0; i &lt; data.length; i++) { var dataItem = data[i]; var fromCoord = geoCoordMap[dataItem[0].name]; var toCoord = geoCoordMap[dataItem[1].name]; if (fromCoord &amp;&amp; toCoord) { res.push([{ coord: fromCoord }, { coord: toCoord }]); } } return res; }; var color = [&apos;#fff&apos;, &apos;#FFFFA8&apos;, &apos;#46bee9&apos;]; //圆圈和字的颜色，线的颜色，箭头颜色 // 数据 var series = []; // 遍历由合肥到其他城市的线路 [ [&apos;合肥&apos;, HFData] ].forEach(function(item, i) { // 配置 series.push({ // 系列名称，用于tooltip的显示 name: item[0], type: &apos;lines&apos;, zlevel: 1, // 用于 Canvas 分层，不同zlevel值的图形会放置在不同的 Canvas 中 // effect出发到目的地 的白色尾巴线条 // 线特效的配置 effect: { show: true, period: 6, // 特效动画的时间，单位为 s trailLength: 0.1, // 特效尾迹的长度。取从 0 到 1 的值，数值越大尾迹越长 color: &apos;#46bee9&apos;, // 移动箭头颜色 symbol: planePath, symbolSize: 10 // 特效标记的大小 }, // lineStyle出发到目的地 的线条颜色 lineStyle: { normal: { color: color[i], width: 0, curveness: 0.2 //幅度 } }, data: convertData(item[1]) //开始到结束数据 }, { //出发地信息 name: item[0], type: &apos;lines&apos;, zlevel: 2, effect: { show: true, period: 6, trailLength: 0, symbol: planePath, symbolSize: 6 }, lineStyle: { normal: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: &apos;#FFFFA8&apos; // 出发 }, { offset: 1, color: &apos;#58B3CC &apos; // 结束 颜色 }], false), width: 1.5, opacity: 0.4, curveness: 0.2 } }, data: convertData(item[1]) }, { // 目的地信息 name: item[0], type: &apos;effectScatter&apos;, coordinateSystem: &apos;geo&apos;, zlevel: 2, rippleEffect: { brushType: &apos;stroke&apos; }, label: { normal: { show: true, position: &apos;right&apos;, formatter: &apos;{b}&apos; } }, symbolSize: function(val) { return val[2] / 8; }, itemStyle: { normal: { color: color[i] } }, data: item[1].map(function(dataItem) { return { name: dataItem[1].name, value: geoCoordMap[dataItem[1].name].concat([dataItem[1].value]) }; }) }); }); // 指定相关的配置项和数据 var mapBoxOption = { geo: { map: &apos;china&apos;, roam: false, // 是否开启鼠标缩放和平移漫游。默认不开启。如果只想要开启缩放或者平移，可以设置成 &apos;scale&apos; 或者 &apos;move&apos;。设置成 true 为都开启 aspectScale: 0.75, zoom: 1.20, label: { normal: { show: true, textStyle: { color: &apos;#00a0c9&apos; } }, emphasis: { // 对应的鼠标悬浮效果 show: false, textStyle: { color: &quot;#00a0c9&quot; } } }, itemStyle: { normal: { areaColor: &apos;#0083ce&apos;, borderColor: &apos;#0066ba&apos;, textStyle: { fontSize: 24,//不显示目的地文字 fontWeight: &apos;bold&apos;, color: &apos;#FFC051&apos; //color: &apos;#6BEEFF&apos; // 目的地颜色 } }, emphasis: { borderWidth: 0, borderColor: &apos;#0066ba&apos;, areaColor: &quot;#0494e1&quot;, shadowColor: &apos;rgba(0, 0, 0, 0.5)&apos; } } }, series: series }; // 使用制定的配置项和数据显示图表 mapBoxEchart.setOption(mapBoxOption); // echart图表自适应 window.addEventListener(&quot;resize&quot;, function() { mapBoxEchart.resize(); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","path":"2021/12/22/Echarts-引入地图实例/"},{"title":"Vue事件符.stop .self的含义用法","text":"今天我们来学习一下Vue事件符.stop .self的含义用法，跟着我一起来学习吧~学习参考：https://www.jianshu.com/p/012c97c67560 .self 和 .stop 区别:self只响应当前元素自身触发的事件，不会响应经过冒泡触发的事件，并不会阻止冒泡继续向外部触发。stop是从自身开始不向外部发射冒泡信号 &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;wrapper&quot; v-on:click=&quot;wrapper&quot;&gt; &lt;div class=&quot;box&quot; v-on:click=&quot;box&quot;&gt; &lt;button v-on:click=&quot;btn&quot;&gt;阻止单击事件继续传播&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#app&quot;, data: { name: &quot;Vue.js&quot; }, methods: { wrapper: function () { console.log(&quot;wrapper&quot;); }, box: function () { console.log(&quot;box&quot;); } , btn: function () { console.log(&quot;这是btn&quot;); } } }); &lt;/script&gt; 正常情况下。 点击button会冒泡, 从html结构上 一层一层向上冒泡，父级有事件就会被触发将会先弹出“btn”,再弹出“box”,再弹出“wrapper”。 1. .stop 是阻止冒泡行为,不让当前元素的事件继续往外触发,如阻止点击div内部事件,触发div事件&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;wrapper&quot; v-on:click=&quot;wrapper&quot;&gt; &lt;div class=&quot;box&quot; v-on:click=&quot;box&quot;&gt; &lt;button v-on:click.stop=&quot;btn&quot;&gt;阻止单击事件继续传播&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#app&quot;, data: { name: &quot;Vue.js&quot; }, methods: { wrapper: function () { console.log(&quot;wrapper&quot;); }, box: function () { console.log(&quot;box&quot;); } , btn: function () { console.log(&quot;这是btn&quot;); } } }); &lt;/script&gt; 只弹出“noclick” 2. .self 是只有是自己触发的自己才会执行,如果接受到内部的冒泡事件传递信号触发,会忽略掉这个信号&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;wrapper&quot; v-on:click=&quot;wrapper&quot;&gt; &lt;div class=&quot;box&quot; v-on:click.self=&quot;box&quot;&gt; &lt;button v-on:click=&quot;btn&quot;&gt;阻止单击事件继续传播&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#app&quot;, data: { name: &quot;Vue.js&quot; }, methods: { wrapper: function () { console.log(&quot;wrapper&quot;); }, box: function () { console.log(&quot;box&quot;); } , btn: function () { console.log(&quot;这是btn&quot;); } } }); &lt;/script&gt; 这里点击button, 只会触发input事件,而不会触发box，但会向上冒泡 点击div,正常向上冒泡","path":"2021/12/18/Vue事件符.stop.self的含义用法/"},{"title":"Vue事件符.capture的含义用法","text":"今天我们来学习一下Vue事件符.capture的含义用法，跟着我一起来学习吧~学习参考：https://blog.csdn.net/catascdd/article/details/108273931 一、.capture的含义vue事件符的.capture用法，含义是捕获。先看一个4层结构的div盒子：div(最外层) &gt; div(爷爷) &gt; div(父亲) &gt; div(儿子) 点击最里层儿子,则会冒泡打印输出，输出为: 现在给@click添加.capture修饰符 1. 首先添加单个.capture给每层盒子，点击“儿子”看效果1.1 给父亲加 1.2. 给爷爷加 1.3. 给最外层加 2. 首先添加多个.capture给每层盒子，点击“儿子”看效果2.1.给父亲和爷爷加 2.2. 给父亲和最外层加 2.3. 给父亲、爷爷、最外层加 2.4. 给每一层都加 总结： 冒泡是从里往外冒，捕获是从外往里捕。 当捕获存在时，先从外到里的捕获，剩下的从里到外的冒泡输出。","path":"2021/12/18/Vue事件符.capture的含义用法/"},{"title":"CSS Hack是什么？","text":"学习参考:https://blog.csdn.net/qq_31635733/article/details/81660897 第一部分：什么是CSS Hack？CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），以达到应用不同的CSS样式的目的。 CSS Hack常见的有三种形式：CSS属性Hack、CSS选择符Hack以及IE条件注释Hack， Hack主要针对IE浏览器。1、属性级Hack：比如IE6能识别下划线“_”和星号“*”，IE7能识别星号“*”，但不能识别下划线”_”，而firefox两个都不能认识。2、选择符级Hack：比如IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。3、IE条件注释Hack：IE条件注释是微软IE5开始就提供的一种非标准逻辑语句。比如针对所有IE：&lt;!-[if IE]&gt;&lt;!-您的代码-&gt;&lt;![endif]&gt;，针对IE6及以下版本：&lt;!-[if it IE 7]&gt;&lt;!-您的代码-&gt;&lt;![endif]-&gt;，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。 第二部分：CSS hack的实际应用解释一下：上面的css在firefox中，它是认识不了后面的那个带星号的东西是什么的，于是将它过滤掉，不予理睬，解析得到的结果是:div{background:green} ,于是理所当然这个div的背景是绿色的。在IE6中呢，它两个background都能识别出来，它解析得到的结果是:div{background:green;*background:red;},于是根据优先级别，处在后面的red的优先级高，于是当然这个div的背景颜色就是红色的了。CSS hack:区分IE6，IE7，firefox区别不同浏览器，CSS hack写法： 区别IE6与FF：background:orange;*background:blue; 区别IE6与IE7：background:green!important;background:blue; 区别IE7与FF：background:orange;*background:green; 区别FF，IE7，IE6：background:orange;background:green;_background:blue;background:orange;background:green!important;*background:blue; 注：IE都能识别;标准浏览器(如FF)不能识别\\；IE6能识别*；不能识别 !important ;IE7能识别*，能识别!important;FF不能识别*，但能识别!important; 第三部分：为什么不推荐使用CSS hack来解决兼容性问题 CSS hack是因为现有浏览器对标准的解析不同，为了兼容各浏览器，所采用的一种补救方法。CSS hack是一种类似作弊的手段，以欺骗浏览器的方式达到兼容的目的，是用浏览器的兼容性差异来解决浏览器的兼容性问题。因此，在设计之初，写CSS hack需要遵循以下三条原则：有效： 能够通过 Web 标准的验证只针对太古老的/不再开发的/已被抛弃的浏览器， 而不是目前的主流浏览器代码要丑陋。让人记住这是一个不得已而为之的 Hack, 时刻记住要想办法去掉它。现在很多hacks已经抛弃了最初的原则，而滥用hack会导致浏览器更新之后产生更多的兼容性问题。因此，并不推荐使用CSS hack来解决兼容性问题。","path":"2021/09/06/CSS_Hack是什么/"},{"title":"SVN实现Web服务器自动更新（Windows平台）","text":"很多人都把SVN服务器搭建在正式服务器上，commit后，需要在测试服务器先测试一下，这时候，就需要在测试环境进行update操作。问题是，commit后，测试环境如何实现自动更新呢？研究了一天，终于有了结果 网上有很多中实现SVN自动更新的方法，这里记录了两种Windows平台下，实现SVN上传代码，自动更新web服务器内容的方法，供大家学习~ 1. 设置钩子，使得VisualSVN Server可以自动发布配置部署svn代码到web目录服务器上线 SVN钩子有很多种： post-commit 在提交完成成功创建版本之后执行该钩子，提交已经完成，不可更改。 pre-commit 提交完成前触发执行该脚本 start-commit 在客户端还没有想服务器提交数据之前，及没有建立Subversion transaction 之前。 仓库-&gt;右键-&gt;Properties-&gt;Hooks，添加一个post- commit文件；当有commit动作发生时（提交到SVN Server时）就会执行这个post-commit文件，在该文件实现数据的复制。 适用条件：SVN Server与测试用的Web Server在同一台Windows系统服务器上，SVN Server使用的是VisualSVN，Web Server使用的是Apache。项目的名称为faqSVN，客户端使用TortoiseSVN。首先创建一个文件夹，进行checkout，输入需要用户名和密码，将test项目取出到该文件夹中。 找到SVN Server的Repositories目录，在Repositories/test/hooks文件夹中创建post-commit.bat，在其中写入命令： &quot;C:\\Program Files\\VisualSVN Server\\bin\\svn.exe&quot; update &quot;D:\\www\\test&quot; --quiet --username name --password pwd（即执行svn update命令，请自行替换用户名和密码） 也可以这样写 @echo offSET REPOS=%1SET REV=%2SET DIR=%REPOS%/hooksSET PATH=%PATH%;SET WORKING_COPY=C:\\lichang\\faqSVN“C:\\Program Files\\VisualSVN Server\\bin\\svn.exe” update %WORKING_COPY% –username admin –password 123456 注意：修改完钩子文件，我们需要重启一下VisualSVN post-commit文件设置完成后，我们可以测试一下，当我们在客户端提交SVN文件的时候,VisualSVN Server会通过这个钩子文件，将SVN中更新的内容自动update到我们本地部署的faqSVN文件夹中 2.在Web服务器种写一个批处理文件svnUpdate.bat来进行svn update操作有的时候，我们操作SVN服务器不是很方便，那么我们可以在Web服务器上进行一些操作来实现SVN自动更新：首先，在Web服务器种写一个批处理文件svnUpdate.bat来进行svn update操作 ::SVN自动update ::待更新SVN目录 SET WORKING_COPY=D:/wwwroot svn update %WORKING_COPY% ::pause 文件很简单，就两条命令。WORKING_COPY是你测试环境的网站目录，这里是D:/faq，请自行修改，当然你必须在该目录下checkout先。如果用户名或密码更改了，你应该手动进行一次验证，并保存验证结果。 下一个问题是怎么调用这个bat文件呢？如果正式和测试环境，都在同一只机器上，那么直接编写HOOK，调用这个文件就可以。但如何不是同一个机器呢？一个比较简单的办法，就是在测试环境上，每经过一个时间间隔进行更新操作，我们可以编写一个vbs脚本，每隔15秒调用一次svnUpdate.bat。采用vbs调用有一个好处，可以隐藏弹出的cmd.exe窗口。我们新建一个文件，callSvnUpdate.vbs，内容如下： &apos;指定时间间隔调用.bat文件 &apos;停止脚本请在任务管理器结束wscript.exeSet ws=wscript.createobject(&quot;wscript.shell&quot;) dim bat &apos;需运行的文件 bat=&quot;cmd.exe /c svnUpdate.bat&quot; do &apos;0表示不显示窗口，1显示，调试用 ws.run bat,0 &apos;每15秒运行一次 wscript.sleep 15000 loop 将两个文件放于web服务器的同一目录中，双击运行callSvnUpdate.vbs即可","path":"2021/09/05/SVN实现Web服务器自动更新（Windows平台）/"},{"title":"SVN常见问题汇总","text":"SVN常见问题汇总：1. post-commit中，系统找不到指定的路径解决办法：钩子函数中路径不对，核对post-commit文件中所用到的文件路径 2. E155007: None of the targets are working copies问题原因：这主要是因为需要先在目标目录进行检出，只有目标目录检出[checkout]，才能执行钩子中的更新[update]操作解决办法：post-commit文件中用于部署在服务器的项目需要先SVN checkout，否则post-commit文件在编译时找不到相应的目标项目 3. 文件已经过时解决办法：客户端提交的时候可能出现文件过时的信息，原因是太久没有文件更新了，先更新文件（SVN update）再提交（如有文件冲突，处理冲突文件后再提交） 4. E200031: sqlite: attempt to write a readonly database 问题原因：客户端提交的时候出现该报错，原因是服务器中Visual SVN Server服务的执行权限不够，不能对指定目录做读写操作。解决办法：win+R 运行框输入 services.msc 打开服务列表 找到visual svn server 服务，右键-》属性-》登陆面板-》设置桌面交互、使用管理员权限重启服务即可； 5. E50004：Working copy XXX locked客户端提交的时候提示：或是服务端更新的时候提示： 解决办法：只需进到服务端文件目录下，执行svn cleanup即可 6. 版本库的UUID不匹配客户端更新或提交时提示该报错： uuid是SVN服务器在创建仓库时自动生成的一个随机数，通过这个随机数用来判断服务器和客户端的仓库是否一致，如果不一致，就会引起冲突。 我们要使服务端和客户端的uuid保持一致，很显然，修改服务端的uuid是不可以的，最好是修改我们本地仓库的uuid。要修改uuid，首先得知道服务端的uuid是什么，虽然报错的时候对话框中显示出了服务端的uuid是什么，但是那个不能复制。我们打开VisualSVN Server Manager页面，在中找到相应的repository，右键查看【Propertity】，然后在Details标签页中可以看到这个仓库的uuid了，这里的uuid是可以直接复制的。 直接执行svnadmin setuuid D:\\Repositories\\andon ad64c3d-b4ae-8641-b331-d04acc68038d","path":"2021/08/28/SVN常见问题汇总/"},{"title":"SVN环境搭建","text":"最近有个项目，要把界面搭建在web服务器上，同时支持通过SVN上传修改代码同步界面，因此学习一下SVN搭建过程，跟着我一起来学习吧~ 一、SVN下载地址Subversion（SVN）它是一个自由/开源的版本控制系统，一组文件存放在中心版本库，记录每一次文件和目录的修改，SVN允许把数据恢复到早期版本，或是检查数据修改的历史，它可以通过网络访问它的版本库，从而使用户在不同的电脑上进行操作。 SVN包含两部分，SVN服务端和SVN客户端，最好两部分搭配使用，下载地址如下： svn服务端下载地址：https://www.visualsvn.com/server/download/ svn客户端及中文包下载地址：https://tortoisesvn.net/downloads.zh.html 二、SVN服务器安装及使用方法2.1 VisualSVN安装第一步：首先要下载SVN服务端，下载地址：https://www.visualsvn.com/server/download/，根据系统选择对应的版本。 第二步： 双击安装程序 VisualSVN-Server-4.3.4-x64.msi 第三步：勾选“I accept…”，然后单击“Next” 第四步：使⽤默认配置，点击Next 第五步：设置服务器的安装路径、资源的存放⽬录及端⼝ Location是你的安装目录，C盘或D盘都可以，我选择存放在D盘，Repositories是你的源代码仓库，也就是你SVN帮你管理代码放置的位置，这里我选择放置在E盘。 第六步：使⽤默认配置，点击Next 第七步：使⽤默认配置，点击Next 第八步：点击install进行安装： 等待安装 第九步：安装完成后可勾选复选框，然后选择 Finish完成安装 SVN服务端界面显示如下： 2.2 VisualSVN使用方法2.2.1 创建版本库第一步：右键-“create new Repository” 第二步：使⽤默认配置，进入下一步 第三步：创建版本库的名称，进入下一步 第四步：选择【Single-project repository】，创建trunk，branches, tags三个文件夹，三个目录表示主杆、分枝、存档。 第五步：使⽤默认配置，进行创建 第六步：创建完成，我们可以看到我们的版本库中自动帮我们创建了trunk，branches, tags三个文件夹 2.2.2 创建用户第一步：选中Users用户组，右键单击，选择Create User或者新建-&gt;User 第二步：填写Username和password后，点击ok按钮为方便记忆，密码先统一设置为123456 第三步：创建完成显示如下 2.2.3 创建分组第一步：选中Groups用户组，右键单击，选择Create Group或者新建-&gt;Group,如图: 第二步：创建一个开发组，将刚刚创建的用户添加到该组中，点击ok按钮 第三步：创建完成显示如下 2.2.4 给版本库设置权限第一步：在faqRepository上单击右键,选择属性Properties 第二步：设置权限，你可以按组来设置，也可以按个人来设置，设置完成点击确定即可 2.2.5 将本地文件导入到SVN服务器第一步：首选需要过滤不必要上传到svn服务器的文件和文件夹。进入源码目录，在空白出点击右键，选择【TortoiseSVN】，选择【设置】，选择【常规设置】，在【Subversion】下的【全局忽略样式】中输入要忽略的文件夹名称及文件名称，以空格分隔。注意：此处建议忽略.temp、.vscode、node_modules等文件 第二步：打开VisualSVN Server Manager，选择版本库【demo1-mvcone】，选择【trunk】，在【trunk】上点击右键选择【Copy URL to Cliboard】，将版本库主杆地址copy到剪贴板。 第三步：进入本机源码所在的目录，右键菜单，选择【TortoiseSVN】，选择【导入…】 第四步：在版本库URL输入框里粘贴版本库地址，填上导入信息，强烈建议每次提交都填入导入信息，便于看日志做了哪些更改 第五步：输入svn server版本库demo1-mvcone的用户名和密码，点击确定开始上传 第六步：等待上传，完成上传 注意：我们可以看到本次完成上传的时间是11分钟，耗时太久，浪费时间，因此，此处建议不要上传.temp、.vscode、node_modules等文件，因为耗时太久、可以先将源码更新下来再在本地npm install进行手动更新需要加载的模块，这样可以提高上传下载效率 第七步：修改ignore文件、重新上传 第八步：刷新服务端，我们可以看到我们的代码已经上传到服务端了，可以开始进行客户端操作了 2.2.5.1. 遇到的问题注意：我在其他环境种导入代码遇到了如下问题： 1. 不知道这样的主机 原因： 地址https://e2jdkdwwxx01/svn/faqRepositories/trunk 中e2jdkdwwxx01是虚拟机的名字解决方法： 是把地址中“e2jdkdwwxx01”改成虚拟机的IP地址的形式，查询虚拟机IP地址方法是输入cmd打开命令提示符，再输入ipconfig，回车， IPv4地址即虚拟机的IP地址 将地址改成https://10.30.4.89/svn/faqRepositories/trunk，即可继续上传 此外，如果我们想修改我们的端口号，我们可以通过-&gt;右键-&gt;properties-Network来修改我们想要的端口号 2. 提示证书认证失败的问题解决办法： 直接选择“永久接受凭证”或者“接受凭证”即可 输入SVN中设置的用户名和密码即可完成上传 打开服务器的VisualSVN，即可看到我们的代码已经更新到SVN服务器中了 三、SVN客户端安装及使用方法3.1 TortoiseSVN安装第一步：首先要下载SVN客户端，下载地址：https://tortoisesvn.net/downloads.zh.html ，根据系统选择对应的版本。 第二步： 双击安装程序 TortoiseSVN-1.14.1.29085-x64-svn-1.14.1.msi 第三步：进入版权信息页面，直接点击Next 第四步：选择安装位置和需要的特性，默认，一般直接点击Next即可（你也可以根据自己的需求进行选择安装），具体想安装在哪个盘可以自定义 第五步：进入到安装界面，点击Install开始安装 第六步：点击Install后，进入到安装界面，可以看到安装的进度条，耐性等待哦 第七步：选上，更新日志，可以查看更新的版本详细信息，也可以不够选，点击Finish完成安装 3.2 安装TortoiseSVN汉化包第一步：双击【LanguagePack_1.14.1.29085-x64-zh_CN.msi】安装TortoiseSVN汉化包。 第二步：安装完成后，在资源管理器空白处单击鼠标右键，就可以看到汉化版的TortoiseSVN菜单。 第三步：选择 【Settings】，将General选项的Language设置为【简体中文】,【确定】后菜单文都变成中文的了。 3.3 TortoiseSVN使用方法3.3.1 下载源码到本地第一步：在本地新建文件夹，右键SVN检出 第二步：填写版本库URL，导出源码https://lichang.supcon.com/svn/faqRepositories/trunk 第三步：等待导出完成，导出完成，此时导出的代码为最新的源码版本 注意：如果我们之前有进行过版本库检出，后续要修改代码直接 -&gt; 右键 -&gt; SVN更新（SVN update），将代码更新到最新版即可 第四步：这个时候我们可以看到文件目录中已经把源码下下来了，左下角的绿色小图标代表此时文件状内容和服务器中的源码保持一致 第五步：打开终端，进入到代码目录，输入npm install 即可看到我们的目录中重新加载了node_modules node_modules是安装node后用来存放用包管理工具下载安装的包的文件夹。比如webpack、gulp、grunt这些工具。 第六步：接下来输入口令：yarn docs:dev注意：如果不执行第五步，直接执行第六步就会报错哦 完成第五步第六步，输入口令：yarn docs:dev，即可运行程序显示界面 3.3.2 文件上传（SVN commit）当我们编写完我们想要更新的文件，想要将其上传到服务器中，那么，你要了解接下来的一系列操作。 第一步：我们可以看到，未被修改过的文件显示绿色对号，修改过未上传的文件会被标注红色叹号，新创建的文件左下角没有标识 第二步：找到需要上传的文件或文件夹，点击右键，选中SVN提交（SVN commit） 我们可以单独提交某个文件 也可以提交整个文件夹 选中所要上传的文档，并填写commit message来记录上传内容 提示提交成功则完成代码提交 提交完成可以看到我们的图标已经变成了绿色对号 3.3.3 查看更新内容（show log）我们可以 -&gt; 右键 -&gt; TortoiseSVN -&gt; 显示日志 查看文档更新的内容 双击修改文件，可以查看修改细节，参考下图： 3.3.4 设置钩子，使得VisualSVN Server可以自动发布配置部署svn代码到web目录服务器上线 SVN钩子有很多种： post-commit 在提交完成成功创建版本之后执行该钩子，提交已经完成，不可更改。 pre-commit 提交完成前触发执行该脚本 start-commit 在客户端还没有想服务器提交数据之前，及没有建立Subversion transaction 之前。 仓库-&gt;右键-&gt;Properties-&gt;Hooks，添加一个post- commit文件；当有commit动作发生时（提交到SVN Server时）就会执行这个post-commit文件，在该文件实现数据的复制。 适用条件：SVN Server与测试用的Web Server在同一台Windows系统服务器上，SVN Server使用的是VisualSVN，Web Server使用的是Apache。项目的名称为faqSVN，客户端使用TortoiseSVN。首先创建一个文件夹，进行checkout，输入需要用户名和密码，将test项目取出到该文件夹中。 找到SVN Server的Repositories目录，在Repositories/test/hooks文件夹中创建post-commit.bat，在其中写入命令： &quot;C:\\Program Files\\VisualSVN Server\\bin\\svn.exe&quot; update &quot;D:\\www\\test&quot; --quiet --username name --password pwd（即执行svn update命令，请自行替换用户名和密码） 也可以这样写 @echo offSET REPOS=%1SET REV=%2SET DIR=%REPOS%/hooksSET PATH=%PATH%;SET WORKING_COPY=C:\\lichang\\faqSVN“C:\\Program Files\\VisualSVN Server\\bin\\svn.exe” update %WORKING_COPY% –username admin –password 123456 注意：修改完钩子文件，我们需要重启一下VisualSVN post-commit文件设置完成后，我们可以测试一下，当我们在客户端提交SVN文件的时候,VisualSVN Server会通过这个钩子文件，将SVN中更新的内容自动update到我们本地部署的faqSVN文件夹中","path":"2021/08/24/SVN环境搭建/"},{"title":"VuePress-项目搭建过程","text":"搭建参考文档：https://segmentfault.com/a/1190000017055963https://blog.csdn.net/weixin_39157014/article/details/110423784 一、安装yarn1、安装npm i -g -yarn 2、测试是否安装成功yarn --version 解决方法：设置环境变量，“控制面板“-”系统和安全“-“系统”-“高级系统设置”-“高级”-“环境变量” 设置完环境变量，重启VScode就可以显示yarn版本了 3、安装依赖 如vuecliyarn global add @vue/cli 4、Yarn 淘宝源安装yarn config set registry https://registry.npm.taobao.org -g yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g 二、安装vuePress1、将 VuePress 安装为本地依赖我们已经不再推荐全局安装 VuePress yarn add -D vuepress 2、在本地启动服务器yarn docs:dev # npm run docs:dev 点击链接打开网页,开始进行网页编辑","path":"2021/06/18/VuePress-项目搭建过程/"},{"title":"移动端返回后页面刷新","text":"学习参考：https://blog.csdn.net/qq_35430000/article/details/109098866?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link 移动端返回刷新手机端返回后页面不刷新，一些失效的信息依然显示在页面上。这个问题在iphone手机上会出现，在Android手机上返回时会自动刷新，为了解决这个问题，可以用pageshow方法。 onpageshow 事件在用户浏览网页时触发。onpageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， onpageshow 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发，此外还有pagehide在不显示的时候触发。 1. 根据persisted 属性来判断为了查看页面是直接从服务器上载入还是从缓存中读取，可以使用 PageTransitionEvent 对象的 persisted 属性来判断。 window.onpageshow = function(event) { if (event.persisted) { window.location.reload(); } } window.addEventListener(&apos;pageshow&apos;, function(event) { console.log(&quot;PageShow Event &quot; + event.persisted); console.log(event) if (event.persisted) { window.location.reload(); } }) 2. 根据数据是否变化来判断如果页面从浏览器的缓存中读取该属性返回 ture，否则返回 false。然后在根据true或false在执行相应的页面刷新动作或者直接ajax请求接口更新数据。这一点有个缺陷就是，无论是不是需要更新数据这个页面都会刷新，我们要做的只是数据变化了才需要更新。于是想到另一个办法在可能会出现数据变化的页面设置缓存，即为只要页面数据变化了就写缓存一条记录，在返回页面后检测到这条记录就说明需要页面刷新或调用接口刷新。 处理方法为： // a.html 设置刷新 检测缓存是否有标志 要是有就说明数据有变化 a.html跳转到b.html页面 window.addEventListener(&quot;pageshow&quot;, function(){ if(sessionStorage.getItem(&quot;need-refresh&quot;)){ location.reload(); sessionStorage.removeItem(&quot;need-refresh&quot;); } }); // b.html 如果是数据变化了就写一条缓存 b.html返回到a.html页面 sessionStorage.setItem(&quot;need-refresh&quot;, true); 3. 根据performance.navigation.type属性来判断最近在项目中使用pageshow，发现页面返回的时候persisted依然为false，这时候只好找其他方案解决。 这时候发现有一个window.performance对象，performance.navigation.type是一个无符号短整型 TYPE_NAVIGATE (0)：当前页面是通过点击链接，书签和表单提交，或者脚本操作，或者在url中直接输入地址，type值为0 TYPE_RELOAD (1)点击刷新页面按钮或者通过Location.reload()方法显示的页面，type值为1 TYPE_BACK_FORWARD (2)页面通过历史记录和前进后退访问时。type值为2 TYPE_RESERVED (255)任何其他方式，type值为255 这真是我们需要的部分，于是可以预见，解决方案如下： window.addEventListener(&apos;pageshow&apos;, () =&gt; { if (e.persisted || (window.performance &amp;&amp;window.performance.navigation.type == 2)) { location.reload() } }, false)","path":"2021/04/24/移动端返回后页面刷新/"},{"title":"页面加载前进后退的方法","text":"1.页面加载方法：1.1 location.href常见的几种形式self.location.href;//当前页面打开URL页面 window.location.href;//当前页面打开URL页面 this.location.href;//当前页面打开URL页面 location.href;// 当前页面打开URL页面 parent.location.href;//在父页面打开新页面 top.location.href;//在顶层页面打开新页面 注：location是window对象的属性，而所有的网页下的对象都是属于window作用域链中（这是顶级作用域），所以使用时是可以省略window。而top是指向顶级窗口对象，parent是指向父级窗口对象。 如果页面中自定义了frame，那么可将parent、self、top换为自定义frame的名称,效果是在frame窗口打开url地址。 1.2 刷新当前页面window.location.Reload();//页面刷新，如果有数据提交的话，会提示是否提交的(是和否选项) window.location.href=window.location.href;//是定向url提交数据 注：他们最大区别是，是否有数据提交： 当有提交数据时，window.location.Reload()会提示是否提交，window.location.href=window.location.href;则是向指定的url提交数据 1.3 打开新页面window.open(url); //在新窗口打开页面 window.location.href＝url; //在原窗口打开页面 //有时浏览器会一些安全设置window.open肯定被屏蔽。例如避免弹出广告窗口。 注意： 两者的主要区别是：window.location是window对象的属性，是你对当前浏览器窗口的URL地址对象的参考window.open是window对象的方法，用来打开一个新窗口的函数 window.open()是可以在一个网站上打开另外的一个网站的地址 而window.location()是只能在一个网站中打开本网站的网页 window.open不一定是打开一个新窗口只要有窗口的名称和window.open中第二个参数中的一样就会将这个窗口替换，用这个特性的话可以在iframe和frame中来代替location.href。 如&lt;iframe name=&quot;aa&quot;&gt;&lt;/iframe&gt; &lt;input type=button onclick=&quot;window.open(&#39;1.htm&#39;,&#39;aa&#39;,&#39;&#39;)&quot;&gt;和&lt;input type=button onclick=&quot;self.frames[&#39;aa&#39;].location.href=&#39;1.htm&#39;&quot;&gt;的效果一样 window.location或window.open如何指定target?这是一个经常遇到的问题，特别是在用frame框架的时候解决办法:window.location 改为 top.location 或直接用window.open(“你的网址”,”_top”); 即可在顶部链接到指定页 2.页面后退方法：history.back(-1):直接返回当前页的上一页，数据全部消息，是个新页面 history.go(-1):也是返回当前页的上一页，不过表单里的数据全部还在 history.back(1) 前进 history.back(-1) 后退 window.location.reload(); //刷新 window.history.go(1); //前进 window.history.go(-1); //返回+刷新 window.history.forward(); //前进 window.history.back(); //返回","path":"2021/04/12/页面加载前进后退的方法/"},{"title":"React-井字棋游戏案例","text":"学习教程：React井字游戏教材井字棋游戏扩展：https://blog.csdn.net/xxdesky/article/details/103427340https://blog.csdn.net/qq_40792800/article/details/106567832?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&amp;spm=1001.2101.3001.4242 import React from &apos;react&apos;; import ReactDOM from &apos;react-dom&apos;; import &apos;./index.css&apos;; function Square(props) { return ( &lt;button className=&quot;square&quot; onClick={props.onClick}&gt; {props.value} &lt;/button&gt; ); } class Board extends React.Component { renderSquare(i) { return &lt;Square value={this.props.squares[i]} onClick={() =&gt; this.props.onClick(i)} /&gt;; } render() { return ( &lt;div&gt; &lt;div className=&quot;board-row&quot;&gt; {this.renderSquare(0)} {this.renderSquare(1)} {this.renderSquare(2)} &lt;/div&gt; &lt;div className=&quot;board-row&quot;&gt; {this.renderSquare(3)} {this.renderSquare(4)} {this.renderSquare(5)} &lt;/div&gt; &lt;div className=&quot;board-row&quot;&gt; {this.renderSquare(6)} {this.renderSquare(7)} {this.renderSquare(8)} &lt;/div&gt; &lt;/div&gt; ); } } class Game extends React.Component { constructor(props) { super(props); this.state = { history: [{ squares: Array(9).fill(null), }], stepNumber: 0, xIsNext: true, }; } handleClick(i) { const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length - 1]; const squares = current.squares.slice(); if (calculateWinner(squares) || squares[i]) { return; } squares[i] = this.state.xIsNext ? &apos;X&apos; : &apos;O&apos;; this.setState({ history: history.concat([{ squares: squares, }]), stepNumber: history.length, xIsNext: !this.state.xIsNext, }); } jumpTo(step) { this.setState({ stepNumber: step, xIsNext: (step % 2) === 0, }); } render() { const history = this.state.history; const current = history[this.state.stepNumber]; const winner = calculateWinner(current.squares); const moves = history.map((step, move) =&gt; { const desc = move ? &apos;Go to move #&apos; + move : &apos;Go to game start&apos;; return ( &lt;li key={move}&gt; &lt;button onClick={() =&gt; this.jumpTo(move)}&gt;{desc}&lt;/button&gt; &lt;/li&gt; ); }); let status; if (winner) { status = &apos;Winner: &apos; + winner; } else { status = &apos;Next player: &apos; + (this.state.xIsNext ? &apos;X&apos; : &apos;O&apos;); } return ( &lt;div className=&quot;game&quot;&gt; &lt;div className=&quot;game-board&quot;&gt; &lt;Board squares={current.squares} onClick={(i) =&gt; this.handleClick(i)} /&gt; &lt;/div&gt; &lt;div className=&quot;game-info&quot;&gt; &lt;div&gt;{ status }&lt;/div&gt; &lt;ol&gt;{ moves }&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ); } } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i &lt; lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) { return squares[a]; } } return null; } // ======================================== ReactDOM.render( &lt;Game /&gt;, document.getElementById(&apos;root&apos;) );","path":"2021/04/08/React-井字棋游戏案例/"},{"title":"React学习笔记2（官网学习）","text":"一、概述1. 在网站中添加React（1）添加一个DOM容器到HTML中首先，打开你想要编辑的 HTML 页面。添加一个空的 &lt;div&gt; 标签作为标记你想要用 React 显示内容的位置。例如： &lt;!-- ... 其它 HTML ... --&gt; &lt;div id=&quot;like_button_container&quot;&gt;&lt;/div&gt; &lt;!-- ... 其它 HTML ... --&gt; 我们给这个 &lt;div&gt; 加上唯一的 id HTML 属性。这将允许我们稍后用 JavaScript 代码找到它，并在其中显示一个 React 组件。 （2）添加Script标签接下来，在 &lt;/body&gt; 结束标签之前，向 HTML 页面中添加三个 &lt;script&gt; 标签： &lt;!-- ... 其它 HTML ... --&gt; &lt;!-- 加载 React。--&gt; &lt;!-- 注意: 部署时，将 &quot;development.js&quot; 替换为 &quot;production.min.js&quot;。--&gt; &lt;script src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;!-- 加载我们的 React 组件。--&gt; &lt;script src=&quot;like_button.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; 前两个标签加载 React。第三个将加载你的组件代码。 （3）创建一个React组件在 HTML 页面文件的同级目录下创建一个名为 like_button.js 的文件，将这段代码粘贴到 like_button.js 文件中。 &apos;use strict&apos;; const e = React.createElement; class LikeButton extends React.Component { constructor(props) { super(props); this.state = { liked: false }; } render() { if (this.state.liked) { return &apos;You liked this.&apos;; } return e( &apos;button&apos;, { onClick: () =&gt; this.setState({ liked: true }) }, &apos;Like&apos; ); } } 在 like_button.js 的底部，在模板代码之后，加入以下两行代码。 // ... 此前粘贴的代码 ... const domContainer = document.querySelector(&apos;#like_button_container&apos;); ReactDOM.render(e(LikeButton), domContainer); 这两行代码会找到我们在步骤 1 中添加到 HTML 里的 &lt;div&gt;，然后在它内部显示我们的 React 组件 “Like” 按钮。最终，两个文件代码编辑如下：index.html： &lt;!--index.html--&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Add React in One Minute&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Add React in One Minute&lt;/h2&gt; &lt;p&gt;This page demonstrates using React with no build tooling.&lt;/p&gt; &lt;p&gt;React is loaded as a script tag.&lt;/p&gt; &lt;!-- We will put our React component inside this div. --&gt; &lt;div id=&quot;like_button_container&quot;&gt;&lt;/div&gt; &lt;!-- 加载 React。--&gt; &lt;!-- 注意: 部署时，将 &quot;development.js&quot; 替换为 &quot;production.min.js&quot;。--&gt; &lt;script src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;!-- 加载我们的 React 组件。--&gt; &lt;script src=&quot;like_button.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; like_button.js： //like_button.js &apos;use strict&apos;; const e = React.createElement; class LikeButton extends React.Component { constructor(props) { super(props); this.state = { liked: false }; } render() { if (this.state.liked) { return &apos;You liked this.&apos;; } return e( &apos;button&apos;, { onClick: () =&gt; this.setState({ liked: true }) }, &apos;Like&apos; ); } } const domContainer = document.querySelector(&apos;#like_button_container&apos;); ReactDOM.render(e(LikeButton), domContainer); 至此，我们已经成功将一个React组件添加到网站中 （4）知识扩展：重用一个组件通常你可能希望在 HTML 页面的多个位置展示 React 组件。下面是一个示例，它显示了三次 “Like” 按钮，并向各自传入了一些数据：完整代码如下：index.html： &lt;!--index.html--&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Add React in One Minute&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Add React in One Minute&lt;/h2&gt; &lt;p&gt;This page demonstrates using React with no build tooling.&lt;/p&gt; &lt;p&gt;React is loaded as a script tag.&lt;/p&gt; &lt;p&gt; This is the first comment. &lt;!-- We will put our React component inside this div. --&gt; &lt;div class=&quot;like_button_container&quot; data-commentid=&quot;1&quot;&gt;&lt;/div&gt; &lt;/p&gt; &lt;p&gt; This is the second comment. &lt;!-- We will put our React component inside this div. --&gt; &lt;div class=&quot;like_button_container&quot; data-commentid=&quot;2&quot;&gt;&lt;/div&gt; &lt;/p&gt; &lt;p&gt; This is the third comment. &lt;!-- We will put our React component inside this div. --&gt; &lt;div class=&quot;like_button_container&quot; data-commentid=&quot;3&quot;&gt;&lt;/div&gt; &lt;/p&gt; &lt;!-- Load React. --&gt; &lt;!-- Note: when deploying, replace &quot;development.js&quot; with &quot;production.min.js&quot;. --&gt; &lt;script src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;!-- Load our React component. --&gt; &lt;script src=&quot;like_button.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; like_button.js // like_button.js &apos;use strict&apos;; const e = React.createElement; class LikeButton extends React.Component { constructor(props) { super(props); this.state = { liked: false }; } render() { if (this.state.liked) { return &apos;You liked comment number &apos; + this.props.commentID; } return e( &apos;button&apos;, { onClick: () =&gt; this.setState({ liked: true }) }, &apos;Like&apos; ); } } // Find all DOM containers, and render Like buttons into them. document.querySelectorAll(&apos;.like_button_container&apos;) .forEach(domContainer =&gt; { // Read the comment ID from a data-* attribute. const commentID = parseInt(domContainer.dataset.commentid, 10); ReactDOM.render( e(LikeButton, { commentID: commentID }), domContainer ); }); 至此，我们已经成功将三个React组件添加到网站中 （5）使用 React 和 JSX在上面的示例中，我们只依赖了浏览器原生支持的特性。这就是为什么我们使用了 JavaScript 函数调用来告诉 React 要显示什么： const e = React.createElement; // 显示一个 &quot;Like&quot; &lt;button&gt;return e( &apos;button&apos;, { onClick: () =&gt; this.setState({ liked: true }) }, &apos;Like&apos; ); 然而，React 还提供了一种使用 JSX 编写界面的方式： // 显示一个 &quot;Like&quot; &lt;button&gt;return ( &lt;button onClick={() =&gt; this.setState({ liked: true })}&gt; Like &lt;/button&gt; ); 这两段代码是等价的。虽然 JSX 完全是可选的，但是多数人觉得这样编写 UI 代码更方便 —— 无论是使用 React 还是其它库。 （6）快速尝试 JSX在项目中尝试 JSX 最快的方法是在页面中添加这个 &lt;script&gt; 标签： &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; 现在，你可以在任何 &lt;script&gt; 标签内使用 JSX，方法是在为其添加 type=&quot;text/babel&quot; 属性。 这种方式适合于学习和创建简单的示例。然而，它会使你的网站变慢，并且不适用于生产环境。 当你准备好更进一步时，删除你添加的这个新的 &lt;script&gt; 标签以及type=”text/babel” 属性。取而代之的，在下一小节中，你将设置一个 JSX 预处理器来自动转换所有 &lt;script&gt; 标签的内容。 1) 将JSX添加到项目中将 JSX 添加到项目中并不需要诸如打包工具或开发服务器那样复杂的工具。本质上，添加 JSX 就像添加 CSS 预处理器一样。唯一的要求是你在计算机上安装了 Node.js。在终端上跳转到你的项目文件夹，然后粘贴这两个命令： 步骤 1： 执行 npm init -y 运行成功后，文件夹中会增加一个 package.json 的文件 步骤 2： 执行 npm install babel-cli@6 babel-preset-react-app@3 运行成功后，文件夹中会增加一个 package-lock.json 的文件和node_modules文件夹 提示我们在这里使用 npm 只是用来安装 JSX 预处理器，之后你不再需要它。React 和应用程序代码都可以继续使用 &lt;script&gt; 标签而不做任何更改。恭喜！你刚刚为你的项目加入了一个生产就绪（production-ready）的 JSX 配置环境。 2) 运行 JSX 预处理器创建一个名为 src 的文件夹并执行这个终端命令： npx babel --watch src --out-dir . --presets react-app/prod 注意： npx 不是拼写错误 —— 它是 npm 5.2+ 附带的 package 运行工具。 如果你看到一个错误消息显示为：“You have mistakenly installed the babel package”，你可能错过了上一步(将JSX添加到项目中)。在同一个文件夹中执行它，然后重试。 不要等待它运行结束 —— 这个命令启动了一个对 JSX 的自动监听器。 如果此时你用这段 JSX 入门代码创建一个 src/like_button.js 文件，监听器会创建一个预处理过的 like_button.js 文件，它包含了适用于浏览器的普通 JavaScript 代码。当你编辑带有 JSX 的源文件时，转换过程将自动重新执行。 2. React 工具链Create React AppCreate React App 是一个用于学习 React 的舒适环境，也是用 React 创建新的单页应用的最佳方式。 它会配置你的开发环境，以便使你能够使用最新的 JavaScript 特性，提供良好的开发体验，并为生产环境优化你的应用程序。你需要在你的机器上安装 Node &gt;= 10.16 和 npm &gt;= 5.6。要创建项目，请执行： npx create-react-app my-app cd my-app npm start 注意第一行的 npx 不是拼写错误 —— 它是 npm 5.2+ 附带的 package 运行工具。 Create React App 不会处理后端逻辑或操纵数据库；它只是创建一个前端构建流水线（build pipeline），所以你可以使用它来配合任何你想使用的后端。它在内部使用 Babel 和 webpack，但你无需了解它们的任何细节。 当你准备好部署到生产环境时，执行 npm run build 会在 build 文件夹内生成你应用的优化版本。你能从它的 README 和用户指南了解 Create React App 的更多信息。 一组 JavaScript 构建工具链通常由这些组成： 一个 package 管理器，比如 Yarn 或 npm。它能让你充分利用庞大的第三方 package 的生态系统，并且轻松地安装或更新它们。 一个打包器，比如 webpack 或 Parcel。它能让你编写模块化代码，并将它们组合在一起成为小的 package，以优化加载时间。 一个编译器，例如 Babel。它能让你编写的新版本 JavaScript 代码，在旧版浏览器中依然能够工作。 3.CDN链接&lt;script crossorigin src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 上述版本仅用于开发环境，不适合用于生产环境。 压缩优化后可用于生产的 React 版本可通过如下方式引用： &lt;script crossorigin src=&quot;https://unpkg.com/react@17/umd/react.production.min.js&quot;&gt;&lt;/script&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; 如果需要加载指定版本的 react 和 react-dom，可以把 17 替换成所需加载的版本号。 为什么要使用crossorigin属性?如果你通过 CDN 的方式引入 React，我们建议你设置crossorigin属性： &lt;script crossorigin src=&quot;...&quot;&gt;&lt;/script&gt; 我们同时建议你验证使用的 CDN 是否设置了Access-Control-Allow-Origin: * HTTP 请求头： 这样能在 React 16 及以上的版本中有更好的错误处理体验。 二、基础知识1. JSX是什么？ JSX是一个 JavaScript 的语法扩展，可以很好地描述 UI 应该呈现出它应有交互的本质形式。 为什么使用 JSX？ React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。 React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。我们将在后面章节中深入学习组件。如果你还没有适应在 JS 中使用标记语言，这个会议讨论应该可以说服你。 React 不强制要求使用 JSX，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。 在 JSX 中嵌入表达式在下面的例子中，我们声明了一个名为 name 的变量，然后在 JSX 中使用它，并将它包裹在大括号中： const name = &apos;Josh Perez&apos;; const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;; ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); 在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。 JSX 特定属性 （1）使用引号来将属性值指定为字符串字面量： const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;; （2）使用大括号来在属性值中插入一个 JavaScript 表达式： const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;; 注意：（1）在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。（2）React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。","path":"2021/03/28/React学习笔记2/"},{"title":"React学习笔记1","text":"今天我们来学习一下作为三大主流框架之一的React，跟着我一起学习吧~ 一、安装React 的核心思想是：封装组件。各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。基于这种方式的一个直观感受就是我们不再需要不厌其烦地来回查找某个 DOM 元素，然后操作 DOM 去更改 UI。React 大体包含下面这些概念：组件JSXVirtual DOMData Flow这里通过一个简单的组件来快速了解这些概念，以及建立起对 React 的一个总体认识。 import React, { Component } from &apos;react&apos;; import { render } from &apos;react-dom&apos;; class HelloMessage extends Component { render() { return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;; } } // 加载组件到 DOM 元素 mountNode render(&lt;HelloMessage name=&quot;John&quot; /&gt;, mountNode); React 的安装包，可以到官网下载。 二、React 网页结构使用 React 的网页源码，结构大致如下。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // ** Our code goes here! ** &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 上面代码有两个地方需要注意。首先，最后一个 &lt;script&gt; 标签的 type 属性为 text/babel。这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上type=&quot;text/babel&quot;。其次，上面代码一共用了三个库：react.js、react-dom.js 和 Browser.js，它们必须首先加载。其中，react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。 $ babel src –out-dir build 上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录。 三、ReactDOM.render()ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;)); 上面代码将一个 h1 标题，插入 example 节点 四、JSX语法将HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写 var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; ReactDOM.render( &lt;div&gt; { names.map(function (name) { return &lt;div&gt;Hello, {name}!&lt;/div&gt; }) } &lt;/div&gt;, document.getElementById(&apos;example&apos;)); 上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员 var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; ReactDOM.render( &lt;div&gt; { names.map(function (name) { return &lt;div&gt;Hello, {name}!&lt;/div&gt; }) } &lt;/div&gt;, document.getElementById(&apos;example&apos;)); 上面代码的arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板。 五、组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类。 var HelloMessage = React.createClass({ render: function() { return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;; }}); ReactDOM.render( &lt;HelloMessage name=&quot;John&quot; /&gt;, document.getElementById(&apos;example&apos;)); 上面代码中，变量 HelloMessage 就是一个组件类。模板插入 &lt;HelloMessage /&gt; 时，会自动生成 HelloMessage 的一个实例（下文的”组件”都指组件类的实例）。所有组件类都必须有自己的 render 方法，用于输出组件。注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;HelloMessage name=&quot;John&quot;&gt;，就是 HelloMessage 组件加入一个 name 属性，值为 John。组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor，这是因为 class 和 for 是 JavaScript 的保留字。 六、this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点 var NotesList = React.createClass({ render: function() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); }}); ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body ); 上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取。 这里需要注意， this.props.children 的值有三种可能：1.如果当前组件没有子节点，它就是 undefined ;2.如果有一个子节点，数据类型是 object ；3.如果有多个子节点，数据类型就是 array 。 所以，处理 this.props.children 的时候要小心。React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考官方文档。 七、PropTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求。 var MyTitle = React.createClass({ propTypes: { title: React.PropTypes.string.isRequired, }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; } }); 三只青蛙 第一只青蛙 第二只青蛙 第三只青蛙 上面的Mytitle组件有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。现在，我们设置 title 属性的值是一个数值。 八、获取真实的DOM节点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff，它可以极大提高网页的性能表现。但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性 var MyComponent = React.createClass({ handleClick: function() { this.refs.myTextInput.focus(); }, render: function() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt; &lt;/div&gt; ); }}); ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&apos;example&apos;)); 上面代码中，组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等，完整的事件清单请查看官方文档。 九、this.state组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI var LikeButton = React.createClass({ getInitialState: function() { return {liked: false}; }, handleClick: function(event) { this.setState({liked: !this.state.liked}); }, render: function() { var text = this.state.liked ? &apos;like&apos; : &apos;haven\\&apos;t liked&apos;; return ( &lt;p onClick={this.handleClick}&gt; You {text} this. Click to toggle. &lt;/p&gt; ); }}); ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;)); 上面代码是一个 LikeButton 组件，它的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 十、表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。 var Input = React.createClass({ getInitialState: function() { return {value: &apos;Hello!&apos;}; }, handleChange: function(event) { this.setState({value: event.target.value}); }, render: function () { var value = this.state.value; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt; &lt;p&gt;{value}&lt;/p&gt; &lt;/div&gt; ); }}); ReactDOM.render(&lt;Input/&gt;, document.body); 上面代码中，文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况 十一、组件的生命周期 组件的生命周期分成三个状态：Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用","path":"2021/03/16/React学习笔记1/"},{"title":"Grid布局方式","text":"作为前端必备知识点，Grid为我们页面布局提供了灵活性，今天我们来学一下Grid布局吧~学习参考:阮一峰CSS Grid 网格布局教程 一、概述网格布局（Grid）是最强大的 CSS 布局方案。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。 Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。 Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。 Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。 二、基本概念2.1 容器和项目采用网格布局的区域，称为 &quot;容器&quot;（container） 。容器内部采用网格定位的子元素，称为 &quot;项目&quot;（item） 。12345&lt;div&gt; &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 上面代码中，最外层的&lt;div&gt;元素就是容器，内层的三个&lt;div&gt;元素就是项目。注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的&lt;p&gt;元素就不是项目。Grid 布局只对项目生效。 2.2 行和列容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。 上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。 2.3 单元格行和列的交叉区域，称为”单元格”（cell）。正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。 2.4 网格线划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。 上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。 三、容器属性以下几个属性设置在容器上： display ：指定一个容器采用网格布局 1. grid-template： grid-template-rows ：定义每一行的行高 grid-template-columns ：定义每一列的列宽 grid-template-areas ：用于定义区域 grid-template（不建议使用） ：是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式 2. grid： grid-auto-rows ：设置浏览器自动创建的多余网格的行高 grid-auto-columns ：设置浏览器自动创建的多余网格的列宽 grid-auto-flow ：设置子元素放置顺序，默认是”先行后列” grid（不建议使用） ：是grid-template-rows、grid-template-columns、grid-template-areas、grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式 3. grid-gap（gap）： grid-row-gap（row-gap） ：设置行与行的间隔（行间距） grid-column-gap（column-gap） ：设置列与列的间隔（列间距） grid-gap（gap） ：是 grid-column-gap 和 grid-row-gap的合并简写形式 4. place-items： justify-items ：设置单元格内容的水平位置（左中右） align-items ：设置单元格内容的垂直位置（上中下） place-items ：是align-items属性和justify-items属性的合并简写形式 5. place-content： justify-content ：是整个内容区域在容器里面的水平位置（左中右） align-content ：是整个内容区域的垂直位置（上中下） place-content ：是align-content属性和justify-content属性的合并简写形式 3.1 display 属性 display: grid指定一个容器采用网格布局。 123div &#123; display: grid;&#125; 默认情况下，容器元素都是块级元素，但也可以设成行内元素。123div &#123; display: inline-grid;&#125; 上面代码指定div是一个行内元素，该元素内部采用网格布局。如下图所示： 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 3.2 grid-template-columns 属性，grid-template-rows 属性容器指定了网格布局以后，接着就要划分行和列。 grid-template-columns属性定义每一列的列宽grid-template-rows属性定义每一行的行高 12345.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 上面代码指定了一个三行三列的网格，列宽和行高都是100px。 除了使用绝对单位，也可以使用百分比。12345.container &#123; display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%;&#125; （1）repeat()有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。12345.container &#123; display: grid; grid-template-columns: repeat(3, 33.33%); grid-template-rows: repeat(3, 33.33%);&#125; repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。repeat()重复某种模式也是可以的。1grid-template-columns: repeat(2, 100px 20px 80px); 上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。 （2）auto-fill 关键字有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; 上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。 （3）fr 关键字为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。1234.container &#123; display: grid; grid-template-columns: 1fr 1fr;&#125; 上面代码表示两个相同宽度的列。 fr可以与绝对长度的单位结合使用，这时会非常方便。1234.container &#123; display: grid; grid-template-columns: 150px 1fr 2fr;&#125; 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。 （4）minmax()minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。1grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 （5）auto 关键字auto关键字表示由浏览器自己决定长度。1grid-template-columns: 100px auto 100px; 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。 （6）网格线的名称grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。12345.container &#123; display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&#125; 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 （7）布局实例grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。1234.wrapper &#123; display: grid; grid-template-columns: 70% 30%;&#125; 上面代码将左边栏设为70%，右边栏设为30%。传统的十二网格布局，写起来也很容易。1grid-template-columns: repeat(12, 1fr); 3.3 grid-row-gap 属性，grid-column-gap 属性，grid-gap 属性 grid-row-gap属性设置行与行的间隔（行间距）grid-column-gap属性设置列与列的间隔（列间距） 1234.container &#123; grid-row-gap: 20px; grid-column-gap: 20px;&#125; 上面代码中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距。 grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式 1grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; 因此，上面一段 CSS 代码等同于下面的代码。123.container &#123; grid-gap: 20px 20px;&#125; 如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 3.4 grid-template-areas 属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。 grid-template-areas属性用于定义区域 12345678.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i';&#125; 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。多个单元格合并成一个区域的写法如下。123grid-template-areas: 'a a a' 'b b b' 'c c c'; 上面代码将9个单元格分成a、b、c三个区域。下面是一个布局实例。123grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\"; 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。如果某些区域不需要利用，则使用”点”（.）表示。123grid-template-areas: 'a . c' 'd . f' 'g . i'; 上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 3.5 grid-auto-flow 属性划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 grid-auto-flow属性用于决定子元素的放置顺序，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行” 1grid-auto-flow: column; 上面代码设置了column以后，放置顺序就变成了下图。 grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。 假设让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row情况下，会产生下面这样的布局。 上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。现在修改设置，设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。1grid-auto-flow: row dense; 上面代码的效果如下。 上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。如果将设置改为column dense，表示”先列后行”，并且尽量填满空格。1grid-auto-flow: column dense; 上面代码的效果如下。 上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。 3.6 justify-items 属性，align-items 属性，place-items 属性 justify-items属性设置单元格内容的水平位置（左中右）align-items属性设置单元格内容的垂直位置（上中下） 1234.container &#123; justify-items: start | end | center | stretch; align-items: start | end | center | stretch;&#125; 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。123.container &#123; justify-items: start;&#125; 上面代码表示，单元格的内容左对齐，效果如下图。 123.container &#123; align-items: start;&#125; 上面代码表示，单元格的内容头部对齐，效果如下图。 place-items属性是align-items属性和justify-items属性的合并简写形式 1place-items: &lt;align-items&gt;&lt;justify-items&gt;; 下面是一个例子。1place-items: start end; 如果省略第二个值，则浏览器认为与第一个值相等。 3.7 justify-content 属性，align-content 属性，place-content 属性 justify-content属性是整个内容区域在容器里面的水平位置（左中右）align-content属性是整个内容区域的垂直位置（上中下） 1234.container &#123; justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; &#125; 这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。） (1) start - 对齐容器的起始边框。 (2) end - 对齐容器的结束边框。 (3) center - 容器内部居中。 (4) stretch - 项目大小没有指定时，拉伸占据整个网格容器。 (5) space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 (6) space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 (7) space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性是align-content属性和justify-content属性的合并简写形式。 1place-content: &lt;align-content&gt; &lt;justify-content&gt; 下面是一个例子。1place-content: space-around space-evenly; 如果省略第二个值，浏览器就会假定第二个值等于第一个值。 3.8 grid-auto-columns 属性，grid-auto-rows 属性有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 下面的例子里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。123456.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-auto-rows: 50px; &#125; 上面代码指定新增的行高统一为50px（原始的行高为100px）。 3.9 grid-template 属性，grid 属性(不建议使用) grid-template属性是以下三个属性的合并简写形式：grid-template-columnsgrid-template-rowsgrid-template-areas grid属性是以下六个属性的合并简写形式：grid-template-rowsgrid-template-columnsgrid-template-areasgrid-auto-rowsgrid-auto-columnsgrid-auto-flow 从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。 四、项目属性以下几个属性设置在项目上： grid-column-start ：左边框所在的垂直网格线grid-column-end ：右边框所在的垂直网格线grid-row-start ：上边框所在的水平网格线grid-row-end ：下边框所在的水平网格线grid-column ：是grid-column-start属性和grid-column-start属性的合并简写形式grid-row ：是grid-row-start属性和grid-row-end属性的合并简写形式grid-area ：指定项目放在哪一个区域justify-self ：设置单元格内容的水平位置（左中右）align-self ：设置单元格内容的垂直位置（上中下）place-self ：是align-self属性和justify-self属性的合并简写形式 4.1 grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start属性：左边框所在的垂直网格线grid-column-end属性：右边框所在的垂直网格线grid-row-start属性：上边框所在的水平网格线grid-row-end属性：下边框所在的水平网格线 1234.item-1 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。 上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。下面的例子是指定四个边框位置的效果。12345.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4;&#125; 这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。1234.item-1 &#123; grid-column-start: header-start; grid-column-end: header-end;&#125; 上面代码中，左边框和右边框的位置，都指定为网格线的名字。这四个属性的值还可以使用span关键字，表示跨越;，即左右边框（上下边框）之间跨越多少个网格。123.item-1 &#123; grid-column-start: span 2;&#125; 上面代码表示，1号项目的左边框距离右边框跨越2个网格。 这与下面的代码效果完全一样。123.item-1 &#123; grid-column-end: span 2;&#125; 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 4.2grid-column 属性，grid-row 属性 grid-column属性是grid-column-start和grid-column-end的合并简写形式grid-row属性是grid-row-start属性和grid-row-end的合并简写形式 1234.item &#123; grid-column: &lt;start-line&gt; / &lt;end-line&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt;;&#125; 下面是一个例子。1234567891011.item-1 &#123; grid-column: 1 / 3; grid-row: 1 / 2;&#125;/* 等同于 */.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。这两个属性之中，也可以使用span关键字，表示跨越多少个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;/* 等同于 */.item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 4.3 grid-area 属性 grid-area属性指定项目放在哪一个区域 123.item-1 &#123; grid-area: e;&#125; 上面代码中，1号项目位于e区域，效果如下图。 grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 下面是一个例子。123.item-1 &#123; grid-area: 1 / 1 / 3 / 3;&#125; 4.4 justify-self 属性，align-self 属性，place-self 属性 justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目 1234.item &#123; justify-self: start | end | center | stretch; align-self: start | end | center | stretch;&#125; 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 123.item-1 &#123; justify-self: start;&#125; place-self属性是align-self属性和justify-self属性的合并简写形式 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 下面是一个例子。1place-self: center center; 如果省略第二个值，place-self属性会认为这两个值相等。","path":"2021/01/27/Grid布局方式/"},{"title":"获取页面的宽度和高度","text":"1. clientHeight clientWidth元素的像素高度,包含元素的高度+内边距,不包含水平滚动条,边框和外边距。 包括padding但不包括border、水平滚动条、margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素。 2. offsetHeight offsetWidth元素的像素高度 包含元素的垂直内边距和边框,水平滚动条的高度,且是一个整数 包括padding、border、水平滚动条，但不包括margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素。 3. scrollHeight scrollWidth元素内容的高度,包括溢出的不可见内容 而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。 4. scrollTop代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时scrollTop==0恒成立。单位px，可读可设置。 5. offsetTop当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。 注意点: 对块级元素来说，offsetTop、offsetLeft、offsetWidth 及 offsetHeight 描述了元素相对于 offsetParent 的边界框。但是文本框不是如此.文本框的offsetLeft和offsetTop是第一个文本框的左偏移和上偏移. offsetParent元素指改元素的定位元素以及最近的table,td,th,body.可见,offsetParent和position属性的包含块概念类似.大部分场景下可以通用. offsetTop和offsetLeft都是相对于其内边距边界的. offsetLeft和left属性的区别: position为fixed时值不同当position为fixed的时候,offsetLeft的值将会是null,而left此时一般有确定的数字值. 相对边距不同offerset的是相对于offsetParent的内边距边界,left是相对于包含块的外边距边界. 包含块有区别offerset相对与定位的祖先元素或者 table/td/th/body等祖先元素,left仅仅是相对于定位祖先元素+body clientHeight与offsetHeight的区别:clientHeight仅仅包含内边距+高度,offsetHeight包含内边距+滚动条+边框所以可以这样说: clientHeight+滚动条高度+边框 = offsetHeight Javascript: 网页可见区域宽： document.body.clientWidth 网页可见区域高： document.body.clientHeight 网页可见区域宽： document.body.offsetWidth (包括边线的宽) 网页可见区域高： document.body.offsetHeight (包括边线的高) 网页正文全文宽： document.body.scrollWidth 网页正文全文高： document.body.scrollHeight 网页被卷去的高： document.body.scrollTop 网页被卷去的左： document.body.scrollLeft 网页正文部分上： window.screenTop 网页正文部分左： window.screenLeft 屏幕分辨率的高： window.screen.height 屏幕分辨率的宽： window.screen.width 屏幕可用工作区高度： window.screen.availHeight 屏幕可用工作区宽度： window.screen.availWidth JQuery: $(document).ready(function(){alert($(window).height()); //浏览器当前窗口可视区域高度 alert($(document).height()); //浏览器当前窗口文档的高度 alert($(document.body).height());//浏览器当前窗口文档body的高度 alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin alert($(window).width()); //浏览器当前窗口可视区域宽度 alert($(document).width());//浏览器当前窗口文档对象宽度 alert($(document.body).width());//浏览器当前窗口文档body的宽度 alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin})","path":"2020/12/21/获取页面的宽度和高度/"},{"title":"获取当前浏览器的信息","text":"console.log(navigator) var explorer = navigator.userAgent; var Browser; // IE 判断浏览器是否支持ActiveX控件，如果浏览器支持ActiveX控件可以利用, if (!!window.ActiveXObject || &quot;ActiveXObject&quot; in window) { Browser = &apos;ie&apos;; console.log(&quot;当前浏览器为：IE&quot;); } //IE documentMode是一个IE的私有属性，在IE8+中被支持。 if (window.document.documentMode) { Browser = &apos;ie&apos;; console.log(&quot;当前浏览器为：IE&quot;); } //firefox else if (explorer.indexOf(&quot;Firefox&quot;) &gt;= 0) { Browser = &apos;Firefox&apos;; console.log(&quot;当前浏览器为：Firefox&quot;); } //Chrome else if (explorer.indexOf(&quot;Chrome&quot;) &gt;= 0) { Browser = &apos;Chrome&apos;; console.log(&quot;当前浏览器为：Chrome&quot;); } //Opera else if (explorer.indexOf(&quot;Opera&quot;) &gt;= 0) { Browser = &apos;Opera&apos;; console.log(&quot;当前浏览器为：Opera&quot;); } //Safari else if (explorer.indexOf(&quot;Safari&quot;) &gt;= 0) { Browser = &apos;Safari&apos;; console.log(&quot;当前浏览器为：Safari&quot;); } //Netscape else if (explorer.indexOf(&quot;Netscape&quot;) &gt;= 0) { Browser = &apos;Netscape&apos;; console.log(&apos;当前浏览器为：Netscape&apos;); }","path":"2020/12/20/获取当前浏览器的信息/"},{"title":"sessionStorage、localStorage和 cookie 之间的区别","text":"一、概念我们在编程的时候需要持久化的存储一些数据。对于网络化编程，一般将这项任务交给了服务器端的数据库或者浏览器端的cookie。 HTML5 提供了两种客户端存储数据的新方法： localStorage（本地存储） - 没有时间限制的数据存储 sessionStorage（会话存储） - 针对一个 session 的数据存储 之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。 对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。 HTML5 使用 JavaScript 来存储和访问数据。 二、如何使用sessionStorage、localStorage1. session storagesession storage存储在 sessionStorage 里面的数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。在新标签或窗口打开一个页面会初始化一个新的会话，这点和 session cookies 的运行方式不同。 // 设置session Storage sessionStorage.setItem(&apos;key&apos;, &apos;value&apos;); sessionStorage.keyName = &apos;valueName&apos;; // 也可以使用这种方式 // 读取数据 console.log(sessionStorage.getItem(&apos;key&apos;)); // 删除数据 sessionStorage.removeItem(&apos;value&apos;); // 清空session storage中所有的数据 sessionStorage.clear(); 2. local storagelocal storagelocalStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 // 设置local Storage localStorage.setItem(&apos;key&apos;, &apos;value&apos;); localStorage.keyName = &apos;valueName&apos;; // 也可以使用这种方式 // 读取数据 console.log(localStorage.getItem(&apos;key&apos;)); // 删除数据 localStorage.removeItem(&apos;key&apos;); // 清空local storage中所有的数据 localStorage.clear(); 案例: &lt;script&gt; window.onload=function(){ var color=document.getElementsByClassName(&apos;color&apos;); var face=document.getElementById(&apos;face&apos;); var btn=document.getElementById(&apos;btn&apos;); getlocal(&apos;color&apos;); for(var i=0;i&lt;color.length;i++){ color[i].onclick=function(){ var bgcolor=this.style.backgroundColor;// face.style.backgroundColor=bgcolor; setlocal(&apos;color&apos;,bgcolor);// 存储颜色 getlocal(&apos;color&apos;);// 取出颜色并赋给div } }// 设置本地存储 function setlocal(k,v){ window.localStorage.setItem(k,v); }// 取出本地存储 function getlocal(k){ var divcolor=window.localStorage.getItem(k); face.style.backgroundColor=divcolor;// 取出存储在localStorage中的颜色，并赋给div; } } &lt;/script&gt; 三、sessionStorage、localStorage 和 cookie 之间的区别 三者都是在浏览器端存储数据。 数据存储大小限制不同。cookies：数据始终在同源的http请求中携带，即cookie在服务器和浏览器间回传。故存储的数据大小最小，一般为4k。sessionStorage和localStorage：数据在本地保存，不会自动把数据发给服务器。所以一般5M或者更大。 数据有效期不同cookies：数据在cookie设置的有效期之前都有效，即使窗口和浏览器关闭。sessionStorage：数据在关闭浏览器窗口后自动清除。存储的数据仅在同源同窗口内有效，即使在不同浏览器相同页面也是无效的。一般用于存储会话数据。localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 数据作用域不同Cookies和localStorage：在所有同源窗口敏感词享。sessionStorage：不在不同浏览器窗口敏感词享。 请你谈谈Cookie的弊端 每个特定的域名下最多生成的cookie个数有限制 IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。 web storage和cookie的区别 Cookie的大小是受限的 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽 cookie还需要指定作用域，不可以跨域调用 Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage","path":"2020/11/28/sessionStorage、localStorage和 cookie 之间的区别/"},{"title":"几种前端请求数据方式","text":"经常用ajax进行请求操作，那么除了ajax，还有什么请求方式呢，今天我们来学一下几种前端请求数据方式吧~ 学习参考:https://blog.csdn.net/weixin_43992119/article/details/100514686https://www.cnblogs.com/cc123nice/p/12593857.html 1. XMLHttpRequestajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。 所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求 &lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;http://i2.mediapower.mobi/adpower/vm/Bora/js/test.js&quot;, true); xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { console.log(xhr.responseText); } }; xhr.send(null); &lt;/script&gt; 2. jquery的$.ajax方法 场景1. 用Ajax进行数据验证 场景2.按需取数据 场景3.自动更新页面 异步请求方式，jQuery都封装好了，具体的业务可以通过设置不同的属性去实现 &lt;script src=&quot;js/jquery-1.11.3.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $.ajax({ async: false, type: &quot;GET&quot;, dataType: &apos;jsonp&apos;, jsonp: &apos;callback&apos;, jsonpCallback: &apos;callbackfunction&apos;, url: &quot;http://i2.mediapower.mobi/adpower/vm/Bora/js/test.js&quot;, data: &quot;&quot;, timeout: 3000, contentType: &quot;application/json;utf-8&quot;, success: function(msg) { console.log(msg); } }); }) &lt;/script&gt; 3. axiosaxios 是一个基于 Promise 的 http请求库，可以用在浏览器和 node.js 中，本质上也是对原生XHR的封装，只不过它是Promise 的实现版本，符合最新的ES规则。 axios与ajax区别相同点：都是执行异步请求操作 不同点：1. 大小 axios体积小 只需在要使用的目录下 npm install axios –save ajax 需要导入jQuery【体积较大 只是为了ajax去引入是不值得的】 2. 针对方向 axios 符合前端MVVM的浪潮 ajax 本身是针对MVC的编程 3. 实现方法与返回值 axios 用promise技术实现对ajax技术的封装 返回值是 promise ajax 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 4. 对并发请求的封装api 5. 用法相同，但个别参数不同 &lt;script&gt; axios({ url:&apos;服务器url&apos;, method:&apos;请求方式&apos; , params:{ name:&apos;cc&apos;, age:&apos;18&apos; } }).then(function (response) { console.log(response); console.log(response.data); }).catch(function (error) { console.log(error); }） &lt;/script&gt; 4. postMessage+iframe&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;testa&lt;/title&gt; &lt;/head&gt; &lt;script&gt; window.onload = function() { document.getElementById(&apos;ifr&apos;).contentWindow.postMessage(&apos;我是一条测试数据&apos;, &apos;https://mp.csdn.net/mdeditor/100514686&apos;); }; &lt;/script&gt; &lt;body&gt; &lt;iframe id=&quot;ifr&quot; src=&quot;https://mp.csdn.net/mdeditor/100514686.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 请求的页面 则可以通过添加监听来获得请求数据 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;testb&lt;/title&gt; &lt;/head&gt; &lt;script&gt; //可以调用window中的时间监听对跨域访问的postmessage经行监听 window.addEventListener(&apos;message&apos;, function(event) { // 通过origin属性判断消息来源地址 if (event.origin === &apos;http://127.0.0.1:8080&apos;) { alert(event.data); } }, false); &lt;/script&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;","path":"2020/11/22/几种前端请求数据方式/"},{"title":"ajax详解","text":"今天我们来学一下什么是ajax请求吧~学习参考:https://blog.csdn.net/chaopingyao/article/details/106481895 一、定义1. 什么是AjaxAjax：即异步 JavaScript 和XML。Ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页(不使用 Ajax)如果需要更新内容，必需重载整个网页面。 2. 同步与异步的区别同步提交：当用户发送请求时，当前页面不可以使用，服务器响应页面到客户端，响应完成，用户才可以使用页面。 异步提交：当用户发送请求时，当前页面还可以继续使用，当异步请求的数据响应给页面，页面把数据显示出来 。 3. ajax的工作原理客户端发送请求，请求交给xhr，xhr把请求提交给服务，服务器进行业务处理，服务器响应数据交给xhr对象，xhr对象接收数据，由javascript把数据写到页面上，如下图所示： 二、实现AJAX的基本步骤要完整实现一个AJAX异步调用和局部刷新,通常需要以下几个步骤: 创建XMLHttpRequest对象,即创建一个异步调用对象. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. 设置响应HTTP请求状态变化的函数. 发送HTTP请求. 获取异步调用返回的数据. 使用JavaScript和DOM实现局部刷新. 1. 创建XMLHttpRequest对象不同浏览器使用的异步调用对象有所不同，在IE浏览器中异步调用使用的是XMLHTTP组件中的XMLHttpRequest对象，而在Netscape、Firefox浏览器中则直接使用XMLHttpRequest组件。因此，在不同浏览器中创建XMLHttpRequest对象的方式都有所不同. 在IE浏览器中创建XMLHttpRequest对象的方式为: var xmlHttpRequest = new ActiveXObject(“Microsoft.XMLHTTP”); 在Netscape浏览器中创建XMLHttpRequest对象的方式为: var xmlHttpRequest = new XMLHttpRequest(); 由于无法确定用户使用的是什么浏览器,所以在创建XMLHttpRequest对象时,最好将以上两种方法都加上.如以下代码所示: var xmlHttpRequest; //定义一个变量,用于存放XMLHttpRequest对象 createXMLHttpRequst(); //调用创建对象的方法 //创建XMLHttpRequest对象的方法 function createXMLHttpRequest(){ if(window.ActiveXObject) {//判断是否是IE浏览器 xmlHttpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//创建IE的XMLHttpRequest对象 }else if(window.XMLHttpRequest){//判断是否是Netscape等其他支持XMLHttpRequest组件的浏览器 xmlHttpRequest = new XMLHttpRequest();//创建其他浏览器上的XMLHttpRequest对象 } } &quot;if(window.ActiveXObject)&quot;用来判断是否使用IE浏览器.其中ActiveXOject并不是Windows对象的标准属性,而是IE浏览器中专有的属性,可以用于判断浏览器是否支持ActiveX控件.通常只有IE浏览器或以IE浏览器为核心的浏览器才能支持Active控件.&quot;else if(window.XMLHttpRequest)&quot;是为了防止一些浏览器既不支持ActiveX控件,也不支持XMLHttpRequest组件而进行的判断.其中XMLHttpRequest也不是window对象的标准属性,但可以用来判断浏览器是否支持XMLHttpRequest组件.如果浏览器既不支持ActiveX控件,也不支持XMLHttpRequest组件,那么就不会对xmlHttpRequest变量赋值. 2. 创建HTTP请求创建了XMLHttpRequest对象之后，必须为XMLHttpRequest对象创建HTTP请求，用于说明XMLHttpRequest对象要从哪里获取数据。通常可以是网站中的数据,也可以是本地中其他文件中的数据。 创建HTTP请求可以使用XMLHttpRequest对象的open()方法,其语法代码如下所示: XMLHttpRequest.open(method,URL,flag,name,password); 代码中的参数解释如下所示: method：该参数用于指定HTTP的请求方法，一共有get、post、head、put、delete五种方法，常用的方法为get和post。 URL：该参数用于指定HTTP请求的URL地址，可以是绝对URL，也可以是相对URL。 flag：该参数为可选，参数值为布尔型。该参数用于指定是否使用异步方式。true表示异步、false表示同步，默认为true。 name：该参数为可选参数，用于输入用户名。如果服务器需要验证，则必须使用该参数。 password：该参数为可选，用于输入密码。若服务器需要验证，则必须使用该参数。 通常可以使用以下代码来访问一个网站文件的内容。 xmlHttpRequest.open(“get”,”http://www.aspxfans.com/BookSupport/JavaScript/ajax.htm&quot;,true); 或者使用以下代码来访问一个本地文件内容： xmlHttpRequest.open(“get”,”ajax.htm”,true); 注意：如果HTML文件放在Web服务器上，在Netscape浏览器中的JavaScript安全机制不允许与本机之外的主机进行通信。也就是说，使用open()方法只能打开与HTML文件在同一个服务器上的文件。而在IE浏览器中则无此限制（虽然可以打开其他服务器上的文件，但也会有警告提示）。 3. 设置响应HTTP请求状态变化的函数创建完HTTP请求之后，应该就可以将HTTP请求发送给Web服务器了。然而，发送HTTP请求的目的是为了接收从服务器中返回的数据。从创建XMLHttpRequest对象开始，到发送数据、接收数据、XMLHttpRequest对象一共会经历以下5种状态。 未初始化状态。在创建完XMLHttpRequest对象时，该对象处于未初始化状态，此时XMLHttpRequest对象的readyState属性值为0。 初始化状态。在创建完XMLHttpRequest对象后使用open()方法创建了HTTP请求时，该对象处于初始化状态。此时XMLHttpRequest对象的readyState属性值为1。 发送数据状态。在初始化XMLHttpRequest对象后，使用send()方法发送数据时，该对象处于发送数据状态，此时XMLHttpRequest对象的readyState属性值为2。 接收数据状态。Web服务器接收完数据并进行处理完毕之后，向客户端传送返回的结果。此时，XMLHttpRequest对象处于接收数据状态，XMLHttpRequest对象的readyState属性值为3。 完成状态。XMLHttpRequest对象接收数据完毕后，进入完成状态，此时XMLHttpRequest对象的readyState属性值为4。此时接收完毕后的数据存入在客户端计算机的内存中，可以使用responseText属性或responseXml属性来获取数据。 只有在XMLHttpRequest对象完成了以上5个步骤之后，才可以获取从服务器端返回的数据。因此，如果要获得从服务器端返回的数据，就必须要先判断XMLHttpRequest对象的状态。 XMLHttpRequest对象可以响应readystatechange事件，该事件在XMLHttpRequest对象状态改变时（也就是readyState属性值改变时）激发。因此，可以通过该事件调用一个函数，并在该函数中判断XMLHttpRequest对象的readyState属性值。如果readyState属性值为4则使用responseText属性或responseXml属性来获取数据。具体代码如下所示： //设置当XMLHttpRequest对象状态改变时调用的函数，注意函数名后面不要添加小括号 xmlHttpRequest.onreadystatechange = getData; //定义函数 function getData(){ //判断XMLHttpRequest对象的readyState属性值是否为4，如果为4表示异步调用完成 if(xmlHttpRequest.readyState == 4) { //设置获取数据的语句 } } 4. 设置获取服务器返回数据的语句如果XMLHttpRequest对象的readyState属性值等于4，表示异步调用过程完毕，就可以通过XMLHttpRequest对象的responseText属性或responseXml属性来获取数据。 但是，异步调用过程完毕，并不代表异步调用成功了，如果要判断异步调用是否成功，还要判断XMLHttpRequest对象的status属性值，只有该属性值为200，才表示异步调用成功，因此，要获取服务器返回数据的语句，还必须要先判断XMLHttpRequest对象的status属性值是否等于200，如以下代码所示： if(xmlHttpRequst.status == 200) { document.write(xmlHttpRequest.responseText);//将返回结果以字符串形式输出 //document.write(xmlHttpRequest.responseXML);//或者将返回结果以XML形式输出 } 注意：如果HTML文件不是在Web服务器上运行，而是在本地运行，则xmlHttpRequest.status的返回值为0。因此，如果该文件在本地运行，则应该加上xmlHttpRequest.status == 0的判断。 通常将以上代码放在响应HTTP请求状态变化的函数体内，如以下代码所示： //设置当XMLHttpRequest对象状态改变时调用的函数，注意函数名后面不要添加小括号 xmlHttpRequest.onreadystatechange = getData; //定义函数 function getData(){ //判断XMLHttpRequest对象的readyState属性值是否为4，如果为4表示异步调用完成 if(xmlHttpRequest.readyState==4){ if(xmlHttpRequest.status == 200 || xmlHttpRequest.status == 0){//设置获取数据的语句 document.write(xmlHttpRequest.responseText);//将返回结果以字符串形式输出 //docunment.write(xmlHttpRequest.responseXML);//或者将返回结果以XML形式输出 } } } 5. 发送HTTP请求在经过以上几个步骤的设置之后，就可以将HTTP请求发送到Web服务器上去了。发送HTTP请求可以使用XMLHttpRequest对象的send()方法，其语法代码如下所示： XMLHttpRequest.send(data); 其中data是个可选参数，如果请求的数据不需要参数，即可以使用null来替代。data参数的格式与在URL中传递参数的格式类似，以下代码为一个send()方法中的data参数的示例： name=myName&amp;value=myValue 只有在使用send()方法之后，XMLHttpRequest对象的readyState属性值才会开始改变，也才会激发readystatechange事件，并调用函数。 6、局部更新在通过Ajax的异步调用获得服务器端数据之后，可以使用JavaScript或DOM来将网页中的数据进行局部更新。 三、完整的AJAX实例&lt;html&gt; &lt;head&gt; &lt;title&gt;AJAX实例&lt;/title&gt; &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; function ajaxHttpRequestFunc(){ let xmlHttpRequest; // 创建XMLHttpRequest对象，即一个用于保存异步调用对象的变量 if(window.ActiveXObject){ // IE浏览器的创建方式 xmlHttpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); }else if(window.XMLHttpRequest){ // Netscape浏览器中的创建方式 xmlHttpRequest = new XMLHttpRequest(); } xmlHttpRequest.onreadystatechange=function(){ // 设置响应http请求状态变化的事件 console.log(&apos;请求过程&apos;, xmlHttpRequest.readyState); if(xmlHttpRequest.readyState == 4){ // 判断异步调用是否成功,若成功开始局部更新数据 console.log(&apos;状态码为&apos;, xmlHttpRequest.status); if(xmlHttpRequest.status == 200) { console.log(&apos;异步调用返回的数据为：&apos;, xmlHttpRequest .responseText); document.getElementById(&quot;myDiv&quot;).innerHTML = xmlHttpRequest .responseText; // 局部刷新数据到页面 } else { // 如果异步调用未成功,弹出警告框,并显示错误状态码 alert(&quot;error:HTTP状态码为:&quot;+xmlHttpRequest.status); } } } xmlHttpRequest.open(&quot;GET&quot;,&quot;https://www.runoob.com/try/ajax/ajax_info.txt&quot;,true); // 创建http请求，并指定请求得方法（get）、url（https://www.runoob.com/try/ajax/ajax_info.txt）以及验证信息 xmlHttpRequest.send(null); // 发送请求 } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;原数据&lt;/div&gt; &lt;input type = &quot;button&quot; value = &quot;更新数据&quot; onclick = &quot;ajaxHttpRequestFunc()&quot;&gt; &lt;/body&gt; &lt;/html&gt; 直接运行该段代码可能会出现跨域的现象，控制台的报错信息如下： 这是因为代码中设置请求的是菜鸟驿站服务端的文件，所以出现跨域导致未正常获取到服务端返回的数据。 解决办法：复制该段代码在菜鸟驿站的编辑器中粘贴运行即可。 点击运行前页面显示为： 点击运行后页面显示为： 好啦，关于ajax的部分到此就全部学习完成了,恭喜你又掌握一个新知识点~","path":"2020/11/10/ajax详解/"},{"title":"jQuery基本用法","text":"作为前端必备知识点，怎么能不会Jquery呢，今天我们来学一下Jquery吧~ jQuery基本语法jQuery语法jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。基础语法： $(selector).action() 美元符号定义 jQuery 选择符（selector）”查询”和”查找” HTML 元素 jQuery 的 action() 执行对元素的操作 // 实例 $(this).hide() //隐藏当前元素 $(&quot;p&quot;).hide() //隐藏所有 &lt;p&gt; 元素 $(&quot;p.test&quot;).hide() //隐藏所有 class=&quot;test&quot; 的 &lt;p&gt; 元素 $(&quot;#test&quot;).hide() //隐藏 id=&quot;test&quot; 的元素 jQuery选择器jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。jQuery 中所有选择器都以美元符号开头：$()。 // 实例 $(&quot;p&quot;).hide(); //元素选择器 $(&quot;#test&quot;).hide(); //id选择器 $(&quot;.test&quot;).hide(); // class选择器 jQuery获取内容或属性 text() 设置或返回所选元素的文本内容 html() 设置或返回所选元素的内容（包括 HTML 标记） val() 设置或返回表单字段的值 attr() 方法用于获取属性值。 //获取元素文本内容 $(&quot;#btn1&quot;).click(function(){ alert(&quot;Text: &quot; + $(&quot;#test&quot;).text()); }); //设置元素文本内容 $(&quot;#btn1&quot;).click(function(){ $(&quot;#test1&quot;).text(&quot;Hello world!&quot;); }); //获取元素属性 $(&quot;button&quot;).click(function(){ alert($(&quot;#runoob&quot;).attr(&quot;href&quot;)); }); //设置元素属性 $(&quot;button&quot;).click(function(){ $(&quot;#runoob&quot;).attr({ &quot;href&quot; : &quot;http://www.runoob.com/jquery&quot;, &quot;title&quot; : &quot;jQuery 教程&quot; }); }); //text()、html() 以及 val() 的回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值 $(&quot;#btn2&quot;).click(function(){ $(&quot;#test2&quot;).html(function(i,origText){ return &quot;旧 html: &quot; + origText + &quot; 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: &quot; + i + &quot;)&quot;; }); }); 操作表单对象属性Jquery提供了两个方法：prop(),attr()。官方的建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()。 &lt;input type=&quot;checkbox&quot; id=&quot;checkId&quot; checked=&quot;&quot;/&gt; &lt;input type=&quot;text&quot; id=&quot;textId&quot; value=&quot;abc&quot; valuebak=&quot;&quot; /&gt; &lt;script&gt; $(function() { var checkValue = $(&quot;#checkId&quot;).prop(&apos;checked&apos;); //获取复选框checked的属性值 console.log(checkValue); var textValue = $(&quot;#textId&quot;).attr(&apos;valuebak&apos;); //获取输入框valuebak的属性值 console.log(textValue ); $(&quot;#checkId&quot;).prop(&apos;checked&apos;,’true’); //给复选框checked的属性赋值 $(&quot;#textId&quot;).attr(&apos;valuebak&apos;,’abc’); //给输入框valuebak的属性赋值 }); &lt;/script&gt; jQuery添加元素 append() 在被选元素的结尾插入内容 prepend() 在被选元素的开头插入内容 after() 在被选元素之后插入内容 before() 在被选元素之前插入内容 append/prepend和after/before有什么区别呢？ append &lt;p&gt; &lt;span class=&quot;s1&quot;&gt;s1&lt;/span&gt; &lt;/p&gt; &lt;script&gt; $(&quot;p&quot;).append(&apos;&lt;span class=&quot;s2&quot;&gt;s2&lt;/span&gt;&apos;); &lt;/script&gt; 结果是这样的: 1234&lt;p&gt; &lt;span class=&quot;s1&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;s2&lt;/span&gt;&lt;/p&gt; after &lt;p&gt; &lt;span class=&quot;s1&quot;&gt;s1&lt;/span&gt; &lt;/p&gt; &lt;script&gt; $(&quot;p&quot;).after(&apos;&lt;span class=&quot;s2&quot;&gt;s2&lt;/span&gt;&apos;); &lt;/script&gt; 结果是这样的: 1234&lt;p&gt; &lt;span class=&quot;s1&quot;&gt;s1&lt;/span&gt;&lt;/p&gt;&lt;span class=&quot;s2&quot;&gt;s2&lt;/span&gt; 总结：append/prepend 是在选择元素内部嵌入。after/before 是在元素外面追加。 jQuery删除元素 remove() 删除被选元素（及其子元素） empty() 从被选元素中删除子元素 //过滤被删除元素 $(&quot;p&quot;).remove(&quot;.italic&quot;); remove()和hide()的区别用 hide 和用 remove 都可以得到相同效果，但两者有区别，当我们用hide 时，事件触发后HTML代码中第一个 div 多了一个 “display：none；”属性，并且是由此属性来实现页面隐藏，源代码还存在；而用 remove 时，是通过移除第一个 div 及其里面的内容来实现页面隐藏的，源代码已被删除。当需要实现页面隐藏效果时，推荐使用 hide()。 jQuery操作css addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 $(&quot;body div:first&quot;).addClass(&quot;important blue&quot;); $(&quot;h1,h2,p&quot;).removeClass(&quot;blue&quot;); $(&quot;h1,h2,p&quot;).toggleClass(&quot;blue&quot;); $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); $(&quot;p&quot;).css({&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;}); jQuery对象绑定事件页面对不同访问者的响应叫做事件。事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。在事件中经常使用术语”触发”（或”激发”）例如： “当您按下按键时触发 keypress 事件”。 &lt;div id=&quot;btId&quot; name=&quot;btName&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(&apos;#btId&apos;).bind(&apos;click&apos;,function(){ alert(‘click me!’); }); }); &lt;/script&gt; 常用的 jQuery 事件方法 $(document).ready() 允许我们在文档完全加载完后执行函数。 鼠标事件： click() 当按钮点击事件被触发时会调用一个函数。 dblclick() 当双击元素时，会发生 dblclick 事件。 mouseenter() 当鼠标指针穿过元素时，会发生 mouseenter 事件。 mouseleave() 当鼠标指针离开元素时，会发生 mouseleave 事件。 mousedown() 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。 mouseup() 当在元素上松开鼠标按钮时，会发生 mouseup 事件。 hover() 用于模拟光标悬停事件。 键盘事件： keypress() 当按钮被按下时发生该事件。keypress 事件不会触发所有的键（比如 ALT、CTRL、SHIFT、ESC） keydown() 当键盘键被按下时发生 keydown 事件。 keyup() 当键盘键被松开时发生 keyup 事件。 表单事件： submit() 当提交表单时，会发生 submit 事件。该事件只适用于 元素。 change() 当元素的值改变时发生 change 事件（仅适用于表单字段）。当用于 select 元素时，change 事件会在选择某个选项时发生。当用于 text field 或 text area 时，change 事件会在元素失去焦点时发生。 focus() 当元素获得焦点时（当通过鼠标点击选中元素或通过 tab 键定位到元素时），发生 focus 事件。 blur() 当元素失去焦点时，发生 blur 事件。 文档/窗口事件： resize() 当调整浏览器窗口大小时，发生 resize 事件。 scroll() 当用户滚动指定的元素时，会发生 scroll 事件。scroll 事件适用于所有可滚动的元素和 window 对象（浏览器窗口）。 //当点击事件在某个 &lt;p&gt; 元素上触发时，隐藏当前的 &lt;p&gt; 元素： $(&quot;p&quot;).click(function(){ $(this).hide(); }); //当提交表单时，显示警告框： $(&quot;form&quot;).submit(function(){ alert(&quot;提交&quot;); }); //当 &lt;input&gt; 字段获得焦点时调整span标签的样式 $(&quot;input&quot;).focus(function(){ $(&quot;span&quot;).css(&quot;display&quot;,&quot;inline&quot;).fadeOut(2000); }); //对浏览器窗口调整大小进行计数 $(window).resize(function(){ $(&apos;span&apos;).text(x+=1); }); //对元素滚动的次数进行计数： $(&quot;div&quot;).scroll(function(){ $(&quot;span&quot;).text(x+=1); }); jQuery常用效果 hide() 和 show() 隐藏和显示 HTML 元素 $(selector).hide(speed,callback);可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是隐藏或显示完成后所执行的函数名称。第二个参数是一个字符串，表示过渡使用哪种缓动函数。 $(document).ready(function(){ $(&quot;.hidebtn&quot;).click(function(){ $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function(){ alert(&quot;Hide() 方法已完成!&quot;); }); }); }); toggle() 切换 hide() 和 show() 方法。 fadeIn() 和 fadeOut() 用于淡入已隐藏的元素/淡出可见元素。 fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。 $(&quot;button&quot;).click(function(){ $(&quot;#div1&quot;).fadeToggle(); $(&quot;#div2&quot;).fadeToggle(&quot;slow&quot;); $(&quot;#div3&quot;).fadeToggle(3000); }); fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间） $(selector).fadeTo(speed,opacity,callback);必需的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。fadeTo() 方法中必需的 opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）。可选的 callback 参数是该函数完成后所执行的函数名称。 $(&quot;button&quot;).click(function(){ $(&quot;#div1&quot;).fadeTo(&quot;slow&quot;,0.15); $(&quot;#div2&quot;).fadeTo(&quot;slow&quot;,0.4); $(&quot;#div3&quot;).fadeTo(&quot;slow&quot;,0.7); }); slideDown() 和slideUp() 用于向下/向上滑动元素。 slideToggle() 在 slideDown() 与 slideUp() 方法之间进行切换。 animate() 方法用于创建自定义动画。 $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({ left:&apos;250px&apos;, opacity:&apos;0.5&apos;, height:&apos;150px&apos;, width:&apos;150px&apos; }); }); stop() 方法用于停止动画或效果，在它们完成之前。stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。 jQuery获取页面尺寸 width() 设置或返回元素的宽度（不包括内边距、边框或外边距）。 height() 设置或返回元素的高度（不包括内边距、边框或外边距）。 innerWidth() 返回元素的宽度（包括内边距）。 innerHeight() 返回元素的高度（包括内边距）。 outerWidth() 返回元素的宽度（包括内边距和边框）。 outerHeight() 返回元素的高度（包括内边距和边框）。 $(&quot;button&quot;).click(function(){ var txt=&quot;&quot;; txt+=&quot;div 的宽度是: &quot; + $(&quot;#div1&quot;).width() + &quot;&lt;/br&gt;&quot;; txt+=&quot;div 的高度是: &quot; + $(&quot;#div1&quot;).height(); $(&quot;#div1&quot;).html(txt); }); jQuery遍历jQuery 遍历，意为”移动”，用于根据其相对于其他元素的关系来”查找”（或选取）HTML 元素。以某项选择开始，并沿着这个选择移动，直到抵达您期望的元素为止。下图展示了一个家族树。通过 jQuery 遍历，您能够从被选（当前的）元素开始，轻松地在家族树中向上移动（祖先），向下移动（子孙），水平移动（同胞）。这种移动被称为对 DOM 进行遍历。 parent() 返回被选元素的直接父元素。 parents() 返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。 parentsUntil() 返回介于两个给定元素之间的所有祖先元素。","path":"2020/10/22/jQuery基本用法/"},{"title":"undefined、null与NaN","text":"undefined、null和NaN都属于javascript中的数据类型，那么三者有什么区别呢，又要如何区分呢，今天我们来学一下undefined、null与NaN~ 学习参考:https://www.cnblogs.com/pangguoming/p/7690816.htmlhttps://www.jianshu.com/p/9cc8411fa431 undefined、null和NaN都属于javascript中的数据类型。 undefined的类型是一个对象，代表没有定义。 null的类型是个一对象，代表一个空值。 NaN的类型是一个number，代表不是数值类型。 1. undefined当你使用一个未被声明的变量时或者已经声明了但还没有赋值，又或者使用了一个不存在的对象属性，返回的就是undefined。undefined对应类型undefined，布尔型false，字符串undefined，数字计算结果一定是NaN var message;alert(message==undefined)；// true 常见的返回undefined类型的 变量声明且没有赋值 获取对象中不存在的属性 函数需要实参，但是调用时没有传值，形参是undefined 函数调用没有返回值或者return后没有数据，接受函数返回值的变量 var test; //类型，输出undefined document.write( typeof (test)); document.write(&quot;&lt;br/&gt;&quot;); //字符串，输出undefinedtest document.write(test + &apos;test&apos;); document.write(&quot;&lt;br/&gt;&quot;); //数字，输出NaN document.write(test + 10); document.write(&quot;&lt;br/&gt;&quot;); //布尔值，输出false if (test) { document.write(&quot;true&quot;); } if (!test) { document.write(&quot;false&quot;); } 判断undefined: var tmp = undefined; if (typeof(tmp) == &quot;undefined&quot;){ alert(&quot;undefined&quot;); } 说明：typeof 返回的是字符串，有六种可能：”number”、”string”、”boolean”、”object”、”function”、”undefined” 2. null把一个变量的值设置为null，就表示该变量的值不是有效的对象,数组，数字，字符串和布尔值。null对应类型Object，布尔值false，数字0，字符串“null” var test = null; //类型，输出object document.write( typeof (test)); document.write(&quot;&lt;br/&gt;&quot;); //字符串，输出nulltest document.write(test + &apos;test&apos;); document.write(&quot;&lt;br/&gt;&quot;); //数字，输出10 document.write(test + 10); document.write(&quot;&lt;br/&gt;&quot;); //布尔值，输出false if (test) { document.write(&quot;true&quot;); } if (!test) { document.write(&quot;false&quot;); } 判断null： var tmp = null; if (!tmp &amp;&amp; typeof(tmp)!=&quot;undefined&quot; &amp;&amp; tmp!=0){ alert(&quot;null&quot;); } 3.NaNNaN 属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字（例如， “abc” / 4），要么是因为运算的结果非数字（例如，除数为零）。判断一个变量是否为NaN。ES6提供了一个新的 Number.isNaN() 函数，这是一个不同的函数，并且比老的全局 isNaN() 函数更可靠。 // 两大惊人特性 // 1 这的是Number型的 console.log(typeof NaN === &quot;number&quot;); // logs &quot;true&quot; // 2 自己和自己并不相等 console.log(NaN === NaN); // logs &quot;false&quot; 判断NaN： var tmp = 0/0; if(isNaN(tmp)){ alert(&quot;NaN&quot;); } 说明：如果把 NaN 与任何值（包括其自身）相比得到的结果均是 false，所以要判断某个值是否是 NaN，不能使用 == 或 === 运算符。提示：isNaN() 函数通常用于检测 parseFloat() 和 parseInt() 的结果，以判断它们表示的是否是合法的数字。当然也可以用 isNaN() 函数来检测算数错误，比如用 0 作除数的情况。 4.判断undefined和nullnull和undefined的比较: null == undefined 返回true null === undefined 返回false 判断undefined和null: var tmp = undefined; if (tmp == undefined) { alert(&quot;null or undefined&quot;); } var tmp = undefined; if (tmp == null) { alert(&quot;null or undefined&quot;); } 说明：null==undefined 5. 判断undefined、null与NaNundefined、null与NaN的比较: var a1; //a1的值为undefined var a2 = null; var a3 = NaN; alert(a1 == a2); //显示&quot;true&quot; alert(a1 != a2); //显示&quot;false&quot; alert(a1 == a3); //显示&quot;false&quot; alert(a1 != a3); //显示&quot;true&quot; alert(a2 == a3); //显示&quot;false&quot; alert(a2 != a3); //显示&quot;true&quot; alert(a3 == a3); //显示&quot;false&quot; alert(a3 != a3); //显示&quot;true&quot; 从上面的代码可以得出结论：（1）undefined与null是相等；（2）NaN与任何值都不相等，与自己也不相等。 判断undefined、null与NaN: var tmp = null; if (!tmp) { alert(&quot;null or undefined or NaN&quot;); }","path":"2020/09/26/undefined、null与NaN/"},{"title":"js数据结构之链表","text":"学习参考：https://segmentfault.com/a/1190000017569816https://www.jianshu.com/p/f254ec665e57https://www.cnblogs.com/cc-freiheit/p/10591992.html 一、链表和数组的区别大家都用过js中的数组，数组其实是一种线性表的顺序存储结构，它的特点是用一组地址连续的存储单元依次存储数据元素。而它的缺点也正是其特点而造成，比如对数组做删除或者插入的时候，可能需要移动大量的元素。这里大致模拟一下数组的插入操作： function insert(arr, index, data) { for (let i = arr.length; i &gt;index; i--) { arr[i] = arr[i - 1]; } arr[index] = data; } 从上面的代码可以看出数组的插入以及删除都有可能会是一个O(n)的操作。从而就引出了链表这种数据结构，链表不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的缺点，当然它也失去了数组在一块连续空间内随机存取的优点。 二、链表的定义链表是一组节点组成的集合，每个节点都使用一个对象的引用来指向它的后一个节点。指向另一节点的引用叫做链。相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。 数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点(表头)开始迭代列表直到找到所需的元素。 其中，data中保存着数据，next保存着下一个链表的引用。上图中，我们说 data2 跟在 data1 后面，而不是说 data2 是链表中的第二个元素。上图，值得注意的是，我们将链表的尾元素指向了 null 节点，表示链接结束的位置。由于链表的起始点的确定比较麻烦，因此很多链表的实现都会在链表的最前面添加一个特殊的节点，称为 头节点，表示链表的头部。进过改造，链表就成了如下的样子： 三、链表的设计我们设计链表包含两个类，一个是 Node 类用来表示节点，另一个事 LinkedList 类提供插入节点、删除节点等一些操作。 1.Node类Node类包含两个属性： element 用来保存节点上的数据，next 用来保存指向下一个节点的链接，具体实现如下： //节点 function Node(element) { this.element = element; //当前节点的元素 this.next = null; //下一个节点链接 } 2.LinkedList类LinkedList类提供了对链表进行操作的方法，包括插入删除节点，查找给定的值等。值得注意的是，它只有一个属性，那就是使用一个 Node 对象来保存该链表的头节点。它的构造函数的实现如下： //链表类 function LList () { this.head = new Node( &apos;head&apos; ); //头节点 this.find = find; //查找节点 this.insert = insert; //插入节点 this.remove = remove; //删除节点 this.findPrev = findPrev; //查找前一个节点 this.display = display; //显示链表 } head节点的next属性初始化为 null ，当有新元素插入时，next会指向新的元素。链表可分为单向链表、双向链表、环链表等，其定义如下： 3.单向链表 单向链表的特点： 用一组任意的内存空间去存储数据元素（这里的内存空间可以是连续的，也可以是不连续的） 每个节点(node)都由数据本身和一个指向后续节点的指针组成 整个链表的存取必须从头指针开始，头指针指向第一个节点 最后一个节点的指针指向空（NULL） 链表中的几个主要操作： 创建节点 插入节点 搜索/遍历节点 删除节点 合并 初始化节点 指针指向空 存储数据 class Node { constructor(key) { this.next = null; this.key = key; } } 初始化单向链表每个链表都有一个头指针，指向第一个节点，没节点则指向NULL class List { constructor() { this.head = null; } } 创建节点 static createNode(key) { return new createNode(key); } 这里说明一下，这一块我是向外暴露了一个静态方法来创建节点，而并非直接把它封装进插入操作里去，因为我感觉这样的逻辑会更加正确一些。 从创建一个链表 -&gt; 创建一个节点 -&gt; 将节点插入进链表中。可能你会遇到一些文章介绍的方式是直接将一个数据作为参数去调用insert操作，在insert内部做了一个创建节点。 3.1插入节点（插入到头节点之后）插入操作只需要去调整节点的指针即可,两种情况： head没有指向任何节点，说明当前插入的节点是第一个 head指向新节点 新节点的指针指向NULL head有指向的节点 head指向新的节点 新节点的指针指向原本head所指向的节点 function insert(node) { // 如果head有指向的节点 if(this.head){ node.next = this.head; }else { node.next = null; } this.head = node; } 3.2插入节点（在尾节点处添加节点） 根据传入的元素定义一个节点，该元素作为这个节点的值 定义一个变量表示当前的节点 判断是否含有头节点,如果没有头节点，说明链表中还没有值，将传进来的这个值作为头节点；否则，对链表进行遍历，找到最后一个节点，将其next属性赋值为新增的节点 链表的长度+1 //在尾节点处添加节点 function append(element){ let node = new node(element); let current; if(head == null){ current = node }else{ while(current.next){ current = current.next; } current.next = node } length++; } 3.3插入节点（指定位置）将这个位置的前一个节点的next属性赋值为这个节点，并将它原先的下一个节点保存下来，赋值给现在这个节点的next属性 检查postion是否越界,若没有越界，则创建一个节点 定义一个变量表示当前的节点，初始化为头节点，表示从头节点开始遍历；一个变量表示当前节点的前一个节点，作用是插入节点时方便找到前一个节点 判断是否在头节点前添加，如果是就将头节点赋给node的next属性，并且头节点改为这个节点；否则，遍历出这个位置的节点，将该节点插入到这个位置的节点前面 链表的长度+1 function insert(position,element){ let node = new Node(element); let current = head; let previous;//当前节点的前一个节点，在position处添加节点，就是在previos和current之间添加 if(position = 0){ node.next = head; head = node; }else{ for(let i = 0;i&lt; position;i++){ pervious = current; current = current.next; } pervious.next = node; node.next = current; } length++; return true; } //插入节点 function insert ( newElement , item ) { var newNode = new Node( newElement ); var currNode = this.find( item ); newNode.next = currNode.next; currNode.next = newNode; } 3.4删除节点这里分三种情况： 所要删除的节点刚好是第一个，也就是head指向的节点 将head指向所要删除节点的下一个节点(node.next) 要删除的节点为最后一个节点 寻找到所要删除节点的上一个节点(prevNode) 将prevNode中的指针指向NULL 在列表中间删除某个节点 寻找到所要删除节点的上一个节点(prevNode) 将prevNode中的指针指向当前要删除的这个节点的下一个节点 function delete(node) { // 第一种情况 if(node === this.head){ this.head = node.next; return; } // 查找所要删除节点的上一个节点 let prevNode = this.head; while (prevNode.next !== node) { prevNode = prevNode.next; } // 第二种情况 if(node.next === null) { prevNode.next = null; } // 第三种情况 if(node.next) { prevNode.next = node.next; } } 3.5删除指定节点function removed(element){ let node = new Node(element); let pervious; let nextNode; let current = head; if(head != null){ while (current != node){ pervious = current; current = current.next; nextNode = current.next; } pervious.next = nextNode; length--; return true; }else{ return false; } } 3.6删除指定位置节点function removedAt(position){ let current = head; let pervious; let nextNode; let i = 0; while(i &lt; position){ pervious = current; current = current.next; nextNode = current.next; } pervious.next = nextNode; length--; return true; } 3.7搜索节点 从head开始查找 找到节点中的key等于想要查找的key的时候，返回该节点 function find(key) { let node = this.head; while(node !== null &amp;&amp; node.key !== key){ node = node.next; } return node; } 3.8查询某个位置是哪个节点function searchElement(element){ //输入元素，找到该元素后返回该元素的位置 if(head != null){ let node = new Node(element); let current; let index = 0; if(head == node){ return 0; }else{ current = head; while(current != node){ current = current.next; index++; } return index; } }else{ return -1; } } 3.9查询某个节点是在哪个位置function searchPosition(position){ let i = 0; let current = head; while(i&lt; position){ current = current.next; i++; } return current; } 3.10显示链表function display () { var currNode = this.head; while ( !(currNode.next == null) ){ console.log( currNode.next.element ); currNode = currNode.next; } } 3.11单向链表整体的代码// 链表节点 class Node { constructor(element) { this.element = element; this.next = null; } } // 链表 class LinkedList { constructor() { this.head = null; this.length = 0; // length 同数组 length 与下标关系 } // 追加元素 append(element) { let node = new Node(element); let current = null; // 指针？ if (this.head === null) { this.head = node; } else { current = this.head; while (current.next) { current = current.next; } current.next = node; } this.length++; } // 任意位置插入元素 insert (position, element) { if (position &gt;= 0 &amp;&amp; position &lt;= this.length) { let node = new Node(element); let current = this.head; let previous = null; let index = 0; if (position === 0) { this.head = node; } else { while (index++ &lt; position) { previous = current; current = current.next; } node.next = current; previous.next = node; } this.length++; return true } return false } // 移除指定位置元素 removeAt(position) { if (position &gt; -1 &amp;&amp; position &lt; length) { let current = this.head; let previous = null; let index = 0; if (position === 0) { this.head = current.next; } else { while(index++ &lt; position) { previous = current; current = current.next; } previous.next = current.next; } this.length--; return current.element; } return null } // 寻找元素下标 findIndex(element) { let current = this.head; let index = -1; while (current) { if (element === current.element) { return index + 1; } index++; current = current.next; } return -1; } // 删除指定文档 remove(element) { let index = this.findIndex(element); return removeAt(index); } isEmpty() { return !this.length; } size() { return this.length; } // 输出字符串 toString() { let current = this.head; let string = &apos;&apos;; while (current) { string += ` ${current.element}`; current = current.next; } return string; } } var ll = new LinkedList(); console.log(ll); ll.append(2); ll.append(6); ll.append(24); ll.append(152); ll.insert(3, 18); console.log(ll); console.log(ll.findIndex(24)); test2.js class Node { constructor(data) { this.data = data; this.prev = null; this.next = null; }} // 单链表 class SingleList { constructor() { this.size = 0; // 单链表的长度 this.head = new Node(&apos;head&apos;); // 表头节点 this.currNode = &apos;&apos;; // 当前节点的指向 } // 判断单链表是否为空 isEmpty() { return this.size === 0; } // 获取单链表的最后一个节点 findLast() { let currNode = this.head; while (currNode.next) { currNode = currNode.next; } return currNode; } // 单链表的遍历显示 display() { let result = &apos;&apos;; let currNode = this.head; while (currNode) { result += currNode.data; currNode = currNode.next; if(currNode) { result += &apos;-&gt;&apos;; } } console.log(result); } // 从当前位置向前移动 n 个节点。 advance(n, currNode = this.head) { this.currNode = currNode; while ((n--) &amp;&amp; this.currNode.next) { this.currNode = this.currNode.next; } return this.currNode; } // 在单链表中寻找item元素 find(item) { let currNode = this.head; while (currNode &amp;&amp; (currNode.data !== item)) { currNode = currNode.next; } return currNode; } // 显示当前节点 show() { console.log(this.currNode.data); } // 获取单链表的长度 getLength() { return this.size; } // 向单链表中插入元素 insert(item, element) { let itemNode = this.find(item); if(!itemNode) { // 如果item元素不存在 return; } let newNode = new Node(element); newNode.next = itemNode.next; // 若currNode为最后一个节点，则currNode.next为空 itemNode.next = newNode; this.size++; } // 在单链表中删除一个节点 remove(item) { if(!this.find(item)) { // item元素在单链表中不存在时 return; } // 企图删除头结点 if (item === &apos;head&apos;) { if (!(this.isEmpty())) { return; } else { this.head.next = null; return; } } let currNode = this.head; while (currNode.next.data !== item) { // 企图删除不存在的节点 if (!currNode.next) { return; } currNode = currNode.next; } currNode.next = currNode.next.next; this.size--; } // 在单链表的尾部添加元素 append(element) { let currNode = this.findLast(); let newNode = new Node(element); currNode.next = newNode; this.size++; } // 清空单链表 clear() { this.head.next = null; this.size = 0; }} let myList = new SingleList();let arr = [3, 4, 5, 6, 7, 8, 9]; for(let i=0; i&lt;arr.length; i++){ myList.append(arr[i]);} myList.display(); // head-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9 console.log(myList.find(4)); // Node {data: 4, prev: null, next: Node} myList.insert(9, 9.1);myList.insert(3, 3.1);myList.display(); // head-&gt;3-&gt;3.1-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;9.1 myList.remove(9.1);myList.remove(3);myList.display(); // head-&gt;3.1-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9 console.log(myList.findLast()); // Node {data: 9, prev: null, next: null} console.log(myList.advance(4)); // Node {data: 6, prev: null, next: Node} console.log(myList.getLength()); // 7 myList.clear();myList.display(); // head 判断单链表中是否有环 var myList = new SingleList() var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;] arr.forEach(item =&gt; myList.append(item)) var C = myList.find(&apos;C&apos;) var G = myList.findLast() G.next = C // 现在链表有环 写个函数来判断链表是否有环，使用了快慢指针，如果快指针走到最后为null，说明链表没有环，如果两个指针在某个时刻相等了，则说明链表有环。 function hasCycle (head) { // 至少 2 个节点才能构成一个环 if (!head || !head.next) { return false; } // 设置快慢指针 let slow = head; let fast = head.next; // 如果快指针一直没有追上慢指针 while (slow !== fast) { // 如果没有环，则快指针会抵达终点 if (!fast || !fast.next) { return false; } slow = slow.next; fast = fast.next.next; } // 如果有环，那么快指针会追上慢指针 return true; }; hasCycle(myList)// 输出：this list has rings 4.双向链表如果你把上面介绍的单向列表都看明白了，那么这里介绍的双向列表其实差不多。 从上面的图可以很清楚的看到双向链表和单向链表的区别。双向链表多了一个指向上一个节点的指针。 初始化节点 指向前一个节点的指针 指向后一个节点的指针 节点数据 class ListNode { this.prev = null; this.next = null; this.key = key; } 初始化双向链表 头指针指向NULL class List { constructor(){ this.head = null; } } 创建节点 static createNode(key){ return new ListNode(key); } 4.1插入节点（（插入到头节点之后） 看上图中head后面的第一个节点可以知道，该节点的prev指向NULL 节点的next指针指向后一个节点, 也就是当前头指针所指向的那个节点 如果head后有节点，那么原本head后的节点的prev指向新插入的这个节点(因为是双向的嘛)最后将head指向新的节点 function insert(node) { node.prev = null; node.next = this.head; if(this.head){ this.head.prev = node; } this.head = node; } 4.2搜索节点这里和单向节点一样，就直接贴代码了 function search(key) { let node = this.head; while (node !== null &amp;&amp; node.key !== key) { node = node.next; } return node; } 4.3删除节点和之前单向链表一样，分三种情况去看： 删除的是第一个节点 head指向所要删除节点的下一个节点 下一个节点的prev指针指向所要删除节点的上一个节点 删除的是中间的某个节点 所要删除的前一个节点的next指向所要删除的下一个节点 所要删除的下一个节点的prev指向所要删除的前一个节点 删除的是最后一个节点 要删除的节点的上一个节点的next指向null（也就是指向删除节点的next所指的地址） function delete(node) { const {prev,next} = node; delete node.prev; delete node.next; if(node === this.head){ this.head = next; } if(next){ next.prev = prev; } if(prev){ prev.next = next; } } 双向链表整体代码class ListNode { constructor(key) { // 指向前一个节点 this.prev = null; // 指向后一个节点 this.next = null; // 节点的数据(或者用于查找的键) this.key = key; } } /** * 双向链表 */ class List { constructor() { this.head = null; } static createNode(key) { return new ListNode(key); } insert(node) { node.prev = null; node.next = this.head; if (this.head) { this.head.prev = node; } this.head = node; } search(key) { let node = this.head; while (node !== null &amp;&amp; node.key !== key) { node = node.next; } return node; } delete(node) { const { prev, next } = node; delete node.prev; delete node.next; if (node === this.head) { this.head = next; } if (prev) { prev.next = next; } if (next) { next.prev = prev; } } }","path":"2020/09/20/js数据结构之链表/"},{"title":"js事件大全","text":"今天我们来学习js事件，一起来学习吧~学习参考：https://blog.csdn.net/weixin_44388523/article/details/86616710 常用事件类别详见：https://blog.csdn.net/allen_hdh/article/details/31374379 兼容性详见：https://www.jb51.net/article/28772.htm 更多事件详见：https://www.runoob.com/jsref/dom-obj-event.html 一、事件三要素 事件对象 事件名称 事件处理函数 二、常见事件的写法1. 嵌入式(传统事件绑定)优点：简单易懂缺点：将JavaScript代码与html代码混为一起，不利于多人协作开发 //例如：(直接在HTML中写入JS代码) &lt;button onclick=&quot;alert(&apos;hello&apos;)&quot; onmouseover=&quot;show()&quot; id=&apos;btn&apos;&gt;点击&lt;/button&gt; 2. 脚本模型(现代事件绑定) 在JavaScript中完成事件的绑定obj.onclick=function(){}; //例如 //找到button元素 var btn = document.getElementById(&apos;btn&apos;); //添加点击事件 btn.onclick = function(){ alert(&apos;hello&apos;); }; 3. W3C事件添加事件：addEventListener(事件名,事件函数,false)删除事件：removeEventListener(事件名,事件函数,false)注意：事件名 不需要前缀on //例如 btn.addEventListener(&apos;mouseover&apos;,function(){ btn.innerHTML = &apos;点他&apos;; },false); 三、事件类型Web浏览器中可能发生的事件有很多类型。几种常用的事件类型如下： UI事件 焦点事件 鼠标与滚轮事件 键盘与文本事件 剪贴板事件 打印事件 拖动事件 动画和过渡事件 多媒体事件 复合事件 变动事件 HTML5事件 设备事件 触摸与手势事件 1. UI事件UI事件中UI即(User Interface,用户界面)，当用户与页面显示的元素交互时触发。UI事件中主要包括load,unload,abort,error,select,resize,scroll事件。 load：此事件为当页面完全加载完之后（包括所有的图像、js文件、css文件等外部资源），就会触发window上面的load事件。unload：在文档被完全卸载后触发。用户从一个页面切换到另一个页面就会触发unload事件。利用这个事件最多的情况是清除引用，避免内存泄漏。move：浏览器的窗口被移动时触发的事件。resize：当调整浏览器的窗口到一个新的宽度或高度时，就会触发resize事件。这个事件在window（窗口）上面触发。因此同样可以通过JS或者body元素中的onresize特性来指定处理程序。scroll：这个事件会在文档被滚动期间重复被触发，所以应当尽量保持事件处理程序的代码简单。error：捕抓当前页面因为某种原因而出现的错误，如脚本错误与外部数据引用的错误。abort：图片在下载时被用户中断。stop：浏览器的停止按钮被按下时触发的事件或者正在下载的文件被中断。 2. 焦点事件 blur：在元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持。focus：在元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。focusin：在元素获得焦点时触发。这个事件冒泡,某些浏览器不支持。focusout：在元素失去焦点时触发。这个事件冒泡，某些浏览器不支持。DOMFocusIn：在元素获得焦点时触发。这个事件与HTML事件focus等价，但它冒泡。只有Opra支持这个事件。DOM3级事件废弃了DOMFocusIn，选择了focusin。DOMFocusOut：在元素失去焦点时触发。这个事件是HTML事件blur的通用版本。只有Opra支持这个事件。DOM3级事件废弃了DOMFocusOut，选择了focusout。 注意：即使blur和focus不冒泡，也可以在捕获阶段侦听到他们。当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：（1）focusout 在失去焦点的元素上触发（2）focusin 在获得焦点的元素上触发（3）blur 在失去焦点的元素上触发（4）DOMFocusOut 在失去焦点的元素上触发（5）focus 在获得焦点的元素上触发（6）DOMFocusIn 在获得焦点的元素上触发 此外，其他表单事件包括： change：当前元素失去焦点并且元素的内容发生改变而触发的事件 [鼠标与键盘的触发均可] (&lt;input&gt;, &lt;keygen&gt;, &lt;select&gt;, 和 &lt;textarea&gt;)input：元素获取用户输入时触发select：用户选取文本时触发 ( &lt;input&gt; 和 &lt;textarea&gt;)search：用户向搜索域输入文本时触发 ( &lt;input=&quot;search&quot;&gt;)reset：当表单重置时触发的事件submit：一个表单被递交时触发的事件 3. 鼠标与滚轮事件 click：用户单击鼠标左键或按下回车键触发dbclick： 用户双击鼠标左键触发。mousedown：在用户按下了任意鼠标按钮时触发。mouseenter：当鼠标移入某元素时触发。mouseleave：当鼠标移出某元素时触发。mouseover：当鼠标移入某元素时触发，移入和移出其子元素时也会触发。mouseout：当鼠标移出某元素时触发，移入和移出其子元素时也会触发。mousemove：鼠标在某元素上移动时触发，即使在其子元素上也会触发。mouseup：在用户释放鼠标按钮时触发。 补充：以上所有事件除了mouseenter和mouseleave外都冒泡、即子元素连带触发。 4. 键盘和文本事件 keydown：当用户按下键盘上的任意键时触发。按住不放，会重复触发。keypress：当用户按下键盘上的字符键时触发。按住不放，会重复触发。keyup：当用户释放键盘上的键时触发。textInput：这是唯一的文本事件，用意是将文本显示给用户之前更容易拦截文本。 注意：这几个事件在用户通过文本框输入文本时才最常用到。补充：当我们在input中输入值时，当键盘按下时，此时value还没有值；当键盘松开时，value才获取到此值。如下(键盘按下一个a)： &lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; var o = document.querySelector(&apos;#ipt&apos;); o.onkeydow = function(){ //按下键不会打印该键的值 console.log(&apos;按下&apos; + o.value); // 按下 }; o.onkeyup = function(){ //松开键才打印该键的值 console.log(&apos;抬起&apos; + o.value); // 抬起a }; &lt;/script&gt; 5. 剪贴板事件 copy：该事件在用户拷贝元素内容时触发cut：该事件在用户剪切元素内容时触发paste：该事件在用户粘贴元素内容时触发 6. 打印事件 afterprint：该事件在页面已经开始打印，或者打印窗口已经关闭时触发beforeprint：该事件在页面即将开始打印时触发 7. 拖动事件 drag：该事件在元素正在拖动时触发dragend：该事件在用户完成元素的拖动时触发dragenter：该事件在拖动的元素进入放置目标时触发dragleave：该事件在拖动元素离开放置目标时触发dragover：该事件在拖动元素在放置目标上时触发dragstart：该事件在用户开始拖动元素时触发drop：该事件在拖动元素放置在目标区域时触发 8. 动画和过渡事件 animationend：该事件在 CSS 动画结束播放时触发animationiteration：该事件在 CSS 动画重复播放时触发animationstart：该事件在 CSS 动画开始播放时触发transitionend：该事件在 CSS 完成过渡后触发。 9. 多媒体事件 abort：事件在视频/音频（audio/video）终止加载时触发。canplay：事件在用户可以开始播放视频/音频（audio/video）时触发。canplaythrough：事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。durationchange：事件在视频/音频（audio/video）的时长发生变化时触发。emptied：当期播放列表为空时触发ended：事件在视频/音频（audio/video）播放结束时触发。error：事件在视频/音频（audio/video）数据加载期间发生错误时触发。loadeddata：事件在浏览器加载视频/音频（audio/video）当前帧时触发。loadedmetadata：事件在指定视频/音频（audio/video）的元数据加载后触发。loadstart：事件在浏览器开始寻找指定视频/音频（audio/video）时触发。pause：事件在视频/音频（audio/video）暂停时触发。play：事件在视频/音频（audio/video）开始播放时触发。playing：事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。progress：事件在浏览器下载指定的视频/音频（audio/video）时触发。ratechange：事件在视频/音频（audio/video）的播放速度发送改变时触发。seeked：事件在用户重新定位视频/音频（audio/video）的播放位置后触发。seeking：事件在用户开始重新定位视频/音频（audio/video）时触发。stalled：事件在浏览器获取媒体数据，但媒体数据不可用时触发。suspend：事件在浏览器读取媒体数据中止时触发。timeupdate：事件在当前的播放位置发送改变时触发。volumechange：事件在音量发生改变时触发。waiting：事件在视频由于要播放下一帧而需要缓冲时触发。 10. 复合事件复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。 compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了。compositionupdate：在向输入字段中插入新字符时触发。compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘的输入状态。 11. 变动事件DOM2级的变动（mutation）事件能在DOM中的某一部分发生变化时给出提示。变动事件是为XML或HTML DOM设计的，并不特定于某种语言。DOM2级定义了如下变动事件： DOMSubtreeModified：在DOM结构中发生的任何变化时触发。这个事件在其他任何事件触发后都会触发。DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发。DOMNodeRemoved：在节点从其父节点中被移除时触发。DOMNodeInsertedIntoDocument：在一个节点被直接插入文档或通过子树间接插入到文档之后触发。这个事件在DOMNodeInserted之后触发。DOMNodeRemovedFromDocument：在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved之后触发。DOMAttrModified：在特性被修改之后触发。DOMCharacterDataModified：在文本节点的值发生变化时触发。DOMAttributeNameChanged：DOMElementNameChanged： 12. HTML5事件 contextmenu：在用户点击鼠标右键打开上下文菜单时触发。beforeUnload：当前页面的内容将要被改变时触发的事件。DOMContentLoad：HTML Dom结构完成时触发，相当于jquery.ready。readystatechange：支持readystatechange事件的每个对象都有一个readyState属性 readyState属性可能包含下列5个值中的一个。（1）uninitialized（未初始化）：对象存在但尚未初始化。（2）loading（正在加载）：对象正在加载数据。（3）loaded（加载完毕）：对象加载数据完成。（4）interactive（交互）：可以操作对象了，但还没有完全加载。（5）complete（完成）：对象已经加载完毕。这些状态看起来很直观，但并非所有对象都会经历readyState的这几个阶段。换句话说，如果某个阶段不适用某个对象，则该对象完全可能跳过该阶段；并没有规定哪个阶段适用于哪个对象。 onhashchange：该事件在当前 URL 的锚部分（URL的参数列表及URL中“#”号后面的所有字符串）发生修改时触发。pageshow：该事件在用户访问页面时触发。pagehide：该事件在用户离开当前网页跳转到另外一个页面时触发。 13. 设备事件 orientationchange：只要用户改变了设备的查看模式，就会触发orientationchange事件。此时的event对象不包含任何有价值的信息。所有的ios设备都支持orientationchange事件和window.orientation属性。 移动Safari的window.orientation属性中可能包含3个值：（1）0表示肖像模式（2）90表示向左旋转的横向模式（“主屏幕”按钮在右侧）（3）-90表示向右旋转的横向模式（“主屏幕”按钮在左侧）。 MozOrientation：Firefox3.6为检测设备的方向引入了一个名为MozOrientation的新事件。（前缀Moz表示这是特定于浏览器开发商的事件，不是标准事件）当设备的加速计检测到设备方向改变时，就会触发这个事件。deviceorientation：deviceorientation事件的意图是告诉开发人员设备在空间中朝向哪儿，而不是如何移动。触发deviceorientation事件时，事件对象中包含着每个轴相对于设备静止状态下发生变化的信息。 事件对象包含以下5个属性。（1）alpha：在围绕z轴旋转时（即左右旋转时），y轴的度数差；是一个介于0到360之间的浮点数。（2）beta：在围绕x轴旋转时（即前后旋转时），z轴的度数差；是一个介于-180到180之间的浮点数。（3）gamma：围绕y轴旋转时（即扭转设备时），z轴的度数差；是一个介于-90到90之间的浮点数。（4）absolute：布尔值，表示设备是否返回一个绝对值。（5）compassCalibrated：布尔值，表示设备的指南针是否校准过。 devicemotion：devicemotion事件是要告诉开发人员设备什么时候移动，而不仅仅是设备方向如何改变。 触发devicemotion事件时，事件对象包含以下属性。（1）acceleration：一个包含x、y和z属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度。（2）accelerationIncludingGravity：一个包含x、y和z属性的对象，在考虑z轴自然重力加速度的情况下，告诉你在每个方向上的加速度。（3）interval：以毫秒表示的时间值，必须在另一个devicemotion事件触发前传入。这个值在每个事件中应该是一个常量。（4）rotationRate：一个表示方向的alpha、beta和gamma属性的对象。 14. 触摸与手势事件1.触摸事件 触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。具体来说，有以下几个触摸事件。 touchstart：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。touchmove：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动。touchend：当手指从屏幕上移开时触发。touchcancel：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。 上面这几个事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但它们却是以兼容DOM的方式实现的。因此，每个触摸事件的event对象都提供了在鼠标事件中常见的属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlkey和metaKey。 除了常见的DOM属性外，触摸事件还包含下列三个用于跟踪触摸的属性。 touches：表示当前跟踪的触摸操作的Touch对象的数组。targetTouches：特定于事件目标的Touch对象的数组。changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 每个Touch对象包含下列属性。（1）clientX：触摸目标在视口中的x坐标。（2）cilentY：触摸目标在视口中的y坐标。（3）identifier：标示触摸的唯一ID。（4）pageX：触摸目标在页面中的x坐标。（5）pageY：触摸目标在页面中的y坐标。（6）screenX：触摸目标在屏幕中的x坐标。（7）screenY：触摸目标在屏幕中的y坐标。（8）target：触摸的DOM节点目标。 2.手势事件 iOS2.0中的Safari还引入了一组手势事件。当两个手指触摸屏幕时就会产生手势，手势通常会改变显示项的大小，或者旋转显示项。有三个手势事件，分别介绍如下。 gesturestart：当一个手指以及按在屏幕上而另一个手指又触摸屏幕时触发。gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发。gestureend：当任何一个手指从屏幕上面移开时触发。 只有两个手指都触摸到事件的接收容器时才会触发这些事件。触摸事件和手势事件之间存在某种关系。当一个手指放在屏幕上时，会触发touchstart事件。如果另一个手指又放在了屏幕上，则会先触发gesturestart事件，随后触发基于该手指的touchstart事件。如果一个或两个手指在屏幕上滑动，将会触发gesturechange事件。但只要有一个手指移开，就会触发gesureend事件，紧接着又会触发基于该手指的touchend事件。 与触摸事件一样，每个手势事件的event对象都包含着标准的鼠标事件属性。此外，还包含两个额外的属性：rotation和scale。其中，rotation属性表示手指变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转（该值从0开始）。而scale属性表示两个手指间距离的变化情况（例如向内会缩短距离）；这个值从1开始，并随距离拉大而增长，随距离缩短而减小。","path":"2020/09/20/js事件大全/"},{"title":"js创建对象","text":"1. 对象字面量方式var person = { name: &quot;XiaoMing&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName: function () { alert(this.name) } 2.object构造函数var person = new Object(); person.name = &quot;XiaoMing&quot;; person.age = 18; person.job = &quot;software Engineer&quot;; person.sayName = function () { alert(this.name); } 使用object构造函数和对象字面量方式创建对象有一个缺点：如果我们想创建与该对象同类型的对象，就会产生大量重复的代码。 3.工厂模式(用函数来封装以特定接口创建对象的细节)function createPerson(name,age,job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () { alert(this.name); } return o; } var person1 = createPerson(&apos;jill&apos;,18,&apos;software&apos;); var person2 = createPerson(&apos;vane&apos;,23,&apos;student&apos;); 使用这种方式创建对象虽然解决了创建多个结构相似的对象的问题，但是没有解决对象识别的问题（即无法判断一个对象的类型） 4.构造函数模式function Person(name,age,job) { this.name = name; this.age = age; this.job = job; this.sayName = function () { alert(this.name); } } var person1 = new Person(&apos;xiaoming&apos;,18,&apos;software&apos;); var person2 = new Person(&apos;xiaohong&apos;,20,&apos;student&apos;); alert(person1.constructor == Person) //true alert(person1 instanceof Object);//true alert(person1 instanceof Person);//true 创建自定义构造函数可以将它的实例标识为一种特定的类型,但是其中的每个方法都要在每个实例上重新创建一遍。即会导致不同的作用域链和标识符解析，但是创建Function新实例的机制是相同的。所以person1.sayName == person2.sayName //false 5. 原型模式function Person() {} // constructor -&gt; Person Person.prototype.name = &quot;xiaoming&quot;; Person.prototype.age = 18; Person.prototype.job = &quot;software&quot;; Person.prototype.sayName = function () { alert(this.name); } // constructor -&gt; object // Person.prototype = { // constructor: Person, // name: &quot;xiaoming&quot;, // age: 18, // job: &quot;software&quot;, // sayName: function () { // alert(this.name); // } // } var person5 = new Person(); person5.sayName(); // xiaoming var person6 = new Person(); person6.sayName(); //xiaoming alert(person5.sayName === person6.sayName);//true 关于原型模式，每个函数在创建时，都有一个prototype属性，指向该函数的原型对象。使用原型对象的好处是可以让所有对向实例共享它所包含的属性和方法。通过 hasOwnPrototype（）方法可以判断属性是实例属性还是原型属性。若为实例属性，返回true，否则返回false。实例中的指针（[[ Prototype ]]）指向原型。原型对象的问题：原型中的所有属性是被很多实例共享的，这种共享对于函数非常合适，然而对于包含引用类型值的属性来说，问题就比较突出。 6.组合使用构造函数模式原型模式构造函数模式用来定义实例属性，原型模式用来定义方法和共享的属性。 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.friends = [&quot;vane&quot;, &quot;ming&quot;]; } Person.prototype = { constructor: Person, sayName: function () { alert(this.name); } } var person9 = new Person(&quot;xiaoming&quot;, 12, &quot;student&quot;); var person10 = new Person(&quot;xiaohong&quot;, 32, &quot;doctor&quot;); person9.friends.push(&apos;xiaogang&apos;); alert(person9.friends);//vane,ming,xiaogang alert(person10.friends);//vane,ming alert(person9.friends === person10.friends);//false alert(person9.sayName === person10.sayName);//true 7.动态原型模式大多数开发人员看到独立的构造函数和原型时，会感到困惑。我们使用动态原型模式解决这一问题。即通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.friends = [&quot;vane&quot;, &quot;ming&quot;]; // 方法 if (typeof this.sayName != &quot;function&quot;) { //使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系 Person.prototype.sayName = function () { alert(this.name); } } } 8.寄生构造函数模式基本思想：创建一个函数，其作用是封装创建对象的代码，然后返回新创建的对象。 function Person(name,age,job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () { alert(this.name); } return o; } var person = new Person(&quot;ming&quot;,18,&quot;software&quot;); person.sayName();//ming 构造函数返回的对象与在构造函数外部创建的对象没什么不同，不能使用instanceof来确定对象的类型。 9.稳妥构造函数模式稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。其与寄生构造函数不同之处：1、新创建对象的实例方法不引用this；2、不使用new操作符调用构造函数 function Person(name, age, job) { var o = new Object(); //可以在这里定义私有变量和函数 o.sayName = function () { alert(name); } return o; } var person12 = Person(&quot;ming&quot;,29,&quot;student&quot;); person12.sayName();//ming","path":"2020/09/06/js创建对象/"},{"title":"如何访问共享文件夹","text":"1. 打开控制面板主页。 2. 进入程序列表点击开启或关闭Windows功能！ 3. 进入windows列表，勾选SMB2 direct，点击确定。 4. 重新启动一下或者直接注销一下计算机就恢复共享文件夹功能了！5.输入指令：net use \\\\10.10.90.5\\supmandemo 密码 /user:用户名 6. 接下来，就可以访问共享文件夹了 \\10.10.90.5\\supmandemo","path":"2020/08/21/如何访问共享文件夹/"},{"title":"DOM详解","text":"作为前端必备知识点，怎么能不会DOM节点操作呢，今天我们来学一下DOM节点操作吧~学习参考：https://www.cnblogs.com/yinshuige/p/5812095.htmlhttps://zhuanlan.zhihu.com/p/148070585https://blog.csdn.net/alex_wen2014/article/details/101962054https://blog.csdn.net/qq_42127861/article/details/82145842 一、什么是DOM？DOM就是文档对象模型，是针对于xml但是扩展用于HTML的应用程序编程接口，定义了访问和操作HTML的文档的标准。文档对象模型( DOM, Document Object Model )主要用于对HTML和XML文档的内容进行操作。DOM描绘了一个层次化的节点树，通过对节点进行操作，实现对文档内容的添加、删除、修改、查找等功能。 DOM树有两种，分别为节点树和元素树。 节点树：把文档中所有的内容都看成树上的节点； 元素树：仅把文档中的所有标签看成树上的节点。 二、DOM的常用方法1.获取节点// 通过id号来获取元素，返回一个元素对象 var myElement = document.getElementById(idName) // 通过name属性获取id号，返回元素对象数组 document.getElementsByName(name) // 通过class来获取元素，返回元素对象数组 document.getElementsByClassName(className) // 通过标签名获取元素，返回元素对象数组 document.getElementsByTagName(tagName) //仅返回第一个匹配的元素,不需要兼容IE document.querySelector(&apos;#idxxx&apos;) //返回所有匹配的元素，querySelectorAll() 不适用于 Internet Explorer 8 及其更早版本。 document.querySelectorAll(&apos;.red&apos;)[0] document.querySelectorAll(&apos;#idxxx&apos;)[0] document.querySelectorAll(&quot;p.intro&quot;); //获取页面中的HTML标签 document.documentElement //获取页面中的BODY标签 document.body //获取页面中的所有元素节点的对象集合型 document.all[&apos;&apos;] 2.获取/设置元素的属性值：// 括号传入属性名，返回对应属性的属性值 element.getAttribute(attributeName) // 传入属性名及设置的值 element.setAttribute(attributeName,attributeValue) 3.创建节点Node// 创建一个html元素，这里以创建h3元素为例 document.createElement(&quot;h3&quot;) // 创建一个文本节点； document.createTextNode(String); // 创建一个属性节点，这里以创建class属性为例 document.createAttribute(&quot;class&quot;); //创建新的注释节点 document.createComment(&apos;注释节点&apos;); //创建文档片段节点 document.createDocumentFragment( ); 4.增添节点// 往element内部最后面添加一个节点，参数是节点类型 parent.appendChild( element/txt/comment/fragment); // 在element内部的中在existingNode前面插入newNode parent.insertBefore(newNode,existingNode); //给元素增加属性节点 element.setAttributeNode( attributeName ); //给元素增加指定属性，并设定属性值 element.setAttribute( attributeName, attributeValue ); 添加文本节点，有两种常见方法： document.createTextNode(‘新增文本内容’); &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;创建文本节点&lt;/h2&gt; &lt;button onclick=&quot;addText()&quot;&gt;创建文本节点&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; function addText(){ var element = document.getElementsByTagName(&apos;p&apos;)[0]; var txt = document.createTextNode(&apos;新增文本内容&apos;); //创建文本节点 element.appendChild(txt); //添加文本节点 } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; element.innerHTML=’新增文本内容’; 【推荐】 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;创建文本节点&lt;/h2&gt; &lt;button onclick=&quot;addText()&quot;&gt;创建文本节点&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; function addText(){ var element = document.getElementsByTagName(&apos;p&apos;)[0]; element.innerHTML=&apos;新增文本内容&apos;; //插入文本内容 } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.删除节点//删除当前节点下指定的子节点，删除成功返回该被删除的节点，否则返回null parentNode.removeChild(Node) //删除具有指定属性名称的属性，无返回值 element.removeAttribute(&apos;属性名&apos;); //删除指定属性，返回值为删除的属性 element.removeAttributeNode( attrNode ); 6.修改节点//用新节点替换父节点中已有的子节点 parentNode.replaceChild( newChild, existingChild ); //若原元素已有该节点，此操作能达到修改该属性值的目的 element.setAttributeNode( attributeName ); //若原元素已有该节点，此操作能达到修改该属性值的目的 element.setAttribute( attributeName, attributeValue ); //更改元素属性 document.getElementById(id).style.property = new style 添加属性节点，修改属性值，有两种常见方法： element.setAttribute( attributeName, attributeValue ); &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;属性节点&lt;/h2&gt; &lt;p class=&quot;classValue&quot;&gt;增添id属性，并修改class属性值&lt;/p&gt; &lt;script&gt; var element = document.getElementsByTagName(&apos;p&apos;)[0]; element.setAttribute(&apos;id&apos;,&apos;idValue&apos;); //添加属性节点 element.setAttribute(&apos;class&apos;,&apos;classNewValue&apos;);//修改属性值 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; element.setAttributeNode( attributeName ); &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;属性节点&lt;/h2&gt; &lt;p class=&quot;classValue&quot;&gt;增添id属性，并修改class属性值&lt;/p&gt; &lt;script&gt; var element = document.getElementsByTagName(&apos;p&apos;)[0]; // 添加属性节点 var attr = document.createAttribute(&apos;id&apos;); attr.value = &apos;idValue&apos;; element.setAttributeNode(attr); // 修改属性值 var attr = document.createAttribute(&apos;class&apos;); attr.value = &apos;classNewValue&apos;; element.setAttributeNode(attr); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 三、DOM常用属性1.获取当前元素的文本// 返回元素的所有文本，包括html代码 element.innerHTML // 返回当前元素的自身及子代所有文本值，只是文本内容，不包括html代码 element.innerText document.write和innerHTML主要区别：document.write是直接将内容写入页面的内容流，会导致页面全部重绘，innerHTML将内容写入某个DOM节点，不会导致页面全部重绘 例子一：页面有初始内容，点击页面中的按钮向页面中通过document.write()方法写入内容，会发现原先的初始内容消失了，整个页面只剩下了通过write()方法写入的内容。原因是整个页面进行了重绘 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--初始内容 --&gt; &lt;button onclick=&quot;fun()&quot; &gt;按鈕&lt;/button&gt; &lt;script&gt; function fun() { document.write(&quot;write内容&quot;); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 举例二：页面有初始内容，在初始内容后面给定一个节点，通过innerHTML向这个节点写内容，初始内容不消失，通过innerHTML新增加的内容准确的显示在节点位置 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 初始内容 --&gt; &lt;a id=&quot;p&quot;&gt;&lt;/a&gt; &lt;button οnclick=&quot;fun()&quot;&gt;按钮&lt;/button&gt; &lt;script&gt; function fun() { document.getElementById(&quot;p&quot;).innerHTML=&quot;新增加的innerHTML内容&quot;; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.设置当前元素的样式// 设置元素的样式时使用style element.style.color=&quot;#eea&quot;; 使用 JavaScript 创建动画&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;style&gt; #container { width: 400px; height: 400px; position: relative; background: yellow; } #animate { width: 50px; height: 50px; position: absolute; background-color: red; } &lt;/style&gt; &lt;body&gt; &lt;p&gt;&lt;button onclick=&quot;myMove()&quot;&gt;单击我&lt;/button&gt;&lt;/p&gt; &lt;div id =&quot;container&quot;&gt; &lt;div id =&quot;animate&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; function myMove() { var elem = document.getElementById(&quot;animate&quot;); var pos = 0; var id = setInterval(frame, 5); function frame() { if (pos == 350) { clearInterval(id); } else { pos++; elem.style.top = pos + &quot;px&quot;; elem.style.left = pos + &quot;px&quot;; } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.获取当前节点的名称// 返回当前节点的名称 node.nodeName nodeName 属性规定节点的值。 元素节点的 nodeName 是标签名 文本节点的 nodeName 是属性名称 属性节点的 nodeName 是#text 4.获取当前节点的值// 返回当前节点的值 node.nodeValue nodeValue 属性规定节点的值。 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本本身 属性节点的 nodeValue 是属性值 5.获取当前节点的节点类型// 返回节点的类型,数字形式（1-12） // 常见几个1：元素节点，2：属性节点，3：文本节点。 node.nodeType nodeType 属性返回节点的类型。nodeType 是只读的。比较重要的节点类型有： 元素类型 NodeType 元素 1 属性 2 文本 3 注释 8 文档 9 5.1 元素节点、属性节点、文本节点三者关系元素节点可以拥有类型属性节点、文本节点、注释节点的子节点。属性节点与文本节点不是一个层面（角度）上的，因为：在旧 DOM 规范中，属性继承自 Node，是一种特殊的节点。但是DOM4 中已废弃这一条，属性不再是节点。 5.2 节点标志（只介绍三种最重要的节点） 元素节点 属性节点 文本节点 注释节点 文档节点 NodeType 1 2 3 8 9 NodeName 标签名 属性名称 #text NodeValue null 属性value 标签中间夹的文本值 5.3 三种节点的获取方法（这里使用jQuery方法）&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () { //代码 }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;csdn&quot; name=&quot;myname&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 1. 获取元素节点//原生写法 var d = document.getElementById(&quot;csdn&quot;); d–&gt;获取当前元素节点 d.nodeType–&gt;获取nodeType（只读） d.nodeName–&gt;获取nodeName（只读） d.nodeValue–&gt;获取nodeValue（无） // jquery写法 var d = $(&quot;ul&quot;) d–&gt;获取所有元素节点 d[0].nodeType–&gt;获取nodeType（只读） d[0].nodeName–&gt;获取nodeName（只读） d[0].nodeValue–&gt;获取nodeValue（无） 注意：（这时候浏览器也打印出了ul的子节点） 其中的text指的是“回车键” 浏览器显示最终结果如下： 分析：对于子节点来说，就是childNodes来说，回车键也算一个节点，那么如图所示，就存在四个回车节点3个元素节点（li） 注意：区分children与childNodes: 2. 获取属性节点//原生写法 var d = document.getElementById(&quot;csdn&quot;).getAttributeNode(&quot;id&quot;); d–&gt;获取当前属性节点 d.nodeType–&gt;获取nodeType（只读） d.nodeName–&gt;获取nodeName（只读） d.nodeValue–&gt;获取nodeValue（无） // jquery写法 var d = $(&quot;ul&quot;)[0].attributes–&gt;获取所有 d–&gt;获取所有属性节点 d[0].nodeType–&gt;获取nodeType（只读） d[0].nodeName–&gt;获取nodeName（只读） d[0].nodeValue–&gt;获取nodeValue（无） d[0].nodeValue=&quot;newValue&quot;–&gt;设置新的nodeValue（写） //之所以在attributes的下标用0是因为attributes是一个json数组，id这个属性就在其attributes[0]这个地方，如果在设置一个class属性，那么class就在attributes[1]这个地方 浏览器显示如下 3. 获取文本节点//原生写法 var d = document. getElementsByTagName(&quot;li&quot;)[0].firstChild; d–&gt;获取当前文本节点 d.nodeType–&gt;获取nodeType（只读） d.nodeName–&gt;获取nodeName（只读） d.nodeValue–&gt;获取nodeValue（无） //jquery写法 var d = $(&quot;li&quot;).first()[0].childNodes–&gt;获取所有 d–&gt;获取所有文本节点 d[0].nodeType–&gt;获取nodeType（只读） d[0].nodeName–&gt;获取nodeName（只读） d[0].nodeValue–&gt;获取nodeValue（无） d[0].nodeValue=&quot;newValue&quot;–&gt;设置新的nodeValue（写） //之所以在childNodes中下标用0，因为childNodes是一个json数组，而此文本节点刚好在其下标为0的地方，即childNodes的第一个元素 浏览器显示如下 综上：想要获得属性节点或者文本节点，第一步首先要绑定元素节点，然后再从元素节点向下找其子节点 四、DOM导航通过 HTML DOM，您能够使用节点关系来导航节点树 节点树中的节点彼此拥有层级关系。我们常用父（parent）、子（child）和同胞（sibling）等术语来描述这些关系。 术语（父、子和同胞，parent、child 以及 sibling）用于描述这些关系。 在节点树中，顶端节点被称为根（根节点）。 每个节点都有父节点，除了根（根节点没有父节点）。 节点能够拥有一定数量的子 同胞（兄弟或姐妹）指的是拥有相同父的节点。 &lt;html&gt; &lt;head&gt; &lt;title&gt;DOM 教程&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;DOM 第一课&lt;/h1&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 通过 JavaScript，您可以使用以下节点属性在节点之间导航： parentNode childNodes[nodenumber] firstChild lastChild nextSibling previousSibling1.获取当前元素的父节点 // 返回当前元素的父节点对象 element.parentNode 2.获取当前元素的子节点// 返回当前元素所有子元素节点对象，只返回HTML节点 element.chlidren // 返回当前元素多有子节点，包括文本，HTML，属性节点。（回车也会当做一个节点） element.chilidNodes // 返回当前元素的第一个子节点对象 element.firstChild // 返回当前元素的最后一个子节点对象 element.lastChild 3.获取当前元素的同级元素// 返回当前元素的下一个同级元素 没有就返回null element.nextSibling // 返回当前元素上一个同级元素 没有就返回 null element.previousSibling","path":"2020/03/22/DOM详解/"},{"title":"正则表达式详解","text":"一. 为什么要使用正则表达式呢？通过使用正则表达式，可以： 测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。 正则表达式(regular expression) 描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 例如，创建一个正则表达式： let re = /ab+c/ // 或者 let re = new RegExp(&quot;ab+c&quot;, &apos;g&apos;)//ab+c/g /* g 是全局搜索; i 不区分大小写; m 多行搜索; s 允许 . 匹配换行符; u 使用unicode码的模式进行匹配; y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。*/ 在 JavaScript 中，正则表达式通常用于以下几个字符串方法 : search() 、match() 、replace()和 split()。 search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。如果没有找到匹配，则返回-1。 match() 方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。 split() 方法用于把字符串分割为字符串数组 //search():使用正则表达式搜索 &quot;Runoob&quot; 字符串，且不区分大小写： var str = &quot;Visit Runoob!&quot;; var n = str.search(/Runoob/i); //match():检索指定的值，或找到一个或多个正则表达式的匹配 var str=&quot; mm -4193 1 with words&quot; var n = str.match(/\\d+/g) // [&quot;4193&quot;, &quot;1&quot;] //replace():使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 Runoob : var str = document.getElementById(&quot;demo&quot;).innerHTML; var txt = str.replace(/microsoft/i,&quot;Runoob&quot;); //split():用于把字符串分割为字符串数组 var str=&quot;How are you doing today?&quot;; var n=str.split(&quot; &quot;); //返回How,are,you,doing,today? 二. 正则字符简单介绍2.1 修饰符介绍修饰符用于执行区分大小写和全局匹配:&quot;i&quot; ：执行对大小写不敏感的匹配。 &quot;g&quot; ：执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 &quot;m&quot; : 执行多行匹配。 var patt1=/is/i; var patt1=/is/g; var patt1=/is/m; var patt1=/is/gi; //全局匹配+忽略大小写 2.2 元字符介绍&quot;^&quot; ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。 &quot;$&quot; ：$会匹配行或字符串的结尾 &quot;\\b&quot; : \\b不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中”This is Regex”匹配单独的单词 “is” 正则就要写成 “\\bis\\b” \\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界 &quot;\\d&quot;: 匹配数字 例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123 正则:^0\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\d$ 这里只是为了介绍”\\d”字符，实际上有更好的写法会在 下面介绍。 &quot;\\w&quot;：匹配字母，数字，下划线 例如我要匹配”a2345BCD__TTz” 正则：”\\w+” 这里的”+”字符为一个量词指重复的次数，稍后会详细介绍。 &quot;\\s&quot;：匹配空格 例如字符 “a b c” 正则：”\\w\\s\\w\\s\\w” 一个字符后跟一个空格，如有字符间有多个空格直接把”\\s” 写成 “\\s+” 让空格重复 &quot;.&quot;：匹配除了换行符以外的任何字符 这个算是”\\w”的加强版了”\\w”不能匹配 空格 如果把字符串加上空格用”\\w”就受限了，看下用 “.”是如何匹配字符”a23 4 5 B C D__TTz” 正则：”.+” &quot;[abc]&quot;: 字符组 匹配包含括号内元素的字符 这个比较简单了只匹配括号内存在的字符，还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了， 2.3 几种反义写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了 &quot;\\W&quot; 匹配任意不是字母，数字，下划线 的字符 &quot;\\S&quot; 匹配任意不是空白符的字符 &quot;\\D&quot; 匹配任意非数字的字符 &quot;\\B&quot; 匹配不是单词开头或结束的位置 &quot;[^abc]&quot; 匹配除了abc以外的任意字符 2.4 量词先解释关于量词所涉及到的重要的三个概念 贪婪(贪心) 如”*”字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的， 懒惰(勉强) 如 “?” 懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处。 占有 如”+” 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但它只尝试一次，不会回溯，就好比先抓一把石头，然后从石头中挑出黄金 常用量词举例&quot;*&quot;(贪婪) 重复零次或更多 例如”aaaaaaaa” 匹配字符串中所有的a 正则： &quot;a*&quot; 会出到所有的字符”a” &quot;+&quot;(懒惰) 重复一次或更多次 例如”aaaaaaaa” 匹配字符串中所有的a 正则： “a+” 会取到字符中所有的a字符， &quot;a+&quot;与 &quot;a *&quot; 不同在于&quot;+&quot;至少是一次而&quot;*&quot;可以是0次， 稍后会与”?”字符结合来体现这种区别 &quot;?&quot;(占有) 重复零次或一次 例如”aaaaaaaa” 匹配字符串中的a 正则 ： “a?” 只会匹配一次，也就是结果只是单个字符a &quot;{n}&quot; 重复n次 例如从”aaaaaaaa” 匹配字符串的a 并重复3次 正则： “a{3}” 结果就是取到3个a字符 “aaa”; &quot;{n,m}&quot; 重复n到m次 例如正则 “a{3,4}” 将a重复匹配3次或者4次 所以供匹配的字符可以是三个”aaa”也可以是四个”aaaa” 正则都可以匹配到 &quot;{n,}&quot; 重复n次或更多次 与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则”a{3,}” a至少要重复3次 把量词了解了之后之前匹配电话号码的正则现在就可以改得简单点了^0\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\d$ 可以改为”^0\\d+-\\d{7}$”。 这样写还不够完美如果因为前面的区号没有做限定，以至于可以输入很多们，而通常只能是3位或者4位，现在再改一下 “^0\\d{2,3}-\\d{7}”如此一来区号部分就可以匹配3位或者4位的了 2.5 懒惰限定符&quot;*?&quot; 重复任意次，但尽可能少重复 如 “acbacb” 正则 “a.*?b” 只会取到第一个”acb” 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而”acbacb”最少字符的结果就是”acb” &quot;+?&quot; 重复1次或更多次，但尽可能少重复 与上面一样，只是至少要重复1次 &quot;??&quot; 重复0次或1次，但尽可能少重复 如 “aaacb” 正则 “a.??b” 只会取到最后的三个字符”acb” &quot;{n,m}?&quot; 重复n到m次，但尽可能少重复 如 “aaaaaaaa” 正则 “a{0,m}” 因为最少是0次所以取到结果为空 &quot;{n,}?&quot; 重复n次以上，但尽可能少重复 如 “aaaaaaa” 正则 “a{1,}” 最少是1次所以取到结果为 “a” 三. 正则进阶-捕获分组下面列出捕获分组常有的用法 &quot;(exp)&quot; 匹配exp,并捕获文本到自动命名的组里 &quot;(?&lt;name&gt;exp)&quot; 匹配exp,并捕获文本到名称为name的组里 &quot;(?:exp)&quot; 匹配exp,不捕获匹配的文本，也不给此分组分配组号 以下为零宽断言 &quot;(?=exp)&quot; 匹配exp前面的位置 如 “How are you doing” 正则”(?.+(?=ing))” 这里取ing前所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为”How are you do”; &quot;(?&lt;=exp)&quot; 匹配exp后面的位置 如 “How are you doing” 正则”(?(?&lt;=How).+)” 这里取”How”之后所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为” are you doing”; &quot;(?!exp)&quot; 匹配后面跟的不是exp的位置 如 “123abc” 正则 “\\d{3}(?!\\d)”匹配3位数字后非数字的结果 &quot;(?&lt;!exp)&quot; 匹配前面不是exp的位置 如 “abc123 “ 正则 “(?&lt;![0-9])123” 匹配”123”前面是非数字的结果也可写成”(?!&lt;\\d)123” 四. 使用RegExp 对象RegExp 对象：是一个预定义了属性和方法的正则表达式对象。 4.1 RegExp 对象方法4.1.1 test()test() 方法是一个正则表达式方法。test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。 var str=&quot;Hello world!&quot;; //查找&quot;Hello&quot; var patt=/Hello/g; var result=patt.test(str); document.write(&quot;返回值: &quot; + result); //查找 &quot;Runoob&quot; patt=/Runoob/g; result=patt.test(str); document.write(&quot;&lt;br&gt;返回值: &quot; + result); //返回值: true //返回值: false 4.1.2 exec()exec() 方法是一个正则表达式方法。exec() 方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 var str=&quot;Hello world!&quot;; //查找&quot;Hello&quot; var patt=/Hello/g; var result=patt.exec(str); document.write(&quot;返回值: &quot; + result); //查找 &quot;RUNOOB&quot; patt=/RUNOOB/g; result=patt.exec(str); document.write(&quot;&lt;br&gt;返回值: &quot; + result); //返回值: Hello //返回值: null 4.1.3 toString()toString() 方法返回正则表达式的字符串值。 var patt = new RegExp(&quot;RUNOOB&quot;, &quot;g&quot;); var res = patt.toString(); //返回值：/RUNOOB/g 4.2 RegExp 对象属性4.2.1 constructorconstructor属性：返回一个函数，该函数是一个创建 RegExp 对象的原型。 在 JavaScript 中, constructor 属性返回对象的构造函数。返回值是函数的引用，不是函数名： JavaScript 正则表达式 constructor 属性返回 function RegExp() { [native code] } JavaScript 数组 constructor 属性返回 function Array() { [native code] } JavaScript 数字 constructor 属性返回 function Number() { [native code] } JavaScript 字符串 constructor 属性返回 returns function String() { [native code] } 如果一个变量是数组你可以使用 constructor 属性来定义。 var patt = new RegExp(&quot;RUNOOB&quot;, &quot;g&quot;); var res = patt.constructor; //返回值：function RegExp() { [native code] } 4.2.2 global属性global属性：判断是否设置了 “g” 修饰符。如果 g 标志被设置，则该属性为 true，否则为 false。： var str=&quot;Visit RUNOOB!&quot;; var patt1=/RUN/g; if(patt1.global) { document.write(&quot;g 模式有设置!&quot;); } else { document.write(&quot;g 模式有设置!&quot;); } //返回值：g 模式有设置! 4.2.3 ignoreCase属性ignoreCase属性：判断是否设置了 “i” 修饰符。如果设置了 “i” 标志，则返回 true，否则返回 false。 var str=&quot;Visit RUNOOB!&quot;; var patt1=/RUN/i; if(patt1.ignoreCase) { document.write(&quot;i 模式有设置!&quot;); } else { document.write(&quot;i 模式没有设置!&quot;); } //返回值：i 模式有设置! 4.2.4 lastIndex属性lastIndex属性：用于规定下次匹配的起始位置。 注意： 该属性只有设置标志 g 才能使用。上次匹配的结果是由方法 RegExp.exec() 和 RegExp.test() 找到的，它们都以 lastIndex 属性所指的位置作为下次检索的起始点。这样，就可以通过反复调用这两个方法来遍历一个字符串中的所有匹配文本。注意：该属性是可读可写的。只要目标字符串的下一次搜索开始，就可以对它进行设置。当方法 exec() 或 test() 再也找不到可以匹配的文本时，它们会自动把 lastIndex 属性重置为 0。 var str=&quot;The rain in Spain stays mainly in the plain&quot;; var patt1=/ain/g; while (patt1.test(str)==true) { document.write(&quot;&apos;ain&apos; found. Index now at: &quot;+patt1.lastIndex); document.write(&quot;&lt;br&gt;&quot;); } //返回值： &apos;ain&apos; found. Index now at: 8 &apos;ain&apos; found. Index now at: 17 &apos;ain&apos; found. Index now at: 28 &apos;ain&apos; found. Index now at: 43 4.2.5 multiline属性multiline属性：判断是否设置了 “m” 修饰符。如果 m 标志被设置，则该属性为 true，否则为 false。 var str=&quot;Visit RUNOOB!&quot;; var patt1=/RUN/gi; if(patt1.multiline) { document.write(&quot;m 模式有设置!&quot;); } else { document.write(&quot;m 模式没有设置!&quot;); } //返回值：m 模式没有设置! 4.2.6 source属性source属性：返回正则表达式的匹配模式，返回模式匹配所用的文本。 var str=&quot;Visit RUNOOB&quot;; var patt1=/RUN/g; document.write(&quot;The text of the RegExp is: &quot;+patt1.source); //返回值：The text of the RegExp is: RUN 五. 常用正则表达式 了解更多常用正则表达式请参考https://www.jianshu.com/p/4ccc491a571a 5.1 校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 5.2 校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;&#39;,;=?$\\&quot;等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 5.3 特殊需求表达式 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\\d{8}$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\\d{9}$) 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 18位身份证号码(数字、字母x结尾)：^((\\d{18})|([0-9x]{18})|([0-9X]{18}))$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 5.4 钱的输入格式 有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 详情参考:https://www.runoob.com/js/js-regexp.htmlhttps://www.cnblogs.com/zery/p/3438845.htmlhttp://tool.oschina.net/uploads/apidocs/jquery/regexp.htmlhttps://www.cnblogs.com/520Girl/p/10031738.html","path":"2019/10/24/正则表达式详解/"},{"title":"EventLoop详解","text":"EventLoop详解什么是进程与线程？相信大家经常会听到 JS 是单线程执行的，但是你是否疑惑过什么是线程？讲到线程，那么肯定也得说一下进程。本质上来说，两个名词都是 CPU 工作时间片的一个描述。 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。 线程是进程中的更小单位，描述了执行一段指令所需的时间。 把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。当然前面两点在服务端中更容易体现，对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。 什么是执行栈？ 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。 当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，foo 函数后执行，当执行完毕后就从栈中弹出了。 平时在开发中，大家也可以在报错中找到执行栈的痕迹 function foo() { throw new Error(&apos;error&apos;) } function bar() { foo() } bar() 大家可以在上图清晰的看到报错在 foo 函数，foo 函数又是在 bar 函数中调用的。 当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题 function bar() { bar() } bar() 浏览器中的 Event Loop 当我们执行 JS 代码的时候其实就是往执行栈中放入函数，那么遇到异步代码的时候该怎么办？其实当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。下面来看以下代码的执行顺序： //执行顺序 script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout 首先先来解释下上述代码的 async 和 await 的执行顺序。当我们调用 async1 函数时，会马上输出 async2 end，并且函数返回一个 Promise，接下来在遇到 await的时候会就让出线程开始执行 async1 外的代码，所以我们完全可以把 await 看成是让出线程的标志。 然后当同步代码全部执行完毕以后，就会去执行所有的异步代码，那么又会回到 await 的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，接下来去执行 then 中的回调，当两个 then 中的回调全部执行完毕以后，又会回到 await 的位置处理返回值，这时候你可以看成是 Promise.resolve(返回值).then()，然后 await 后的代码全部被包裹进了 then 的回调中，所以 console.log(‘async1 end’) 会优先执行于 setTimeout。 如果你觉得上面这段解释还是有点绕，那么我把 async 的这两个函数改造成你一定能理解的代码 new Promise((resolve, reject) =&gt; { console.log(&apos;async2 end&apos;) // Promise.resolve() 将代码插入微任务队列尾部 // resolve 再次插入微任务队列尾部 resolve(Promise.resolve()) }).then(() =&gt; { console.log(&apos;async1 end&apos;) }) 也就是说，如果 await 后面跟着 Promise 的话，async1 end 需要等待三个 tick 才能执行到。那么其实这个性能相对来说还是略慢的，所以 V8 团队借鉴了 Node 8 中的一个 Bug，在引擎底层将三次 tick 减少到了二次 tick。但是这种做法其实是违法了规范的，当然规范也是可以更改的，这是 V8 团队的一个 PR，目前已被同意这种做法。 Event Loop 执行顺序如下所示： 首先执行同步代码，这属于宏任务 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行 执行所有微任务 当执行完所有微任务后，如有必要会渲染页面 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数 所以以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout属于宏任务，所以会有以上的打印。 微任务:包括 process.nextTick ，promise ，MutationObserver。 宏任务:包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。 这里很多人会有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。EventLoop执行顺序：script(主程序代码)—&gt;process.nextTick—&gt;Promises…——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I/O——&gt;UI rendering 更多详情参考：https://blog.csdn.net/itKingOne/article/details/86502910","path":"2019/09/20/EventLoop详解/"},{"title":"webpack基本原理","text":"Webpack引入原因1.在网页中会引用哪些常见的静态资源？ JS.js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS.css .less .sass .scss Images.jpg .png .gif .bmp .svg 字体文件（Fonts）.svg .ttf .eot .woff .woff2 模板文件.ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 2.网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系（比如bootstrap依赖于jQuery） 3.如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； webpack是一个js打包工具，不一个完整的前端构建工具。它的流行得益于模块化和单页应用的流行。webpack提供扩展机制，在庞大的社区支持下各种场景基本它都可找到解决方案。 webpack原理 webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。并不是什么commonjs或者amd之类的模块化规范。 webpack就是识别你的 入口文件。识别你的模块依赖，来打包你的代码。至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。 webpack做的就是分析代码。转换代码，编译代码，输出代码。webpack本身是一个node的模块，所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的) webpack中每个模块有一个唯一的id，是从0开始递增的。整个打包后的bundle.js是一个匿名函数自执行。参数则为一个数组。数组的每一项都为个function。function的内容则为每个模块的内容，并按照require的顺序排列。 核心思想： 一切皆模块：正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。 按需加载：传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。 webpack核心概念 entry 一个可执行模块或库的入口文件。 chunk 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 chunk 这体现了webpack的打包机制。 loader 文件转换器，例如把es6转换为es5，scss转换为css。 plugin 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack加入功能。 webpack构建流程从启动webpack构建到输出结果经历了一系列过程，它们是： 解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。 从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。 递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。输出所有chunk到文件系统。 需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如UglifyJsPlugin会在loader转换递归完后对结果再使用UglifyJs压缩覆盖之前的结果。 如何实现一个简单的webpack 读取文件分析模块依赖 对模块进行解析执行(深度遍历) 针对不同的模块使用相应的loader 编译模块，生成抽象语法树AST。 循环遍历AST树，拼接输出js。 打包原理把所有依赖打包成一个bundle.js文件，通过代码分割成单元片段并按需加载。 如图，entry.js是入口文件，调用了util1.js和util2.js，而util1.js又调用了util2.js。 打包后的bundle.js例子 ******/ ([ /* 0 */ //模块id /***/ function(module, exports, __webpack_require__) { __webpack_require__(1); //require资源文件id __webpack_require__(2); /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { //util1.js文件 __webpack_require__(2); var util1=1; exports.util1=util1; /***/ }, /* 2 */ /***/ function(module, exports) { //util2.js文件 var util2=1; exports.util2=util2; /***/ } ... ... /******/ ]); bundle.js是以模块 id 为记号，通过函数把各个文件依赖封装达到分割效果，如上代码 id 为 0 表示 entry 模块需要的依赖， 1 表示 util1模块需要的依赖 require资源文件 id 表示该文件需要加载的各个模块，如上代码_webpack_require__(1) 表示 util1.js 模块，webpack_require(2) 表示 util2.js 模块 exports.util1=util1 模块化的体现，输出该模块 webpack-dev-serve常用命令参数修改package.json的script节点如下，其中 --open表示自动打开浏览器 --port 4321表示打开的端口号为4321 --hot表示启用浏览器热更新 --contentBase src指定启动的根目录 &quot;dev&quot;: &quot;webpack-dev-server --contentBase src --hot --port 4321 --open&quot; 注意：热更新用来进行减少不必要的代码更新，每次重新编译只会更新修改过的文件（相当于打补丁）热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明 使用webpack处理第三方类型在解析对于文件，会自动去调用响应的loaderloader 本质上是一个函数，输入参数是一个字符串，输出参数也是一个字符串。当然，输出的参数会被当成是 JS 代码，从而被 esprima 解析成 AST，触发进一步的依赖解析。webpack会按照从右到左的顺序执行loader。 webpack默认只能处理js类型的文件，无法处理其他的非js类型的文件，如果需要非JS类型的文件，我们需要手动安装一些合适的第三方loader加载器 webpack处理第三方文件类型的过程： 发现这个要处理的文件不是js文件，然后就去配置文件中，查找有没有对应的第三方loader规则 如果能找到对应的规则，就会调用相应的loader处理这种文件类型 在调用loader的时候，是从后往前调用的 当最后一个loader调用完毕，会把处理结果，交给webpack进行打包合并，最终输出到bundle.js中去 如使用webpack打包css文件 新建index.css文件 在main.js引入index.css import &apos;./css/index.css&apos; 如果要打包处理css文件，需要安装cnpm i style-loader css-loader -D 打开webpack.config.js这个配置文件，在里面新增一个配置节点叫module，它是一个对象，在这个module对象上有一个rules属性，是个数组，这个数组中存放了所有第三方文件的匹配和处理规则 module: { // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 { test: /.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] }//处理css文件的规则 ] } 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的","path":"2019/09/18/webpack基本原理/"},{"title":"CSS经典布局——圣杯布局和双飞翼布局","text":"圣杯布局和双飞翼布局圣杯布局和双飞翼布局一直是前端面试的高频考点，圣杯布局的出现是来自由 Matthew Levine 在 2006 年写的一篇文章 《In Search of the Holy Grail》。 比起双飞翼布局，它的起源不是源于对页面的形象表达。在西方，圣杯是表达“渴求之物”的意思。而双飞翼布局则是源于淘宝的UED，可以说是灵感来自于页面渲染。 圣杯布局和双飞翼布局达到的效果基本相同，都是侧边两栏宽度固定，中间栏宽度自适应。 主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样： 圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现， 双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。 效果图如下： 1.圣杯布局圣杯布局要求： header和footer各自占领屏幕所有宽度，高度固定。 中间的container是一个三栏布局。 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。 圣杯布局的三种实现1. 浮动 先定义好header和footer的样式，使之横向撑满。 在container中的三列设为浮动和相对定位(后面会用到)，center要放在最前面，footer清除浮动。 三列的左右两列分别定宽200px和150px，中间部分center设置100%撑满 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了 接下来设置left的 margin-left: -100%;，让left回到上一行最左侧 但这会把center给遮住了，所以这时给外层的container设置 padding-left: 200px;padding-right: 150px;，给left和right空出位置 这时left并没有在最左侧，因为之前已经设置过相对定位，所以通过 left: -200px; 把left拉回最左侧 同样的，对于right区域，设置 margin-right: -150px; 把right拉回第一行 这时右侧空出了150px的空间，所以最后设置 right: -150px;把right区域拉到最右侧就行了。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; body { min-width: 550px; /* 2x leftContent width + rightContent width */ font-weight: bold; font-size: 20px; } #header, #footer { background: rgba(29, 27, 27, 0.726); text-align: center; height: 60px; line-height: 60px; } #footer { clear: both; } #container { padding-left: 200px; /* leftContent width */ padding-right: 150px; /* rightContent width */ overflow: hidden; } #container .column { position: relative; float: left; text-align: center; height: 300px; line-height: 300px; } #center { width: 100%; background: rgb(206, 201, 201); } #left { width: 200px; /* leftContent width */ right: 200px; /* leftContent width */ margin-left: -100%; background: rgba(95, 179, 235, 0.972); } #right { width: 150px; /* rightContent width */ margin-right: -150px; /* rightContent width */ background: rgb(231, 105, 2); } &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt;#header&lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;#center&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. flex弹性盒子 header和footer设置样式，横向撑满。 container中的left、center、right依次排布即可 给container设置弹性布局 display: flex; left和right区域定宽，center设置 flex: 1; 即可 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; body { min-width: 550px; font-weight: bold; font-size: 20px; } #header, #footer { background: rgba(29, 27, 27, 0.726); text-align: center; height: 60px; line-height: 60px; } #container { display: flex; } #container .column { text-align: center; height: 300px; line-height: 300px; } #center { flex: 1; background: rgb(206, 201, 201); } #left { width: 200px; background: rgba(95, 179, 235, 0.972); } #right { width: 150px; background: rgb(231, 105, 2); } &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt;#header&lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;#center&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3. grid布局如上图所示，我们把body划分成三行四列的网格，其中有5条列网格线 给body元素添加display: grid;属性变成一个grid(网格) 给header元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第一行网格的从第一条列网格线开始到第五条列网格线结束 给footer元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第三行网格的从第一条列网格线开始到第五条列网格线结束 给left元素设置grid-row: 2; 和 grid-column: 1/2; 意思是占据第二行网格的从第一条列网格线开始到第二条列网格线结束 给center元素设置grid-row: 2; 和 grid-column: 2/4; 意思是占据第二行网格的从第二条列网格线开始到第四条列网格线结束 给right元素设置grid-row: 2; 和 grid-column: 4/5; 意思是占据第二行网格的从第四条列网格线开始到第五条列网格线结束 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; body { min-width: 550px; font-weight: bold; font-size: 20px; display: grid; } #header, #footer { background: rgba(29, 27, 27, 0.726); text-align: center; height: 60px; line-height: 60px; } #header { grid-row: 1; grid-column: 1/5; } #footer { grid-row: 3; grid-column: 1/5; } .column { text-align: center; height: 300px; line-height: 300px; } #left { grid-row: 2; grid-column: 1/2; background: rgba(95, 179, 235, 0.972); } #center { grid-row: 2; grid-column: 2/4; background: rgb(206, 201, 201); } #right { grid-row: 2; grid-column: 4/5; background: rgb(231, 105, 2); } &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt;#header&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;#center&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 双飞翼布局双飞翼布局要求 header和footer各自占领屏幕所有宽度，高度固定。 中间的container是一个三栏布局。 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。 双飞翼布局的实现 left、center、right三种都设置左浮动 设置center宽度为100% 设置负边距，left设置负边距为100%，right设置负边距为自身宽度 设置content的margin值为左右两个侧栏留出空间，margin值大小为left和right宽度 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; body { min-width: 550px; font-weight: bold; font-size: 20px; } #header, #footer { background: rgba(29, 27, 27, 0.726); text-align: center; height: 60px; line-height: 60px; } #container { overflow: hidden; } .column { text-align: center; height: 300px; line-height: 300px; } #left, #right, #center { float: left; } #center { width: 100%; background: rgb(206, 201, 201); } #left { width: 200px; margin-left: -100%; background: rgba(95, 179, 235, 0.972); } #right { width: 150px; margin-left: -150px; background: rgb(231, 105, 2); } .content { margin: 0 150px 0 200px; } &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt;#header&lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt; &lt;div class=&quot;content&quot;&gt;#center&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 原文链接：https://blog.csdn.net/qq_38128179/article/details/86533976https://blog.csdn.net/qq_38128179/article/details/86542447","path":"2019/09/06/CSS经典布局——圣杯布局和双飞翼布局/"},{"title":"七种实现左侧固定，右侧自适应两栏布局的方法","text":"总结一下左边固定，右边自适应的两栏布局的七种方法。其中有老生常谈的float方法,BFC方法，也有CSS3的flex布局与grid布局。并非所有的布局都会在开发中使用，但是其中也会涉及一些知识点。常用的宽度自适应的方法通常是利用了block水平的元素宽度能随父容器调节的流动特性。另外一种思路是利用CSS中的calc()方法来动态设定宽度。还有一种思路是，利用CSS中的新型布局flex layout与grid layout。 首先创建基本的HTML布局和最基本的样式。 &lt;div class=&quot;wrapper&quot; id=&quot;wrapper&quot;&gt; &lt;div class=&quot;left&quot;&gt; 左边固定宽度，高度不固定 &lt;/br&gt; &lt;/br&gt;&lt;/br&gt;&lt;/br&gt;高度有可能会很小，也可能很大。 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 这里的内容可能比左侧高，也可能比左侧低。宽度需要自适应。&lt;/br&gt; 基本的样式是，两个div相距20px, 左侧div宽 120px &lt;/div&gt; &lt;/div&gt; 基本的样式是，两个盒子相距20px, 左侧盒子宽 120px，右侧盒子宽度自适应。基本的CSS样式如下: .wrapper { padding: 15px 20px; border: 1px dashed #ff6c60; } .left { width: 120px; border: 5px solid #ddd; } .right { margin-left: 20px; border: 5px solid #ddd; } 下面的代码都是基于这套基本代码做覆盖，通过给容器添加不同的类来实现效果。 1.双inline-block方案.wrapper-inline-block { box-sizing: content-box; font-size: 0; // 消除空格的影响 } .wrapper-inline-block .left, .wrapper-inline-block .right { display: inline-block; vertical-align: top; // 顶端对齐 font-size: 14px; box-sizing: border-box; } .wrapper-inline-block .right { width: calc(100% - 140px); } 这种方法是通过width: calc(100% - 140px)来动态计算右侧盒子的宽度。需要知道右侧盒子距离左边的距离，以及左侧盒子具体的宽度(content+padding+border)，以此计算父容器宽度的100%需要减去的数值。同时，还需要知道右侧盒子的宽度是否包含border的宽度。 在这里，为了简单的计算右侧盒子准确的宽度，设置了子元素的box-sizing:border-box;以及父元素的box-sizing: content-box;。 同时，作为两个inline-block的盒子，必须设置vertical-align来使其顶端对齐。 另外，为了准确地应用计算出来的宽度，需要消除div之间的空格，需要通过设置父容器的font-size: 0;,或者用注释消除html中的空格等方法。 缺点: 需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的box-sizing 需要消除空格字符的影响 需要设置vertical-align: top满足顶端对齐。 2.双float方案.wrapper-double-float { overflow: auto; // 清除浮动 box-sizing: content-box; } .wrapper-double-float .left, .wrapper-double-float .right { float: left; box-sizing: border-box; } .wrapper-double-float .right { width: calc(100% - 140px); } 本方案和双float方案原理相同，都是通过动态计算宽度来实现自适应。但是，由于浮动的block元素在有空间的情况下会依次紧贴，排列在一行，所以无需设置display: inline-block;，自然也就少了顶端对齐，空格字符占空间等问题。 不过由于应用了浮动，父元素需要清除浮动。 缺点: 需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的box-sizing。 父元素需要清除浮动。 3.float+margin-left方案.wrapper-float { overflow: hidden; // 清除浮动 } .wrapper-float .left { float: left; } .wrapper-float .right { margin-left: 150px; } 上面两种方案都是利用了CSS的calc()函数来计算宽度值。下面两种方案则是利用了block级别的元素盒子的宽度具有填满父容器，并随着父容器的宽度自适应的流动特性。 但是block级别的元素都是独占一行的，所以要想办法让两个block排列到一起。 我们知道，block级别的元素会认为浮动的元素不存在，但是inline级别的元素能识别到浮动的元素。这样，block级别的元素就可以和浮动的元素同处一行了。 为了让右侧盒子和左侧盒子保持距离，需要为左侧盒子留出足够的距离。这个距离的大小为左侧盒子的宽度以及两个盒子之间的距离之和。然后将该值设置为右侧盒子的margin-left。 缺点： 需要清除浮动 需要计算右侧盒子的margin-left 4.使用absolute+margin-left方法另外一种让两个block排列到一起的方法是对左侧盒子使用position: absolute的绝对定位。这样，右侧盒子也能无视掉它。 .wrapper-absolute .left { position: absolute; } .wrapper-absolute .right { margin-left: 150px; } 缺点: 使用了绝对定位，若是用在某个div中，需要更改父容器的position。 没有清除浮动的方法，若左侧盒子高于右侧盒子，就会超出父容器的高度。因此只能通过设置父容器的min-height来放置这种情况。 5.使用float+BFC方法上面的方法都需要通过左侧盒子的宽度，计算某个值，下面三种方法都是不需要计算的。只需要设置两个盒子之间的间隔。 .wrapper-float-bfc { overflow: auto; } .wrapper-float-bfc .left { float: left; margin-right: 20px; } .wrapper-float-bfc .right { margin-left: 0; overflow: auto; } 这个方案同样是利用了左侧浮动，但是右侧盒子通过overflow: auto;形成了BFC，因此右侧盒子不会与浮动的元素重叠。 这种情况下，只需要为左侧的浮动盒子设置margin-right，就可以实现两个盒子的距离了。而右侧盒子是block级别的，所以宽度能实现自适应。 缺点:父元素需要清除浮动 6.flex方案.wrapper-flex { display: flex; align-items: flex-start; } .wrapper-flex .left { flex: 0 0 auto; } .wrapper-flex .right { flex: 1 1 auto; } flex可以说是最好的方案了，代码少，使用简单。有朝一日，大家都改用现代浏览器，就可以使用了。 需要注意的是，flex容器的一个默认属性值:align-items: stretch;。这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start; 7.grid方案又一个新型的布局方式。可以满足需求，但这并不是它发挥用处的真正地方。 .wrapper-grid { display: grid; grid-template-columns: 120px 1fr; align-items: start; } .wrapper-grid .left, .wrapper-grid .right { box-sizing: border-box; } .wrapper-grid .left { grid-column: 1; } .wrapper-grid .right { grid-column: 2; } 注意: grid布局也有列等高的默认效果。需要设置: align-items: start;。 grid布局还有一个值得注意的小地方和flex不同:在使用margin-left的时候，grid布局默认是box-sizing设置的盒宽度之间的位置。而flex则是使用两个div的border或者padding外侧之间的距离。 极限情况最后可以再看一下在父容器极限小的情况下，不同方案的表现。主要分成四种情况： 动态计算宽度的情况两种方案: 双inline-block方案和双float方案。宽度极限小时，右侧的div宽度会非常小，由于遵循流动布局，所以右侧div会移动到下一行。 动态计算右侧margin-left的情况两种方案:float+margin-left方案和absolute+margin-left方案。宽度极限小时，由于右侧的div忽略了文档流中左侧div的存在，所以其依旧会存在于这一行，并被隐藏。 float+BFC方案的情况这种情况下，由于BFC与float的特殊关系，右侧div在宽度减小到最小后，也会掉落到下一行。 flex和grid的情况这种情况下，默认两种布局方式都不会放不下的div移动到下一行。不过 flex布局可以通过 flex-flow: wrap;来设置多余的div移动到下一行。 grid布局暂不支持。如果感觉写的有问题，恳请指出。 详情参考：https://segmentfault.com/a/1190000010698609","path":"2019/09/06/七种实现左侧固定，右侧自适应两栏布局的方法/"},{"title":"跨域常用解决方案","text":"同源与同源策略我们知道，同源指的是协议、域名、端口号全部相同。同源策略（Same Origin Policy）是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能都可能会受到影响。浏览器引入同源策略主要是为了防止XSS，CSRF攻击。Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略是处于对用户安全的考量的，如果缺少了同源的限制，那又怎么能够确定别人的网站始终对你是友好的呢。 针对非同源的情况制定了一些限制条件: 无法读取不同源的cookie、LocalStorage、indexDB。 无法获得不同源的DOM。 不能向不同源的服务器发送Ajax请求。 在浏览器中，script、img、iframe、link等标签都可以跨域加载资源，而不受同源策略的限制。事实上，在大多数情境下，我们经常是需要借用非同源来提供数据的，所以这就要用到跨域方面的技术了。 跨域解决方案1.JSONPJSONP是指JSON Padding，JSONP是一种非官方跨域数据交换协议，由于script的src属性可以跨域请求，所以JSONP利用的就是浏览器的这个原理，需要通信时，动态插入一个javascript标签。请求的地址一般带有一个callback参数，假设需要请求的地址为 http://localhost:3000?callback=show， 服务器返回的代码一般是show()的JSON数据，而show函数恰恰是前端需要用的这个数据的函数。JSONP非常简单易用，自动补全API利用的就是JSONP。 一个简单的例子：当远程数据一返回的时候，随着动态脚本的执行，这个handleResponse函数就会被执行。 var script = doxument.createElement(&quot;script&quot;); script.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;); script.src=&quot;http://example.com/ip?callback=handleResponse&quot;; document.body.appendChild(script); function handleResponse(data) { console.log(&apos;Your public IP address is: &apos;+data.ip); } JSONP解决跨域的本质：script标签可以请求不同域名下的资源，即script请求不受浏览器同源策略的影响。上例中的script会向http://example.com/ 服务器发送请求，这个请求的url后面带了个callback参数，是用来告诉服务器回调方法的方法名的。因为服务器收到请求后，会把相应的数据写进handleResponse的参数，也就是服务器会返回如下的脚本： handleResponse({ &quot;ip&quot; : &quot;8.8.8.8&quot; }); 这样浏览器通过script标签下载的资源就是上面的脚本了，script标签下载完就会立即执行，也就是说http://example.com/ip?callback=handleResponse 这个请求返回后就会立即执行上面的脚本代码，而这个脚本代码就是调用回调方法和拿到json数据了。 缺点： 只能发送get请求，无法发送post请求 无法判断请求成功还是失败 2.跨域源资源共享（CORS） CORS是W3C制定的跨站资源分享标准，可以让AJAX实现跨域访问，定义了在必须访问跨域资源时浏览器与服务器该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应应该成功还是失败。 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。 比如一个简单的使用GET或POST的请求，它没有自定义的头部，而主体内容是text/plain。在发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名、端口号），以便服务器根据该头部信息来决定是否给予响应。 Origin: http://www.example.com 如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中发回相同的源信息（如果是公共资源，可以发“*”）。例如： Access-Control-Allow-Origin: http://www.example.com 如果没有这个头部信息或信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。此时，请求和响应都不包含Cookie信息。 HTTP响应首部字段Access-Control-Allow-Origin: &lt;origin&gt; | * Access-Control-Expose-Headers: 头让服务器把允许浏览器访问的头放入白名单 Access-Control-Max-Age: 头指定了preflight请求的结果能够被缓存多久 Access-Control-Allow-Credentials: 头指定了当浏览器的credentials设置为true时是否允许浏览器读sponse的内容。 Access-Control-Allow-Methods: 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。 Access-Control-Allow-Headers: 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段 3.document.domain实现跨域此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 （1）父窗口：(http://www.domain.com/a.html) &lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = &apos;domain.com&apos;; var user = &apos;admin&apos;; &lt;/script&gt; （2）子窗口：(http://child.domain.com/b.html) &lt;script&gt; document.domain = &apos;domain.com&apos;; // 获取父窗口中变量 alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user); &lt;/script&gt; 4.window.postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递用法： postMessage(data,origin)方法接受两个参数 data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。 origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 使用方法如下：（1）a.html：(http://www.domain1.com/a.html) &lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); iframe.onload = function() { var data = { name: &apos;aym&apos; }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;); }; // 接受domain2返回数据 window.addEventListener(&apos;message&apos;, function(e) { alert(&apos;data from domain2 ---&gt; &apos; + e.data); }, false); &lt;/script&gt; （2）b.html：(http://www.domain2.com/b.html) &lt;script&gt; // 接收domain1的数据 window.addEventListener(&apos;message&apos;, function(e) { alert(&apos;data from domain1 ---&gt; &apos; + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;); } }, false); &lt;/script&gt; 5.window.name实现跨域window.name 传输技术的基本原理：当在浏览器中打开一个页面，或者在页面中添加一个iframe时即会创建一个对应的window对象，当页面加载另一个新的页面时，window.name的属性是不会变的。这样就可以利用在页面动态添加一个iframe然后加载数据页面，在数据页面将需要的数据赋值给window.name。然而此时承载的iframe的parent页面还是不能直接访问不在同一域下的iframe的那么属性，这时，只需要将iframe再加载一个与承载页面同域的空白页面，即可对window.name进行数据读取。通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 具体实现：http://www.domain1.com/a.html 主页面http://http://www.domain2.com/b.html 数据页面http://www.domain1.com/proxy.html 代理页面 a.html：(http://www.domain1.com/a.html) &lt;script&gt; var proxy = function(url, callback) { var state = 0; var iframe = document.createElement(&apos;iframe&apos;); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(&apos;&apos;); iframe.contentWindow.close(); document.body.removeChild(iframe); } }; // 请求跨域b页面数据 proxy(&apos;http://www.domain2.com/b.html&apos;, function(data){ alert(data); }); &lt;/script&gt; proxy.html：(http://www.domain1.com/proxy....中间代理页，与a.html同域，内容为空即可。 b.html：(http://www.domain2.com/b.html) &lt;script&gt; window.name = &apos;This is domain2 data!&apos;; &lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。","path":"2019/08/26/跨域常用解决方案/"},{"title":"js实现继承","text":"实现两个类 A 和 B, 且B类继承自A类，B类的实例可以调用A类的方法 1. 借用构造函数继承：用.call()和.apply()将父类构造函数引入子类函数；call() 方法：B.call(A, args1,args2);即A对象调用B对象的方法；apply() 方法：用作 this 的对象和要传递给函数的参数的数组 B.apply(A, arguments);即A对象应用B对象的方法 function A(propertyA){ this.propertyA=propertyA; this.fn1 = function(){ }; } function B(propertyB){ A.call(this,args1,args2);//A.apply(this,[]) this.propertyB = propertyB; } var b1 = new B(&quot;大毛&quot;); b.fn1(); 2. 原型链继承function A(propertyA){ this,propertyA = propertyA; this.fn = function(){} } function B(propertyB){ this.propertyB = propertyB; } B.prototype = new A(&quot;&quot;); var b1 = new B(&quot;&quot;); b1.fn(); 3. 混合方式：组合继承（组合原型链继承和借用构造函数继承）function A(propertyA){ this,propertyA = propertyA; this.fn = function(){} } function B(propertyB){ A.call(this,args1,args2);//A.apply(this,[]) this.propertyB = propertyB; } B.prototype = Object.create(A.prototype);//创建一个父类的原型对象，并返回这个新对象 B.prototype.constructor = B; var B=new B(&quot;张&quot;); b1.fn(); console.log(B instanceof A) //true 4. 对象冒充function A(){ this.name = &quot;name&quot;; this.sayName = function(){ console.log(this.name); } } function B(){ this.temp = A;//创建对象 this.temp();//调用方法 delete this.temp;//删除对象，以免覆盖父类 this.id = &quot;1&quot;; } var b = new B(); b.sayName();","path":"2019/08/24/js实现继承/"},{"title":"js如何判断数组是Array类型","text":"在说明如何判断一个对象为数组类型前，我们先巩固下js的数据类型，js一共有六大数据类型：number、string、object、Boolean、null、undefined。 var str=&quot;string&quot;; console.log(typeof str); //string var num=1; console.log(typeof num); //number var bn=false; console.log(typeof bn); //boolean var a; console.log(typeof a); //undfined var obj = null; console.log(typeof obj); //object var doc = document; console.log(typeof doc);//object var arr = []; console.log(arr); //object var fn = function(){}; console.log(typeof fn); //function 除了前四个类型外，null、对象、数组返回的都是object类型；对于函数类型返回的则是function，再比如typeof(Date)，typeof(eval)等。 接下来进入正题，js判断数组类型的方法。 方法一： 使用instanceof方法instanceof 用于判断一个变量是否某个对象的实例，左边操作数是一个对象，右边操作数是一个函数对象或者函数构造器。原理是通过判断左操作数的对象的原型链上是否具有右操作数的构造函数的prototype属性。 a instanceof b?alert(&quot;true&quot;):alert(&quot;false&quot;) //注意b值是你想要判断的那种数据类型，不是一个字符串，比如Array。 举一个例子： var arr=[]; console.log(arr instanceof Array) //返回true 方法二： 使用constructor方法在W3C定义中的定义：constructor 属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数。从定义上来说跟instanceof不太一致，但效果都是一样的。那么判断各种类型的方法： console.log([].constructor == Array); //true console.log({}.constructor == Object); //true console.log(&quot;string&quot;.constructor == String); //true console.log((123).constructor == Number); //true console.log(true.constructor == Boolean); //true 注意：使用instaceof和construcor,被判断的array必须是在当前页面声明的！比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量，Array ==object.constructor;会返回false；原因：1、array属于引用型数据，在传递过程中，仅仅是引用地址的传递。2、每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array。 方法三： 使用Object.prototype.toString.call(arr) === ‘[object Array]’方法function isArray(o) { return Object.prototype.toString.call(o); } var arr=[2,5,6,8]; var obj={name:&apos;zhangsan&apos;,age:25}; var fn = function () {} console.log(isArray(arr)); //[object Array] console.log(isArray(obj)); //[object Object] console.log(isArray(fn)); //[object function] 方法四：ES5定义了Array.isArrayArray.isArray([]) //true","path":"2019/08/23/js如何判断数组是Array类型/"},{"title":"js字符串操作","text":"ES5String.fromCharCode()该方法的参数是一系列Unicode码点，返回对应的字符串 charAt()该方法返回指定位置的字符，参数是从0开始编号的位置 str.charAt(index) index 为必须参数，类型为number（0到str.length-1之间，否则该方法返回 空串）另外：str.charAt()即不带参数和str.charAt(NaN)均返回字符串的第一个字符 charCodeAt()方法返回给定位置字符的Unicode码点（十进制表示），相当于String.fromCharCode()的逆操作 str.charCodeAt(index) index 为必须参数，类型为number（0到str.length-1之间，否则该方法返回 NaN） concat()方法用于连接两个字符串，返回一个新字符串，不改变原字符串 var a = &quot;hello&quot;,b = &quot;kitty&quot;,c = &quot;!&quot;;a.concat(b,c) // 功能和 “+” 拼接没啥两样 slice()方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置） str.slice(startIndex,endIndex) 返回值包含startIndex不包含endIndex忽略endIndex则返回包括startIndex到原字符串结尾的字符串另外参数还有负数反向用法 substring()方法用于从原字符串取出子字符串并返回，不改变原字符串。它与slice作用相同，但有一些奇怪的规则，因此不建议使用这个方法，优先使用slice。此方法的第一个参数表示子字符串的开始位置，第二个位置表示结束位置。 str.substring(startIndex,endIndex) 忽略endIndex则返回从startIndex到字符串尾字符 substr()方法用于从原字符串取出子字符串并返回，不改变原字符串。此方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。 str.substr(startIndex,length) 忽略length则返回从startIndex到字符串尾字符 indexOf()，lastIndexOf()这两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回-1，就表示不匹配。两者的区别在于，indexOf从字符串头部开始匹配，lastIndexOf从尾部开始匹配。 str.indexOf(searchStr,startIndex) searchStr必选，表示需要匹配的字符串值；startIndex可选，取值范围0到str.length-1，省略则默认首字符开始检索。 trim()方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。 toLowerCase(),toUpperCase()它们都返回一个新字符串，不改变原字符串。toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。 localeCompare()方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 match()方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 search()方法的用法等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 str.search(regexp/substr) 返回值：str中第一个与正则或字符串相匹配的子串的起始位置。 说明 search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。 replace()方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 split()方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。 str.split() ES6字符的 Unicode 表示法codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。 字符串的遍历器接口ES6 为字符串添加了遍历器接口（Iterator），使得字符串可以被for…of循环遍历。 at()ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。 normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。 一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。 includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。repeat()方法返回一个新字符串，表示将原字符串重复n次。 padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 模板字符串模板编译标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 String.raw()方法往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。","path":"2019/08/19/js字符串操作/"},{"title":"js数组操作","text":"传统的js数组方法: concat(),push(),pop(),shift(),unshift(),splice(),slice(),join(),sort(),reverse(); ES5新增数组方法: indexOf(),lastIndexOf(),map(),filter(),forEach(),some(),every(),reduce(),reduceRight(); Array.map()此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组 let arr = [1, 2, 3, 4, 5] let newArr = arr.map(x =&gt; x*2) //arr= [1, 2, 3, 4, 5] 原数组保持不变 //newArr = [2, 4, 6, 8, 10] 返回新数组 Array.forEach()此方法是将数组中的每个元素执行传进提供的函数，没有返回值，直接改变原数组，注意和map方法区分 let arr = [1, 2, 3, 4, 5] num.forEach(x =&gt; x*2) // arr = [2, 4, 6, 8, 10] 数组改变,注意和map区分 Array.filter()此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回 let arr = [1, 2, 3, 4, 5] const isBigEnough =&gt; value =&gt; value &gt;= 3 let newArr = arr.filter(isBigEnough ) //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组 Array.every()此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回true，否则为false： let arr = [1, 2, 3, 4, 5] const isLessThan4 =&gt; value =&gt; value &lt; 4 const isLessThan6 =&gt; value =&gt; value &lt; 6 arr.every(isLessThan4 ) //false arr.every(isLessThan6 ) //true Array.some()此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false： let arr= [1, 2, 3, 4, 5] const isLessThan4 =&gt; value =&gt; value &lt; 4 const isLessThan6 =&gt; value =&gt; value &gt; 6 arr.some(isLessThan4 ) //true arr.some(isLessThan6 ) //false Array.reduce()此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型： let arr = [1, 2, 3, 4, 5] const add = (a, b) =&gt; a + b let sum = arr.reduce(add) //sum = 15 相当于累加的效果 与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的 Array.push()此方法是在数组的后面添加新加元素，此方法改变了数组的长度： let arr = [1, 2, 3, 4, 5] arr.push(6) console.log(arr) //[1, 2, 3, 4, 5, 6] console.log(arr.length) //6 Array.pop()此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度： let arr = [1, 2, 3, 4, 5] arr.pop() console.log(arr) //[1, 2, 3, 4] console.log(arr.length) //4 Array.shift()此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度： let arr = [1, 2, 3, 4, 5] arr.shift() console.log(arr) //[2, 3, 4, 5] console.log(arr.length) //4 Array.unshift()此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度： let arr = [1, 2, 3, 4, 5] arr.unshift(6, 7) console.log(arr) //[6, 7, 1, 2, 3, 4, 5] console.log(arr.length) //7 Array.isArray()判断一个对象是不是数组，返回的是布尔值 let arr = [1, 2, 3] console.log(arr.isArray()) //true Array.concat()此方法是一个可以将多个数组拼接成一个数组： let arr1 = [1, 2, 3] arr2 = [4, 5] let arr = arr1.concat(arr2) console.log(arr)//[1, 2, 3, 4, 5] Array.toString()此方法将数组转化为字符串： let arr = [1, 2, 3, 4, 5]; let str = arr.toString() console.log(str)// 1,2,3,4,5 Array.join()此方法也是将数组转化为字符串： let arr = [1, 2, 3, 4, 5]; let str1 = arr.join() let str2 = arr.join(&apos;,&apos;) let str3 = arr.join(&apos;##&apos;) console.log(str1)// 12345 console.log(str2)// 1,2,3,4,5 console.log(str3)// 1##2##3##4##5 通过例子可以看出和toString的区别，可以设置元素之间的间隔~ Array.splice(开始位置， 删除的个数，元素)万能方法，可以实现增删改： let arr = [1, 2, 3, 4, 5]; let arr1 = arr.splice(2, 0 &apos;haha&apos;) let arr2 = arr.splice(2, 3) let arr1 = arr.splice(2, 1 &apos;haha&apos;) console.log(arr1) //[1, 2, &apos;haha&apos;, 3, 4, 5]新增一个元素 console.log(arr2) //[1, 2] 删除三个元素 console.log(arr3) //[1, 2, &apos;haha&apos;, 4, 5] 替换一个元素","path":"2019/08/19/js数组操作/"},{"title":"二叉树的前序遍历、中序遍历和后序遍历","text":"1、概念树是一种非顺序数据结构（节点，根节点，内部节点，外部节点，子树，深度） 节点包括（key left right） 二叉搜索树是二叉树的一种，左节点key值&lt;父节点key值，右节点key值&gt;=父节点key值 （1）前序遍历 a、访问根节点；b、前序遍历左子树；c、前序遍历右子树。 （2）中序遍历 a、中序遍历左子树；b、访问根节点；c、中序遍历右子树。 （3）后序遍历 a、后序遍历左子树；b、后续遍历右子树；c、访问根节点。 2、前序遍历和中序遍历还原二叉树思想如下： a、根据前序遍历结果，第一个元素为二叉树的根结点； b、观察中序遍历结果，根结点左侧的为左子树，若左子树根结点前（后）再无任何元素，则左（右）子树的左分支为空；根结点右侧的为右子树，若右子树根结点前（后）再无任何元素，则左（右）子树的左分支为空； c、上面的过程是递归的。先找到当前树的根结点，然后划分为左右子树，再进入左子树重复上面的过程，最后进入右子树重复上面的过程，最终还原一棵树。 例：已知前序遍历：ABDHIEJKCFLMGNO中序遍历：HDIBJEKALFMCNGO 按照上述步骤先画出二叉树，然后在进行求解后序遍历结果。结果为：HIDJKEBLMFNOGCA 练习： 1、前序遍历：GDAFEMHZ 中序遍历：ADEFGHMZ 求得后序遍历结果为：AEFDHZMG 2序遍历：ADCEFGHB 中序遍历：CDFEGHAB 求得后序遍历结果为：CFHGEDBA 3、中序遍历和后序遍历还原二叉树思想如下： a、根据后序遍历结果，最后一个元素为二叉树的根结点； b、观察中序遍历结果，其中根结点左侧为左子树，若左子树根结点前（后）再无任何元素，则左（右）子树的左分支为空；其中根结点右侧为右子树，若右子树根结点前（后）再无任何元素，则左（右）子树的左分支为空； c、上面的过程是递归的。先根据后序遍历结果找根结点，根结点左侧为左子树，右侧为右子树，再进入左子树重复上面的过程，最后进入右子树重复上面的过程，最终还原一棵树。 例：已知中序遍历：HDIBJEKALFMCNGO后序遍历：HIDJKEBLMFNOGCA 按照上述步骤先画出二叉树，然后在进行求解前序遍历结果。结果为：ABDHIEJKCFLMGNO 4、前序遍历和后序遍历还原二叉树已知前序和中序，后序和中序遍历序列之后，可以唯一确定一棵二叉树。但是，只知道前序和后序遍历序列，是无法知道哪个结点是左子树还算右子树。 5.js实现二叉树的先序、中序、后序遍历方法四种遍历的主要思想：前序遍历：根左右;中序遍历：左根右;后序遍历：左右根;广度遍历：按照层次一层层遍历; // 创建一个树节点 function Node(key){ this.key = key; this.left = null; this.right = null; } // 创建树的类 function treeList(){ this.root = new Node(&apos;root&apos;); // 根节点 this.insertNode = insertNode; // 插入节点 this.findNode = findNode; // 查找节点 this.removeNode = removeNode; // 删除节点 this.findMaxNode = findMaxNode; // 这棵树中的最小值在最后一层最左侧的节点 this.findMinNode = findMinNode; // 最大值在最右端的节点。 //先序遍历 主左右 先序遍历的一种应用是打印一个结构化的文档。 this.preOrderTraverseNode = preOrderTraverseNode; // 中序遍历 左主右 是一种上行访问BST所有节点的遍历方式，也就是从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。 this.inOrderTraverseNode = inOrderTraverseNode; // 后序遍历 左右主 后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占用空间的大小。 this.postOrderTraverseNode = postOrderTraverseNode; } function insertNode(node, root){ if (root === null){ root = node; }else{ if (node.key &lt; root.key){ if (root.left == null){ root.left = node }else { insertNode(node, root.left) } }else { if (root.right == null){ root.right = node }else { insertNode(node, root.right) } } } } function findNode(node, key){ if (node == null){ return false }else { if (key &lt; node.key){ return findNode(node.left, key) }else if(key &gt; node.key) { return findNode(node.right, key) }else{ return true } } } function findMaxNode(node){ if (node){ while(node &amp;&amp; node.right !== null){ node = node.right } return node.key }else{ return null } } function findMinNode(node){ if (node){ while(node &amp;&amp; node.left !== null){ node = node.left } return node }else{ return null } } // 三种情况：删除节点没有子节点，删除节点有一个子节点，删除节点有两个子节点，从node来删除 function removeNode(node, key){ if (node === null){ return null; } if (key &lt; node.key){ node.left = removeNode(node.left, key) return node }else if (key &gt; node.key){ node.right = removeNode(node.right, key) return node } else { // 找到删除的节点，删除，分三种情况 // case1 删除节点没有子节点 if (node.left === null &amp;&amp; node.right === null){ node = null; return node; } //case 2 删除节点有一个子节点 if (node.left === null){ node = node.right; return node; } else if (node.right === null){ node = node.left; return node; } //case 3 删除节点有两个子节点，最复杂，用该右子树的最小节点aux的值代替删除节点值de，并删除aux var aux = findMinNode(node.right);// findMinNode返回的是节点 node.key = aux.key; node.right = removeNode(node.right, aux.key); return node; } } // 回调函数用来定义我们对遍历到的每个节点进行操作 // 先序中左右 function preOrderTraverseNode(node, callback){ if (node !== null) { callback(node.key) preOrderTraverseNode(node.left, callback) preOrderTraverseNode(node.right, callback) } } // 中序遍历左中右 function inOrderTraverseNode(node, callback){ if (node !== null) { inOrderTraverseNode(node.left, callback); callback(node.key) inOrderTraverseNode(node.right, callback) } } // 后序遍历左右中 function postOrderTraverseNode(node, callback){ if (node !== null) { postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback) callback(node.key) } } 用例测试，树用object来表示 // 普通二叉树 let obj = { key: 10, left: { key: 11, left: { key: 21, left: { key: 31, left: null, right: null }, right: { key: 32, left: null, right: null } }, right: { key: 22, left: null, right: null } }, right: { key: 12, left: { key: 23, left: null, right: null }, right: { key: 24, left: null, right: null } } } // 搜索二叉树 let treeObj = { key: 14, left: { key: 12, left: { key: 9, left: { key: 6, left: null, right: null }, right: null }, right: { key: 13, left: null, right: null } }, right: { key: 16, left: { key: 10, left: null, right: null }, right: { key: 20, left: {key: 18, left: null, right: null}, right: {key: 21, left: null, right: null} } } } var tree = new treeList(); // tree.preOrderTraverseNode(obj, console.log) // tree.inOrderTraverseNode(obj, console.log) // tree.postOrderTraverseNode(obj, console.log) // console.log(tree.findMinNode(treeObj)) // 6 // console.log(tree.findNode(treeObj, 6)) // true var node = new Node(30) // tree.insertNode(node, treeObj) // tree.inOrderTraverseNode(treeObj, console.log) tree.removeNode(treeObj, 20) tree.inOrderTraverseNode(treeObj, console.log) // console.log(treeObj) 详情参考：https://www.jianshu.com/p/3f3fed4b1b69https://www.jb51.net/article/126850.htm","path":"2019/08/19/二叉树的前序遍历、中序遍历和后序遍历之间还原二叉树/"},{"title":"HTML5语义化标签的理解","text":"语义化标签的好处要从HTML 全局属性说起，即有的标签有默认的HTML全局属性，所以最好用语义化标签。引入语义化标签的好处主要有下列三点： 比div标签有更加丰富的含义，方便开发与维护 搜索引擎能更方便的识别页面的每个部分 方便其他设备解析（如移动设备、盲人阅读器等） 1：以下元素支持 tabindex 属性： &lt;a&gt;, &lt;area&gt;, &lt;button&gt;, &lt;input&gt;, &lt;object&gt;, &lt;select&gt; 以及 &lt;textarea&gt;。 用法：number规定元素的 tab 键控制次序（1 是第一个）。作用：增强用户键盘的可操作性，所以不要用div代替2：以下元素支持 accesskey 属性： &lt;a&gt;, &lt;area&gt;, &lt;button&gt;, &lt;input&gt;, &lt;label&gt;, &lt;legend&gt; 以及 &lt;textarea&gt;。 用法：character规定激活（使元素获得焦点）元素的便捷按键。作用：增强用户键盘的可操作性，所以不要用div代替3：contextmenu 属性的值是要打开的 menu 元素的 id。目前只有火狐支持 4：spellcheck 属性规定是否对元素进行拼写和语法检查。可以对以下内容进行拼写检查： input 元素中的文本值（非密码） &lt;textarea&gt; 元素中的文本 可编辑元素中的文本 5：lang 属性在以下标签中无效： &lt;base&gt;, &lt;br&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;hr&gt;, &lt;iframe&gt;, &lt;param&gt; 以及 &lt;script&gt;。 对外的意义：有利于SEO的！！有利于解析代码！！可读性可维护性增强！！ 1：定义上的： &lt;!--...--&gt; 定义注释。 &lt;!DOCTYPE&gt; 定义文档类型。 &lt;html&gt; 定义 HTML 文档。 &lt;body&gt; 定义文档的主体。 &lt;script&gt; 定义客户端脚本。 &lt;frame&gt; 定义框架集的窗口或框架。 &lt;frameset&gt; 定义框架集。 &lt;head&gt; 定义关于文档的信息。 &lt;iframe&gt; 定义内联框架。 &lt;meta&gt; 定义关于 HTML 文档的元信息。 &lt;link&gt; 定义文档与外部资源的关系。 &lt;noframes&gt; 定义针对不支持框架的用户的替代内容。 &lt;noscript&gt; 定义针对不支持客户端脚本的用户的替代内容。 2：功能上的（js或者css上的作用比较有特色的语义化标签）： &lt;a&gt; 定义锚。 &lt;abbr&gt; 定义缩写。 &lt;address&gt; 定义文档作者或拥有者的联系信息。 &lt;area&gt; 定义图像映射内部的区域。 &lt;audio&gt; 定义声音内容。 &lt;base&gt; 定义页面中所有链接的默认地址或默认目标。 &lt;br&gt; 定义简单的折行。 &lt;button&gt; 定义按钮 (push button)。 &lt;col&gt; 定义表格中一个或多个列的属性值。 &lt;colgroup&gt; 定义表格中供格式化的列组。 &lt;dfn&gt; 定义一个定义项目。 &lt;code&gt; 定义计算机代码文本。 &lt;samp&gt; 定义样本文本。 &lt;kbd&gt; 定义键盘文本。它表示文本是从键盘上键入的。它经常用在与计算机相关的文档或手册中。 &lt;var&gt; 定义变量。您可以将此标签与 &lt;pre&gt; 及 &lt;code&gt; 标签配合使用。 &lt;cite&gt; 定义引用。可使用该标签对参考文献的引用进行定义，比如书籍或杂志的标题。 &lt;datalist&gt; 定义下拉列表。 &lt;wbr&gt; 定义长单词在哪里换号；元素来添加 Word Break Opportunity（单词换行时机） &lt;video&gt; 定义视频。 &lt;track&gt; 标签为诸如 video 元素之类的媒介规定外部文本轨道。 &lt;title&gt; 定义文档的标题。 &lt;time&gt; 定义日期/时间。 &lt;textarea&gt; 定义多行的文本输入控件。 &lt;strong&gt; 定义强调文本。 &lt;style&gt; 定义文档的样式信息。 &lt;sub&gt; 定义下标文本。 &lt;summary&gt; 有关文档的详细信息 &lt;details&gt; 元素定义可见的标题。 &lt;sup&gt; 定义上标文本。 &lt;source&gt; 定义媒介源。 &lt;samp&gt; 定义计算机代码样本。 &lt;section&gt; 定义 section。 &lt;select&gt; 定义选择列表（下拉列表）。 &lt;rt&gt; 定义 ruby 注释的解释。 &lt;ruby&gt; 定义 ruby 注释。 &lt;q&gt; 定义短的引用。 &lt;progress&gt; 定义任何类型的任务的进度。 &lt;param&gt; 定义对象的参数。 &lt;pre&gt; 定义预格式文本。 &lt;optgroup&gt; 定义选择列表中相关选项的组合。 &lt;option&gt; 定义选择列表中的选项。 &lt;output&gt; 定义输出的一些类型。 &lt;details&gt; 定义元素的细节。 &lt;dir&gt; 不赞成使用。定义目录列表。 &lt;div&gt; 定义文档中的节。 &lt;dfn&gt; 定义定义项目。 &lt;dialog&gt; 定义对话框或窗口。 &lt;dl&gt; 定义定义列表。 &lt;dt&gt; 定义定义列表中的项目。 &lt;embed&gt; 定义外部交互内容或插件。 &lt;fieldset&gt; 定义围绕表单中元素的边框。 &lt;figcaption&gt; 定义 figure 元素的标题。 &lt;figure&gt; 定义媒介内容的分组，以及它们的标题。 &lt;form&gt; 定义供用户输入的 HTML 表单。 &lt;hr&gt; 定义水平线。 &lt;img&gt; 定义图像。 &lt;input&gt; 定义输入控件。 &lt;ins&gt; 定义被插入文本。 &lt;kbd&gt; 定义键盘文本。 &lt;keygen&gt; 定义生成密钥。 &lt;label&gt; 定义 input 元素的标注。 &lt;legend&gt; 定义 fieldset 元素的标题。 &lt;map&gt; 定义图像映射。 &lt;mark&gt; 定义有记号的文本。 &lt;menu&gt; 定义命令的列表或菜单。 &lt;menuitem&gt; 定义用户可以从弹出菜单调用的命令/菜单项目。 &lt;meter&gt; 定义预定义范围内的度量。 &lt;nav&gt; 定义导航链接。 &lt;object&gt; 定义内嵌对象。 3：结构上的（方便分块查看，这个很重要）：结构上的可以被其他div+css代替但是好的前端会用这些标签来使代码可读性增强。 &lt;header&gt; 定义 section 或 page 的页眉。 &lt;dd&gt; 定义定义列表中项目的描述。 &lt;article&gt; 定义文章。 &lt;aside&gt; 定义页面内容之外的内容。尤其上面的四位主要用于划分页面块，一般不做样式处理 &lt;p&gt; 定义段落。 &lt;em&gt; 把文本定义为强调的内容。 &lt;strong&gt; 把文本定义为语气更强的强调的内容。 &lt;bdo&gt; 定义文字方向。 &lt;bdi&gt; 定义文本的文本方向，使其脱离其周围文本的方向设置，与bdo配合使用试试。 &lt;big&gt; 定义大号文本。 &lt;b&gt; 定义粗体字。 &lt;del&gt; 定义被删除文本。 &lt;ul&gt; 定义无序列表。 &lt;ol&gt; 定义有序列表。 &lt;table&gt; 定义表格。 &lt;tbody&gt; 定义表格中的主体内容。 &lt;td&gt; 定义表格中的单元。 &lt;tfoot&gt; 定义表格中的表注内容（脚注）。 &lt;th&gt; 定义表格中的表头单元格。 &lt;thead&gt; 定义表格中的表头内容。 &lt;tr&gt; 定义表格中的行。 &lt;footer&gt; 定义 section 或 page 的页脚。 &lt;h1&gt; to &lt;h6&gt; 定义 HTML 标题。 &lt;i&gt; 定义斜体字。 &lt;li&gt; 定义列表的项目。","path":"2019/08/18/HTML5语义化标签的理解/"},{"title":"算法编程题","text":"本文总结了很多简单的算法编程： 降维 排序 去重 统计一个字符串出现最多的字母 不借助临时变量，进行两个整数的交换 找出下列正数组的最大差值 随机生成指定长度的字符串 实现类似getElementsByClassName 的功能 判断一个单词是否是回文？ 找出最长单词 string 里的每个单词首字母大写 判断字符串是否是指定字符结尾 重复字符串指定次数 找出字符串中出现最多的字符和个数 创建一个函数判断给定的表达式中的小括号是否闭合 在字符串中找出连续最长的数字串 使用canvas 绘制一个有限度的斐波那契数列的曲线？ 实现阶乘 过滤敏感词 二分查找 App版本比较 生成菲波那切数列 使用JS 实现二叉查找树(Binary Search Tree) 密码强度判断 修改路由规则 字符串大小写转换 跟着我一起学习吧~ js降维//迭代降维 function jiangwei(arr){ var newarr = [] arr.forEach(item=&gt;{ if(item instanceof Array){ newarr.push(...jiangwei(item)) } else{ newarr.push(item) } }) return newarr } console.log(jiangwei( [3, [&apos;a&apos;, [0,[&apos;a&apos;,1], 1], null], [4, &apos;4j&apos;, [3]], -2])) //用apply的特性，将数组作为参数展开传入新的空数组[]，再contact var arr=[[1,2,3],[&quot;sy&quot;,1,&quot;jh&quot;,null],[&quot;&quot;,9],1] function jiangwei(arr){ var newarr=[] newarr=newarr.concat.apply(newarr,arr) return newarr } //使用ES6特性-扩展运算符将数组展开 function jiangwei(arr){ var newarr=[] newarr=[].concat(...arr) return newarr } console.log(jiangwei(arr)) //多维数组变成一维数组 //es6新增的flat方法 var arr = [3, [&apos;a&apos;, [0, 1], null], [4, &apos;4j&apos;, [3]], -2] function jiangwei(arr){ var newarr=[] //数字参数指定降维次数 newarr=arr.flat(3) return newarr } console.log(jiangwei(arr)) js排序//一、冒泡排序，相邻元素比较交换 //基本思路： //1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。 //2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 //3.针对所有的元素重复以上的步骤，除了最后一个。 //4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 var arr=[9,-2,1,30,-59] function paixu(arr){ for(var i=0; i&lt;arr.length-1; i++){ for(var j=0; j&lt;arr.length-1-i; j++){ if (arr[j]&gt;arr[j+1]){ var temp=arr[j] arr[j]=arr[j+1] arr[j+1]=temp } } } return arr } console.log(paixu(arr)) //二、快速排序 //基本思路： //1.以一个数为基准(中间的数)，比基准小的放到左边，比基准大的放到右边 //2.再按此方法对这两部分数据分别进行快速排序（递归进行） //3.不能再分后退出递归，并重新将数组合并 function quickSort(arr) { if (arr.length &lt;= 1) { return arr; } let leftArr = []; let rightArr = []; let q = arr[0]; for (let i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; q) { rightArr.push(arr[i]); } else { leftArr.push(arr[i]); } } return [].concat(quickSort(leftArr), [q], quickSort(rightArr)); } console.log(quickSort(arr));//[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;] js去重var arr = [&apos;1&apos;,&apos;hello&apos;,&apos;ree&apos;,&apos;ke&apos;,&apos;yi&apos;,&apos;1&apos;,&apos;e&apos;,&apos;1&apos;] //ES6数组去重，无法去{}空对象 function quchong(arr){ return Array.from(new Set(arr)) } //splice去重，一个数据和后面所有数据比较，相同的删除 function quchong(arr){ for (var i=0; i&lt;arr.length; i++){ for (var j=i+1; j&lt;arr.length; j++){ if (arr[i]==arr[j]){ arr.splice(j,1) j-- } } } return arr } //使用indexOf去重，新建一个数组，把原数组的数据与新数组里的数据比较newarr.indexOf(arr[i])===-1，不存在就push进去，存在的就跳过 function quchong(arr){ var newarr=[] for (var i=0; i&lt;arr.length; i++){ if(newarr.indexOf(arr[i])===-1){ newarr.push(arr[i]) } } return newarr } //使用sort去重，先将数组排序，然后前后数据相比较，不存在就放入新的数组 function quchong(arr){ var newarr=[] arr= arr.sort() for (var i=0; i&lt;arr.length; i++){ if(arr[i]!==arr[i+1]){ newarr.push(arr[i]) } } return newarr } console.log(quchong(arr)) 统计一个字符串出现最多的字母给出一段英文连续的英文字符窜，找出重复出现次数最多的字母比如：输入：afjghdfraaaasdenas ;输出 ： a前面出现过去重的算法，这里需要是统计重复次数。利用Object中key的唯一性，利用key来进行筛选，然后计数。 var string = &apos;afjghdfraaaasdenas&apos; function findMaxDuplicateChar(str) { if(str.length == 1) { return str; } let charObj = {}; for(let i=0;i&lt;str.length;i++) { if(!charObj[str.charAt(i)]) { charObj[str.charAt(i)] = 1; }else{ charObj[str.charAt(i)] += 1; } } let maxChar = &apos;&apos;, maxValue = 1; for(var k in charObj) { if(charObj[k] &gt;= maxValue) { maxChar = k; maxValue = charObj[k]; } } return maxChar; } console.log(findMaxDuplicateChar(string)) 不借助临时变量，进行两个整数的交换 举例：输入 a = 2, b = 4 输出 a = 4, b =2 这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b进行置换。 主要是利用 + - 去进行运算，类似 a = a + ( b - a) 实际上等同于最后 的 a = b; var a = 2 var b = 4 function swap(a , b) { b = b - a; a = a + b; b = a - b; return [a,b]; } console.log(swap(a,b)) 找出下列正数组的最大差值比如：输入 [10,5,11,7,8,9] ;输出 6这是通过一道题目去测试对于基本的数组的最大值的查找，很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。 function getMaxProfit(arr) { var minPrice = arr[0]; var maxProfit = 0; for (var i = 0; i &lt; arr.length; i++) { var currentPrice = arr[i]; minPrice = Math.min(minPrice, currentPrice); var potentialProfit = currentPrice - minPrice; maxProfit = Math.max(maxProfit, potentialProfit); } return maxProfit; } function getMaxProfit(arr){ var min = arr[0] var max = arr[0] var value = 0 arr.map(item=&gt;{ if(item &lt; min){ min = item } else if (item &gt; max){ max = item } value = Math.max(value, max-min) }) return value } console.log(getMaxProfit([8,10,1,3,6,2,9])) 随机生成指定长度的字符串实现一个算法，随机生成指指定长度的字符窜。比如：给定 长度 8 输出 4ldkfg9j function randomString(n) { let str = &apos;abcdefghijklmnopqrstuvwxyz9876543210&apos;; let tmp = &apos;&apos;, i = 0, l = str.length; for (i = 0; i &lt; n; i++) { tmp += str.charAt(Math.floor(Math.random() * l)); } return tmp; } console.log(randomString(8)) 实现类似getElementsByClassName 的功能 自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供DOM查找函数。 function queryClassName(node, name) { var starts = &apos;(^|[ \\n\\r\\t\\f])&apos;, ends = &apos;([ \\n\\r\\t\\f]|$)&apos;; var array = [], regex = new RegExp(starts + name + ends), elements = node.getElementsByTagName(&quot;*&quot;), length = elements.length, i = 0, element; while (i &lt; length) { element = elements[i]; if (regex.test(element.className)) { array.push(element); } i += 1; } return array; } 判断一个单词是否是回文？回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider很多人拿到这样的题目非常容易想到用for 将字符串颠倒字母顺序然后匹配就行了。其实重要的考察的就是对于reverse的实现。其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。 // 简易好理解的方法 var str = &apos;helloolleh&apos;; function checkPalindrom(str) { return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;); } console.log(checkPalindrom(str));//true // 复杂方法 function isPalindrome(str){ if (typeof str !== &apos;string&apos; || str.constructor !== String) { return false; } var len = parseInt((str.length+1)/2); for(var i=0; i&lt;len; i++){ if (str[i] !== str[str.length-i-1]) { return false; } } return true; } console.log(isPalindrome(&apos;adddddda&apos;));//true console.log(isPalindrome(&apos;addddda&apos;));//true console.log(isPalindrome(&apos;adddasd&apos;));//false 找出最长单词这个有很多种解决办法 我只是用了个蠢一点最早想到的方法Find the Longest Word in a String function findLongestWord(str) { // 请把你的代码写在这里 var new_str = str.split(&quot; &quot;); var arr = []; for(var i = 0;i&lt;new_str.length;i++){ arr.push(new_str[i].length); } return arr.sort(function(a,b){ return b-a; })[0]; } findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;); string 里的每个单词首字母大写Title Case a Sentence function titleCase(str) { return str.toLowerCase().split(&quot; &quot;).map((item)=&gt;{ return item.replace(item.charAt(0),item[0].toUpperCase()) }).join(&quot; &quot;) } titleCase(&quot;I&apos;m a little tea pot&quot;); 判断字符串是否是指定字符结尾这只是一种思路 我这个有点过去简单粗暴了 小伙伴们如果有更多答案 可以留言 探讨下 function confirmEnding(str, target) { return (str.substr(-target.length)==target) ? true:false; } confirmEnding(&quot;He has to give me a new name&quot;, &quot;name&quot;); 重复字符串指定次数这个折腾了一会儿 刚开始得保存一次 没想到Repeat a string repeat a string function repeat(str, num) { if(num&lt;=0) return &quot;&quot;; var save_ = str for(var i=1;i&lt;num;i++) str+=save_ ; return str; } repeat(&quot;abc&quot;, 3); 找出字符串中出现最多的字符和个数var string=&quot;sssfgtdfssddfsssfssss&quot;; function max(str){ var json={}; var num=0; var value=null; for(var i=0;i&lt;str.length;i++){ var k=str[i]; if(!json[k]){ json[k]=[]; } json[k].push(k); //这里不需要else，否则只有存在这个字符时才添加。次数会少一次 } for(var attr in json){ if(num&lt;json[attr].length){ num=json[attr].length; value=json[attr][0]; } } return value+&apos; &apos;+num; }; console.log(max(string)) 创建一个函数判断给定的表达式中的小括号是否闭合var expression = &quot;(())()()&quot; var expressionFalse = &quot;()(()&quot; function isBalanced(expression) { var checkString = expression; var stack = []; if (checkString.length &lt;= 0) return true; for (var i = 0; i &lt; checkString.length; i++) { if(checkString[i] === &apos;(&apos;) { stack.push(checkString[i]); } else if (checkString[i] === &apos;)&apos;) { // Pop on an empty array is undefined if (stack.length &gt; 0) { stack.pop(); } else { return false; } } } // If the array is not empty, it is not balanced if (stack.pop()) return false; return true; } console.log(isBalanced(expression)) 在字符串中找出连续最长的数字串var lines = &apos;abc360360xyz#123you&apos; function findTheNumString(str) { var reg = /\\d+/g var array = str.match(reg) var max = 0 for (var i = 0; i &lt; array.length; i++) { if (array[i].length &gt;= max) { max = array[i].length var j = i } } return array[j].length + &apos;/&apos; + array[j] } console.log(findTheNumString(lines)) 使用canvas 绘制一个有限度的斐波那契数列的曲线？数列长度限定在9.斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。我们一般都知道定义fibo[i] = fibo[i-1]+fibo[i-2]; 生成斐波那契数组的方法 function getFibonacci(n) { var fibarr = []; var i = 0; while(i&lt;n) { if(i&lt;=1) { fibarr.push(i); }else{ fibarr.push(fibarr[i-1] + fibarr[i-2]) } i++; } return fibarr; } 实现阶乘 非递归实现? function factorialize(num) { var result = 1; if(num &lt; 0) return -1; if(num == 0 || num == 1) return 1; while(num&gt;1) result *= num--; return result; } 递归实现 function factorialize(num) { if (num &lt; 0) { return -1; } else if (num === 0 || num === 1) { return 1; } else { return (num * factorialize(num - 1)); } } factorialize(5); 过滤敏感词function sensitive(content){ var keywords=[&quot;暴力&quot;, &quot;色情&quot;, &quot;fuck&quot;, &quot;TMD&quot;];//敏感词词库 var value = content;//获取需要过滤的内容 //遍历敏感词数组 for(var i=0;i&lt;keywords.length;i++){ var reg = new RegExp(keywords[i],&quot;g&quot;);//全局替换 //判断内容中是否包括敏感词 if(value.indexOf(keywords[i])!=-1){ var result = value.replace(reg,&quot;****&quot;); value = result; } } return value; } 二分查找二分查找又称折半查找，是在有序数组查找中用到的较为频繁的一种算法，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。 非递归实现 function binary_search(arr, key) { var low = 0, high = arr.length - 1; while(low &lt;= high){ var mid = parseInt((high + low) / 2); if(key == arr[mid]){ return mid; }else if(key &gt; arr[mid]){ low = mid + 1; }else if(key &lt; arr[mid]){ high = mid -1; } } return -1; }; 递归实现 function binary_search2(arr, low, high, key) { if(low &gt; high) return -1; var mid = parseInt((low + high)/2); if(key == arr[mid]) return mid; else if(key &gt; arr[mid]) return binary_search2(arr, mid+1, high, key); else if(key &lt; arr[mid]) return binary_search2(arr, low, mid-1, key); } App版本比较function Version(curV, reqV) { var arr1 = curV.toString().split(&apos;.&apos;); var arr2 = reqV.toString().split(&apos;.&apos;); //将两个版本号拆成数字 var minL = Math.min(arr1.length, arr2.length); var pos = 0; //当前比较位 var diff = 0; //当前为位比较是否相等 var flag = false; //逐个比较如果当前位相等则继续比较下一位 while(pos &lt; minL) { diff = parseInt(arr1[pos]) - parseInt(arr2[pos]); if(diff == 0) { pos++; continue; } else if(diff &gt; 0) { flag = true; break; } else { flag = false; break; } } if(flag){ return curV + &apos;,&apos; + reqV } else { return reqV + &apos;,&apos; + curV } } let test_v = Version(&apos;4.1.3&apos;,&apos;5.0.1&apos;) console.log(test_v ) 生成菲波那切数列斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。通过定义fibo[i] = fibo[i-1]+fibo[i-2];来生成斐波那契数组。 强行递归实现 function getfib(n){ if(n == 0) return 0; if(n == 1) return 1; if(n &gt; 1){ return getfib(n-1) + getfib(n-2); } } function fibo(len){ var fibo = []; for(var i=0;i&lt;len;i++) fibo.push(getfib(i)); return fibo; } 简约非递归版 function getFibonacci(n) { var fibarr = []; var i = 0; while(i &lt; n) { if(i &lt;= 1) { fibarr.push(i); } else { fibarr.push(fibarr[i - 1] + fibarr[i - 2]) } i++; } return fibarr; } 使用JS 实现二叉查找树(Binary Search Tree)一般叫全部写完的概率比较少，但是重点考察你对它的理解和一些基本特点的实现。 二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树： 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。在写的时候需要足够理解二叉搜素树的特点，需要先设定好每个节点的数据结构 class Node { constructor(data, left, right) { this.data = data; this.left = left; this.right = right; } } 树是有节点构成，由根节点逐渐延生到各个子节点，因此它具备基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法. class BinarySearchTree { constructor() { this.root = null; } insert(data) { let n = new Node(data, null, null); if (!this.root) { return this.root = n; } let currentNode = this.root; let parent = null; while (1) { parent = currentNode; if (data &lt; currentNode.data) { currentNode = currentNode.left; if (currentNode === null) { parent.left = n; break; } } else { currentNode = currentNode.right; if (currentNode === null) { parent.right = n; break; } } } } remove(data) { this.root = this.removeNode(this.root, data) } removeNode(node, data) { if (node == null) { return null; } if (data == node.data) { // no children node if (node.left == null &amp;&amp; node.right == null) { return null; } if (node.left == null) { return node.right; } if (node.right == null) { return node.left; } let getSmallest = function(node) { if(node.left === null &amp;&amp; node.right == null) { return node; } if(node.left != null) { return node.left; } if(node.right !== null) { return getSmallest(node.right); } } let temNode = getSmallest(node.right); node.data = temNode.data; node.right = this.removeNode(temNode.right,temNode.data); return node; } else if (data &lt; node.data) { node.left = this.removeNode(node.left,data); return node; } else { node.right = this.removeNode(node.right,data); return node; } } find(data) { var current = this.root; while (current != null) { if (data == current.data) { break; } if (data &lt; current.data) { current = current.left; } else { current = current.right } } return current.data; } } module.exports = BinarySearchTree; .ajaxhttps://www.runoob.com/ajax/ajax-examples.html function ajaxtest(){ var xmlhttp; if (window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); } else { // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)//0-4和200，404 { // responseText 获得字符串形式的响应数据。 // responseXML 获得 XML 形式的响应数据。 document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; } } /* 规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步）*/ xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true); /* 将请求发送到服务器。 string：仅用于 POST 请求 */ xmlhttp.send(); } 密码强度判断function checkPassWord(value){ var modes = 0; if(/\\d/.test(value)){//如果用户输入的密码 包含了数字 modes++; } if(/[a-z]/.test(value)){//如果用户输入的密码 包含了小写的a到z modes++; } if(/[A-Z]/.test(value)){//如果用户输入的密码 包含了大写的A到Z modes++; } if(/\\W/.test(value)){//如果是非数字 字母 下划线 modes++; } if(value.length &lt; 8 || modes == 1){//最初级别 return 0; } else { if(modes == 2){ if(/\\d/.test(value)&amp;&amp;/[a-z]/.test(value)){ return 1; } else if(/\\d/.test(value)&amp;&amp;/[A-Z]/.test(value)){ return 1; } else { return 2; } } else if(modes == 3){ return 3; } else if(modes == 4){ return 3; } } } console.log(checkPassWord(&apos;ssqk!!!!!!hk&apos;)) 修改路由规则var routes = [ { path:&quot;/home&quot;, content:&quot;home&quot;, children:[ { path:&quot;/hello&quot;, content:&quot;hello&quot; }, { path:&quot;/hello1&quot;, content:&quot;hello1&quot; } ] }, { path:&quot;/about&quot;, content:&quot;about&quot;, children:[{ path:&quot;/hello&quot;, content:&quot;hello&quot; }] } ] function getRoute(routes){ var obj=[]; routes.map(element =&gt; { var itempath1 = element.path; var itemcontent1 = element.content; var itemobj1 = { path: itempath1, content: itemcontent1 } obj.push(itemobj1); if(element.children){ element.children.map(item =&gt; { var itemcontent2 = []; var itempath2; itemcontent2.push(itemcontent1); itempath2 = element.path+item.path; itemcontent2.push(item.content) var itemobj2 = { path: itempath2, content: itemcontent2 } obj.push(itemobj2); }) } }); return obj } console.log(getRoute(routes)); 字符串大小写转换function change(str){ var arr = str.split(&apos;&apos;) var newarr = [] arr.map(item=&gt;{ if(/[a-z]/.test(item)){ newarr.push(item.toUpperCase()) } else if(/[A-Z]/.test(item)){ newarr.push(item.toLowerCase()) } }) return newarr.join(&apos;&apos;) } console.log(change(&apos;sSuFHJwil&apos;))","path":"2019/08/16/算法编程题/"},{"title":"面试宝典-Vue","text":"什么是MVVM？MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和Model的对象（桥梁）。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。区别：vue数据驱动，通过数据来显示视图层而不是节点操作。场景：数据操作比较多的场景，更加便捷 vue的优点是什么？ 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 组件之间的传值？ 父组件与子组件传值父组件通过标签上面定义传值 ：eg=’data’ 父组件中 data(){return {data:’egdata’}}子组件通过props方法接受数据 props:[‘eg’] 在 props 中添加了元素之后，就不需要在 data 中再添加变量了 子组件向父组件传递数据子组件通过$emit方法传递参数 子组件向子组件传递数据Vue 没有直接子对子传参的方法，建议将需要传递数据的子组件，都合并为一个组件。如果一定需要子对子传参，可以先从传到父组件，再传到子组件。为了便于开发，Vue 推出了一个状态管理工具 Vuex，可以很方便实现组件之间的参数传递 vuex是什么？怎么使用？哪种功能场景使用它？vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 vuex有哪几种属性？有五种，分别是 State、 Getter、Mutation 、Action、 Module vuex的State特性A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的dataB、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中 vuex的Getter特性A、getters 可以对State进行计算操作，它就是Store的计算属性B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用C、 如果一个状态只在一个组件内使用，是可以不用getters vuex的Mutation特性Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。 不用Vuex会带来什么问题？ 可维护性会下降，想修改数据要维护三个地方； 可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的； 增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。 vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？ 第一步：在components目录新建你的组件文件（如：indexPage.vue），script一定要export default {} 第二步：在需要用的页面（组件）中导入：import indexPage from ‘@/components/indexPage.vue’ 第三步：注入到vue的子组件的components属性上面,components:{indexPage} 第四步：在template视图view中使用，例如有indexPage命名，使用的时候则index-page vue.cli项目中src目录每个文件夹和文件的用法？assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件 vue如何实现按需加载配合webpack设置webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。 不进行页面按需加载引入方式：import home from ‘../../common/home.vue’ 进行页面按需加载的引入方式：const home = r =&gt; require.ensure( [], () =&gt; r (require(‘../../common/home.vue’))) 例如：在音乐app中使用的路由懒加载方式为： const Recommend = (resolve) =&gt; { import(&apos;components/recommend/recommend&apos;).then((module) =&gt; { resolve(module) }) } const Singer = (resolve) =&gt; { import(&apos;components/singer/singer&apos;).then((module) =&gt; { resolve(module) }) } v-show和v-if指令的共同点和不同点 v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏 v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果 v-if的特点：每次都会重新删除或创建元素v-show的特点：每次不会重新进行DOM的删除和创建操作，只是切换了元素的display：none v-if有较高的切换性能，如果元素涉及到频繁的切换，最好不要使用v-ifv-show有较高的初始渲染消耗，如果元素可能永远也不会显示出来被用户看到，则不推荐使用v-show 为什么使用key？当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。 为什么避免 v-if 和 v-for 用在一起当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。 Vue的双向数据绑定原理是什么？vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤：第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己2、自身必须有一个update()方法3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化-&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 此题答案同样适合”vue data是怎么实现的？”此面试题。 如何让CSS只在当前组件中起作用将当前组件的&lt;style&gt;修改为&lt;style scoped&gt; Vue中引入组件的步骤?1）采用ES6的import … from …语法或CommonJS的require()方法引入组件 2）对组件进行注册,代码如下 // 注册 Vue.component(&apos;my-component&apos;,{ template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos; }) 3）使用组件 在Vue中使用插件的步骤 采用ES6的import … from …语法或CommonJSd的require()方法引入插件 使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true }) 如使用懒加载插件： Vue.use(VueLazyload, { loading: require(&apos;common/image/default.png&apos;) }) 请列举出3个Vue中常用的生命周期钩子函数 created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见 mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 activated: keep-alive组件激活时调用 生命周期总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 1. 什么是vue生命周期答：Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 2. vue生命周期的作用是什么答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 3. 第一次页面加载会触发哪几个钩子答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子 4. DOM 渲染在哪个周期中就已经完成答：DOM 渲染在 mounted 中就已经完成了。 5. 简单描述每个周期具体适合哪些场景答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom vue-loader是什么？使用它的用途有哪些？解析.vue文件的一个加载器。（深入理解见https://www.jb51.net/article/115480.htm） 用途：js可以写es6、style样式可以scss或less、template可以加jade等 根据官网的定义，vue-loader 是 webpack 的一个 loader，用于处理 .vue 文件。其次，使用vue-cli脚手架，作者已经配置好了基本的配置，开箱及用，你需要做的就是npm install 安装下依赖，然后就可以开发业务代码了。当然，如果你想进阶，最好熟悉下vue-loader的具体配置，而不要依赖脚手架 请说下封装 vue 组件的过程？答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。 然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？答：css的预编译。（scss是sass的一个升级版本，完全兼容sass之前的功能，又有了些新增能力，最主要的就是sass是靠缩进表示嵌套关系，scss是花括号） 使用步骤：第一步：先装css-loader、node-loader、sass-loader等加载器模块第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss第三步：在同一个文件，配置一个module属性第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss” 特性: 可以用变量，例如（$变量名称=值）； 可以用混合器，混入@mixin 可以传变量 可以嵌套 继承@extend 不可以传变量，相同样式直接继承，不会造成代码冗余；基类未被继承时，也会被编译成css代码","path":"2019/08/15/面试宝典-Vue/"},{"title":"面试宝典-前后端交互","text":"秋招季，总结一下前后端交互部分面经~ 一. 跨域问题：什么是跨域？跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。所谓同源是指，协议，域名，端口均相同。注意：如果是协议和端口造成的跨域问题“前台”是无能为力的；在跨域问题上，域仅仅是通过“URL的首部”来识别 解决方案：特别注意两点：第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。1. JSONP方式解决跨域问题script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。2. CORS解决跨域问题对后台进行配置，例如：PHP端修改header，然后配置Apache web服务器跨域3. 代理请求方式解决接口跨域问题前端对接口进行代理：（前端ajax请求的是本地接口；本地接口接收到请求后向实际的接口请求数据，然后再将信息返回给前端；一般用node.js即可代理；）详情参考https://segmentfault.com/a/1190000012469713 二. Jsonp实现原理 拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;\\script&gt;、&lt;\\img&gt;、&lt;\\iframe&gt;当需要通讯时，本站脚本创建一个script元素，地址指向第三方的API网址，形如： &lt;script src=&quot;http://www.example.net/api?param1=1¶m2=2&quot;&gt;&lt;/script&gt; 并提供一个回调函数localHandler来接收数据（函数名可约定，或通过地址参数传递）。 &lt;script src=&quot;http://www.example.net/api?param1=1&amp;callback=localHandler&quot; type=&quot;text/javascript&quot;&gt; var localHandler = function(data){ alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); }; &lt;/script&gt; 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如： localHandler( { &quot;result&quot;:&quot;hax&quot;, &quot;gender&quot;:&quot;Male&quot; } ) 这样浏览器会调用localHandler函数，并传递解析后json对象作为参数。 三. 前后端分离的好处 最大的好处就是前端JS可以做很大部分的数据处理工作，对服务器的压力减小到最小。 后台错误不会直接反映到前台，错误接秒较为友好。 由于后台是很难去探知前台页面的分布情况，而这又是JS的强项，而JS又是无法独立和服务器进行通讯的。所以单单用后台去控制整体页面，又或者只靠JS完成效果，都会难度加大，前后台各尽其职可以最大程度的减少开发难度。 四. 从输入一个URL到页面加载完成的过程中都发生了什么事情？ 主要分为6步： DNS域名解析 浏览器与服务器建立TCP连接（3次握手过程） 浏览器向服务器发起HTTP请求 服务器接受请求，进行响应结果，将生成的html返回给客户端 浏览器解析HTML,并请求html代码中的资源 浏览器对页面进行渲染呈现给用户 网络通信的整个流程：流程描述： 第一步：打开浏览器，想要请求访问京东，在地址栏输入了网址：www.jd.com。（www.jd.com是域名就是一个IP地址的名称，IP地址不好记，所有有了域名。） 第二步：先将请求信息发给了交换机，然后交给了路由器，路由发给DNS服务器，通过DNS协议去找我们要访问的京东的IP地址： 第三步：查到的京东服务器对应的IP地址之后，路由器通过路由协议找到一个路由转发的最优路径，将你的请求信息还送给这个IP地址的京东的路由器 第四步：京东的路由器发给了京东网站的服务器上 第五步：京东网站服务器按照来的时候的路径，在返回给你他自己的网站 第六步：当你打开浏览器的时候，你的电脑给你的浏览器这个运行起来的程序给了一个编号，叫做端口号，当你的电脑收到京东发送过来的消息的时候，你的电脑通过端口号找到你的浏览器，你的浏览器拿到了京东的网站信息，然后将网站呈现在了自己的浏览器上 五. 进程和线程的区别 进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。 线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个程序至少一个进程，一个进程至少一个线程。 对资源的管理和保护要求高，不限制开销和效率时，使用多进程。要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。 线程共享进程资源，进程之间的资源独立一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。进程切换时，消耗的资源大，效率高 线程与进程的区别：a. 一个程序至少有一个进程，一个进程至少有一个线程b. 线程的划分尺度小于进程，使得多线程程序的并发性高c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 六. 队列和栈介绍 队列：先进先出，表尾插入，表头删除。队列可以模拟很多现实的生产环境，例如排队，队列是先进先出，不允许有任何元素插队，这对于解决现实生产问题有很大帮助。栈：先进后出，表尾删除插入。可以很好的控制访问，栈的数据访问是有很严格的，只能访问最后加入的数据，这对数据访问控制严格的应用很有好处。现实中，字符串倒序输出，使用栈的原理就可以很好的实现。 栈与队列的相同点： 1.都是线性结构。 2.插入操作都是限定在表尾进行。 3.都可以通过顺序结构和链式结构实现。 4.插入与删除的时间复杂度都是O(1)，效率非常高，在空间复杂度上两者也一样。 5.多链栈和多链队列的管理模式可以相同。 栈与队列的不同点： 队列先进先出，栈先进后出。 对插入和删除操作的”限定”不同。栈是限定只能在表的一端进行插入和删除操作的线性表。队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。 遍历数据速度不同。栈只能从头部取数据，也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性。队列则不同，它基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的 七. HTTP状态码及常见举例1** ：信息，服务器收到请求，需要请求者继续执行操作2** ：成功，操作被成功接收并处理3** ：重定向，需要进一步的操作以完成请求4** ：客户端错误，请求包含语法错误或无法完成请求5** ：服务器错误，服务器在处理请求的过程中发生了错误100 ：继续。客户端应继续其请求。101 ：切换协议，服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200 ：OK。请求成功，一般用于Get和post请求。201 ：已创建。成功请求并创建了新的资源。202 ：已接受。已经接受请求，但未处理完成203 ：非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本。204：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。300：多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。301 ：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。302：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。304：服务端资源无变化，可使用缓存资源307：临时重定向。与302类似。使用GET请求重定向。400：客户端请求的语法错误，服务器无法理解401：请求要求用户的身份认证403：服务端禁止访问该资源404：服务器无法根据客户端的请求找到资源（网页）。408：服务器等待客户端发送的请求时间过长，超时。410：客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置。411：服务器无法处理客户端发送的不带Content-Length的请求信息414：请求的URI过长（URI通常为网址），服务器无法处理417：服务器无法满足Expect的请求头信息。500：服务器内部错误，无法完成请求。501：服务器不支持请求的功能，无法完成请求。502：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求503：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。504：充当网关或代理的服务器，未及时从远端服务器获取请求。505：服务器不支持请求的HTTP协议的版本，无法完成处理。 八. Http请求方法 Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE，对URL地址（网络上的资源）的查，改，增，删4个操作。5、HEAD；6、TRACE；7、OPTIONS； 序号 方法 描述 1 GET 发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。另外get支持快取、缓存、可保留书签等。幂等 2 POST 和get一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中。不支持快取。非幂等 3 HEAD 本质和get一样，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。 4 PUT 和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知道该位置；比如post是在一个集合上（/province），而put是具体某一个资源上（/province/123）。所以put是安全的，无论请求多少次，都是在123上更改，而post可能请求几次创建了几次资源。幂等 5 DELETE 请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。幂等 6 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。 7 OPTIONS 获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。 GET与POST方法有以下区别： 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTTP包的body中。 GET方式提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST则没有此限制。 安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。 服务器取值方式不一样。GET方式取值，如php可以使用$_GET来取得变量的值，而POST方式通过$_POST来获取变量的值。 Post和put区别PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源） 九. 计算机网络的七层OSI应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 十. TCP/IP五层模型的协议应用层、传输层、网络层、数据链路层、物理层 十一. TCP和UDP的区别是什么UDP协议和TCP协议都是传输层协议。 TCP（Transmission Control Protocol，传输控制协议） TCP（Transmission Control Protocol，传输控制协议）提供的是面向连接，可靠的字节流服务。即客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。 优点：可靠，稳定 TCP的可靠性体现在传输数据之前，三次握手建立连接（四次挥手释放连接），并且在数据传递时，有确认、窗口、重传、拥塞控制机制，数据传完之后，断开连接用来节省系统资源。 缺点：慢，效率低，占用系统资源高，易被攻击 传数据之前建立连接，这样会消耗时间，而且在消息传递时，确认机制、重传机制和拥塞控制机制都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。而每个连接都会占用系统的CPU、内存等硬件软件资源。并且TCP的取而机制、三次握手，这些也导致TCP容易被人利用，实现DOS，DDOS攻击。 协议： HTTP HTTPS SSH Telnet FTP SMTP TCP应用场景： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。 TCP粘包问题 首先要明确, 粘包问题中的 “包” , 是指的应用层的数据包； 在TCP的协议头中, 没有如同UDP一样的 “报文长度” 这样的字段, 但是有一个序号这样的字段； 站在传输层的角度, TCP是一个一个报文过来的，按照序号排好序放在缓冲区中； 站在应用层的角度, 看到的只是一串连续的字节数据. 那么应用程序看到了这么一连串的字节数据, 就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。 那么如何避免粘包问题呢? 归根结底就是一句话, 明确两个包之间的边界. 对于定长的包, 保证每次都按固定大小读取即可; 对于变长的包, 可以在报头的位置, 约定一个包总长度的字段, 从而就知道了包的结束位置; 对于变长的包, 还可以在包和包之间使用明确的分隔符。 TLV格式的数据传输 UDP（User Data Protocol，用户数据报协议） UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。 优点：快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，udp是一个无状态的传输协议，所以他在传输数据时非常快。M没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。UDP也是无法避免攻击的，比如：UDP flood攻击 缺点：不可靠，不稳定因为UDP没有TCP的那些可靠机制，在网络质量不好时很容易丢包。 协议： NFS: 网络文件系统 TFTP: 简单文件传输协议 DHCP: 动态主机配置协议 BOOTP: 启动协议(用于无盘设备启动) DNS: 域名解析协议 UDP应用场景： 效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。 TCP与UDP区别总结：1. `TCP面向连接`（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 2. `TCP提供可靠的服务`。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 3. `TCP面向字节流`，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 4. 每一条`TCP连接只能是点到点的`;UDP支持一对一，一对多，多对一和多对多的交互通信 5. TCP`首部开销`20字节;UDP的首部开销小，只有8个字节 6. TCP的逻辑通信信道是`全双工`的`可靠信道`，UDP则是不可靠信道 十二. TCP与HTTP的不同，HTTP是什么，HTTPS是什么 HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。 HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间。 TCP是传输层，而http是应用层，http是要基于TCP连接基础上的。TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。 十三. TCP的三次握手,为什么不是两次？ 三次握手：请求，确认，建立连接第一次：客户端C发送一个请求连接的位码SYN(1)和一个随机产生的序列号Seq(x)给服务器S，C进入SYN_SEND状等待服务器确认。第二次：S收到了这个请求连接的位码SYN(1)，实现确认一下，发送了一个确认码ACK（x+1)+SYN(1)+Seq（y）给进入SYN_RECV状态。第三次：C收到了SYN＋ACK，一比较一样，于是他又发送了一个ACK(y+1)+Seq(z)给S，S收到以后就确定建立连接，C和S进入ESTABLISHED状态，TCP连接建立完成。 为什么不是两次？三次是①C能和S通信②S能和C通信③S和C建立连接，两次的话，不能确定S和C是否能通信，会产生问题 十四. 四次挥手：确保数据能够完整传输。 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。C没数据传输了 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。S说我也没了 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。C请求关闭 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。S同意并关闭 十五. 一次js请求一般情况下有哪些地方会有缓存处理？ 浏览器端存储 浏览器端文件缓存 HTTP缓存304 服务器端文件类型缓存 表现层&amp;DOM缓存 十六. HTTP缓存机制Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。 浏览器缓存分类浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下： 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。 缓存规则解析为方便大家理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。 HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，协商缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。 已存在缓存数据时，仅基于强制缓存，请求数据的流程如下： 已存在缓存数据时，仅基于协商缓存，请求数据的流程如下： 对缓存机制不太了解的同学可能会问，基于协商缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。 我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。 1. 强缓存 强缓存命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。 强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。 Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 该字段会返回一个时间，比如Expires:Thu,31 Dec 2037 23:59:59 GMT。这个时间代表着这个资源的失效时间，也就是说在2037年12月31日23点59分59秒之前都是有效的，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当客户端本地时间被修改以后，服务器与客户端时间偏差变大以后，就会导致缓存混乱。于是发展出了Cache-Control。 Cache-Control Cache-Control是一个相对时间，例如Cache-Control:3600，代表着资源的有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。 2. 协商缓存 若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。 Last-Modify/If-Modify-Since 浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。 当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。 ETag/If-None-Match 与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。 十七. CDN（内容分发网络，Content Distribute Network）的概念以及使用CDN加速的优点。cdn加速是什么？ CDN解决的是如何将数据快速可靠从源站传递到用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。 简单来讲云服务商会在全国各地部署节点服务器，当你的网站购买使用了他们的cdn，那么会把你网站可以缓存的内容都缓存在各地区的节点服务器上。这样不同地区的用户访问你的网站时，就可以在它最近的节点上访问，不需要到你的主站，通过这个方式达到加速的效果。 在通俗一点讲，比如京东自营，当你在网站上购买一件商品，需要快递到厦门，如果是从北京发货那么3天时间是需要的，但京东在厦门设立了仓库，并且提前把货存在仓库中，这时就可以直接从厦门仓发货，当天或隔天就可以收到商品，速度跟体验都非常好。 那么除了速度加快，使用cdn还有什么好处呢？ 网站不容易宕机如果你的网站没有使用cdn，当同个时间出现巨大的访问量时，网站很可能会宕机，比如双十一，凌晨过后突然有大量用户访问，如果不做负载处理那么页面打开会非常缓慢，在使用cdn后，就可以减少网站宕机的情况，承载更多的流量。 保障网站安全cdn的负载均衡和分布式存储技术，加上节点之间的智能冗余机制，可以有效应对大部份的黑客入侵以及ddos的攻击，无形中给网站增加了一把保护伞，避免由于攻击带给网站的巨大损失。 异地备援更可靠使用了cdn加速，当某一个节点服务器发生故障时，不会影响多数用户的访问，系统会判断并调用其它临近正常运行的服务器，这样的机制可以提供接近100%的可靠性，让你的网站做到永不宕机。 减轻原服务器负载当内容分发自动缓存到其它服务器后，用户在访问网站时从临近的服务器上读取数据，减少原web服务器的带宽使用，分担网络流量、减少负载等好处。 不仅如此，cdn还有很多的优点，比如计费合理，平衡节点流量输出，减少费用开支等， 那么对SEO来讲好处主要是网站打开速度优化，稳定性更强，能承载大量蜘蛛访问抓取。 十八. 前端开发常见安全问题（SQL注入、XSS攻击、CSRF攻击）1. SQL注入 SQL攻击（SQL injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。 SQL注入攻击原理 寻找到SQL注入的位置 判断服务器类型和后台数据库类型 针对不通的服务器和数据库特点进行SQL注入攻击 防御措施： 永远不要信任用户的输入对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双“-”进行转换等 永远不要使用动态拼装sql可以使用参数化的sql或者直接使用存储过程进行数据查询存取。哪怕参数是常量，也请用预编译语句PreparedStatement，同时用占位符，如： “select * from table where comment like ?”。注意：如果参数不是使用的占位符，即使用PreparedStatement执行时也并不是预编译。 永远不要使用管理员权限的数据库连接为每个应用使用单独的有权限的数据库连接，这样能降低数据库密码被泄漏而带来的破坏。 不要把机密信息直接存放加密或者hash掉密码和敏感的信息；如数据库连接密码、用户密码、设备密码需要加密存储。 应用的异常信息应该给出尽可能少的提示最好使用自定义的错误信息对原始错误信息进行包装。 2. XSS跨站脚本攻击 XSS(Cross Site Scripting)跨站脚本攻击指攻击者在网页中嵌入客户端脚本(例如JavaScript)，当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的，比如获取用户的Cookie，导航到恶意网站，携带木马等 防御措施： 在cookie中不要存放一些敏感信息比如用户名、密码等安全信息，或者cookie中的信息采用加密的方式。最为有效的方式是将重要的cookie标记为http only，这样脚本中就不能访问这个cookie，就避免了XSS攻击利用JavaScript的document.cookie获取cookie： 输入过滤校验，对用户提交的数据进行有效性验证仅接受指定长度范围内并符合我们期望格式的的内容提交，阻止或者忽略除此外的其他任何数据。比如：电话号码必须是数字和中划线组成，而且要设定长度上限。过滤一些些常见的敏感字符，例如：&lt; &gt; ‘ “ &amp; # \\；过滤或移除特殊的Html标签， 例如: &lt;script&gt;, &lt;iframe&gt; , &amp;lt; for &lt;, &amp;gt; for &gt;, &amp;quot for；过滤JavaScript 事件的标签，例如&quot;οnclick=&quot;,&quot;onfocus&quot;等等。这里的数据校验除了前台要做，后台也要做。 DOM型的XSS攻击防御把变量输出到页面时要做好相关的编码转义工作，如要输出到&lt;script&gt;中，可以进行JS编码；要输出到HTML内容或属性，则进行HTML编码处理。根据不同的语境采用不同的编码处理方式。 3. CSRF（ Cross-site request forgery ）跨站点请求伪造 CSRF（ Cross-site request forgery ）也被称为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来很像XSS跨站脚本攻击，但是它于XSS完全不同。XSS是利用站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的站点，从而在并未授权的情况下执行在权限保护之下的操作。与XSS相比，CSRF攻击不大流行和难以防范，所以比XSS更具危险性。 CSRF攻击原理CSRF攻击原理比较简单，假设Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 防御措施： 合理使用POST和GETGET方法提交数据很容易被拿来做CSRF攻击，使用POST只能降低攻击风险，并不能杜绝，攻击者在第三方页面构造一个form就可以用POST提交数据构成CSRF攻击。 使用验证码在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。 检查Referer字段HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问 添加校验token由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验token的值为空或者错误，拒绝这个可疑请求。 十九. Ajax工作原理 创建XMLHttpRequest对象,也就是创建一个异步调用对象. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. 设置响应HTTP请求状态变化的函数. 发送HTTP请求. 获取异步调用返回的数据. 使用JavaScript和DOM实现局部刷新. 二十. 死锁是什么死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。永远在互相等待的进程称为死锁进程。 二十一. 自适应和响应式区别两者都是优化适应互联网中越来越分化的视口.应该说响应式的范畴更广一些。响应式可以自动适应不同尺寸的屏幕，无论你的设备尺寸多么奇葩。响应式使用CSS media queries的方法，根据目标设备自动改变风格如显示类型,宽度、高度等，这能很好解决不同屏幕尺寸的显示问题。是一个网站能够兼容多个终端而不是为每个终端做一个特定的版本，这个概念是为移动互联网浏览而诞生。自适应设计是基于断点使用静态布局，一旦页面被加载就无法再进行自动适应，自适应会自动检测屏幕的大小来加载适当的工作布局，也就是说，当你要采用自适应设计网站时，你得一个一个设计6种常见的屏幕布局。[自适应设计要求为每一个布局单独开发和维护HTML和CSS代码]1、320 2、480 3、760 4、960 5、1200 6、1600自适应设计需要做更多的工作，你必须至少设计6种常见的布局。而响应式设计可以更好地适应复杂的媒体设备要求，能很好地解决显示和性能问题，修改相当麻烦。修改相当麻烦。 二十二. 谈谈你对前端性能优化的理解 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽：开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体 缓存利用：使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验：避免CSS表达式，避免重定向 二十三. 请说出三种减少页面加载时间的方法 尽量减少页面中重复的HTTP请求数量 服务器开启gzip压缩 css样式的定义放置在文件头部 Javascript脚本放在文件末尾 压缩合并Javascript、CSS代码 使用多域名负载网页内的多个文件、图片 二十四. 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验[性能优化]。 图片懒加载，滚动到相应位置才加载图片。 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 二十五. 什么叫优雅降级和渐进增强？ 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。渐进增强和优雅降级的区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带 二十六. 网站重构的理解重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化，针对于SEO进行优化 减少代码间的耦合，让代码保持弹性 压缩或合并JS、CSS、image等前端资源 二十七. 谈谈以前端角度出发做好SEO需要考虑什么？ 了解搜索引擎如何抓取网页和如何索引网页 meta标签优化 关键词分析 付费给搜索引擎 链接交换和链接广泛度（Link Popularity） 合理的标签使用 二十八. 前端页面有哪三层构成，分别是什么？作用是什么？ 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。 行为层：由脚本负责。解决了页面上“内容应该如何对事件作出反应”的问题。 二十九. 系统访问量变高了，速度变慢了怎么办？优化。优化方式很多，如：读写分离、负载均衡资源服务器和应用服务器分离，即应用部署在应用服务器上，资源部署在资源服务器上。这时候，js和css的引用就需要更改为绝对URL，指向对应的资源服务器。 三十. WEB应用从服务器主动推送Data到客户端有那些方式？ html5 websoket WebSocket 通过 Flash XHR长时间连接 XHR Multipart Streaming 不可见的Iframe 标签的长时间连接(可跨域) 三十一. 知道的网页制作会用到的图片格式有哪些？png-8，png-24，jpeg，gif，svgWebp：谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准。 三十二. AMD和CMD 规范的区别？AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现CMD 按需执行依赖 - 懒执行，seaJS 是它的实现 三十三. 前端 MV*框架的意义 早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，基本不太需要框架。 随着 AJAX 的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了。 如果是页面型产品，多数确实不太需要它，因为页面中的 JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。 长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。 从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的 MV框架，这个状况会大有改观。 之所以感受不到 MV*框架的重要性，是因为Model部分代码较少，View的相对多一些。如果主要在操作View和Controller，那当然 jQuery 这类库比较好用了。 三十四. 对前端工程师这个职位是怎么看的？前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 实现界面交互 提升用户体验 有了Node.js，前端可以实现服务端的一些事情 前景： 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更?? 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 三十五. 平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 三十六. 说说最近最流行的一些东西吧？常去哪些网站？CSDN、SegmentFault、php.net、MDN、css参考手册、iconfont、underscore、github、Bootstrap、W3Shool、W3Cplus、caniuse","path":"2019/08/10/面试宝典-前后端交互/"},{"title":"面试宝典-Javascript","text":"秋招季，总结一下HTML部分面经~ 一. JS作用域和作用域链1. 作用域:作用域就是变量和函数的可访问范围，或者说变量或函数起作用的区域。 javascript函数的作用域：函数内的区域，就是这个函数的作用域，变量和函数在这个区域都可以访问操作。最外层函数外的区域叫全局用域，函数内的区域叫局部作用域。 javascript变量的作用域：在源代码中变量所在的区域，就是这个变量的作用域，变量在这个区域内可被访问操作。在全局作用域上定义的变量叫全局变量，在函数内定义的变量叫局部变量。 2. 作用域链作用域链（Scope Chain）是javascript内部中一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。 3. 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 4. 当全局变量跟局部变量重名的时候，局部变量会覆盖掉全局变量(变量提升)在函数中存在同名的局部变量，如何使用全局变量？window.全局变量名，客户端中，window为全局对象，不在任何函数内的js代码，也可以使用this来引用全局对象，如：var global = this。不加var，相当于给全局对象创建一个同名属性。 5. var和不加var的全局变量区别： 在严格模式和非严格模式下不同，严格模式下，给一个没有声明的变量赋值会报错。 《js权威P58》使用var声明一个变量，创建的全局对象的属性是不可配置的，也就是说无法通过delete运算符删除；而没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量，以这种方式创建的变量是全局对象的正常的可配置属性，并可以删除它们。js全局变量是全局对象的属性。this可以引用全局对象。 作用域详细解读：https://www.cnblogs.com/hfxm/p/5547922.html 二. JS构造函数、原型和原型链1. 构造函数构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。另外就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。 2. 原型在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。 3. 原型链 在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的条，专业术语称之为原型链。举例说明:person → Person → Object ，普通人继承人类，人类继承对象类 原型链查找过程当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。 4. 写一个原型链继承的例子// 动物 function Animal() { this.eat = function () { console.log(&apos;animal eat&apos;) } } // 狗 function Dog() { this.bark = function () { console.log(&apos;dog bark&apos;) } } Dog.prototype = new Animal() // 哈士奇 var hashqi = new Dog() 5. 描述new一个对象的过程 创建一个新对象 this 指向这个新对象 执行代码，即对 this 赋值 返回 this function Foo(neme, age) { this.name = name this.age = age this.class= &apos;class-1&apos; // return this // 默认有这一行 } var f = new Foo(&apos;zhangsan&apos;, 20) 如何判断一个变量是数组类型 var arr = [] arr instanceof Array //true typeof arr //object,typeof是无法判断是否是数组的 原型链详细解读：https://www.cnblogs.com/jianghao233/p/8983176.html 三. js闭包、继承1. 闭包：闭包是能够读取其他函数内部变量的函数，是函数内部和函数外部连接起来的桥梁。闭包连接起来了一个函数和当函数声明时的词法作用域。 闭包最大用处有两个： 读取函数内部的变量； 让这些变量的值始终保存在内存中。使用闭包主要是为了设计私有的方法和变量。 闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 函数嵌套函数（外部嵌套的函数将嵌套的函数对象作为返回值返回） 函数内部可以引用外部的参数和变量（子函数可以使用父函数的变量，反之则不能） 参数和变量不会被垃圾回收机制回收（会让变量的值始终在内存中） 2. ES6中闭包： let命令：块级作用域；不存在变量提升：var定义变量：可以先使用，后声明；而let定义变量：只可先声明，后使用；暂时性死区：只要一进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量；不允许重复声明 const命令：const命令用来声明常量，一旦声明，其值就不能改变；在声明时必须初始化；块级作用域，所以其变量只在块级作用域内使用或其中的闭包使用；不存在变量提升；不可重复声明常量；变量名指向的地址不变，并不保证该地址的数据不变； 3. 继承：创建的子类将继承超类的所有属性和方法，包括构造函数及方法的实现。子类还可添加超类中没有的新属性和方法，也可以覆盖超类的属性和方法。 继承的方式： 原型链继承:将子类的prototype属性赋值为父类实例对象，则子类的proto属性继承父类。 借用构造函数继承：用.call()和.apply()将父类构造函数引入子类函数；call() 方法：它的第一个参数是用作 this 的对象，其他参数都直接传递给函数自身，B.call(A, args1,args2);即A对象调用B对象的方法；apply() 方法：用作 this 的对象和要传递给函数的参数的数组 B.apply(A, arguments);即A对象应用B对象的方法混合方式： 组合继承（组合原型链继承和借用构造函数继承） 对象冒充 寄生式继承 给两个构造函数A和B，如何实现A继承B？function A(…) {} A.prototype…function B(…) {} B.prototype…A.prototype = Object.create(B.prototype); 为什么要用Object.create(B.prototype)？因为如果这里用new B()的话，函数B的构造函数的参数就传了undefined，里面的一些函数可能会误执行，如果构造函数里面创建了一些对象的话，可能会造成内存泄漏。 call()、apply()、和bind()的区别js改变this指向的方法var obj = {name:”wang”} 函数对象的call()方法,用于指定this调用函数,第一参数是指定的this对象,从第二个参数开始,是调用自身函数所传递的参数，this指向objtest.call(obj,1,3); 函数对象的apply()方法,也用于指定this调用函数,第一个参数也是指定的this对象,和call的区别是:第二个参数是一个数组,数组中存放本次调用要传递的参数，this指向objtest.apply(obj,[1,3]); 函数对象的bind()方法,不会调用本函数,而是生成一个新的函数,这个函数的代码逻辑和原函数一样,但是this指向不一样，指向.bind(demo),demo this.name=&quot;jack&quot;; var demo={ name:&quot;rose&quot;, getName:function(){return this.name;} } console.log(demo.getName());//输出rose 这里的this指向demo var another=demo.getName; console.log(another())//输出jack 这里的this指向全局对象= //运用bind方法更改this指向 var another2=another.bind(demo); console.log(another2());//输出rose 这里this指向了demo对象了; 四. 基础数据类型： 基本类型：String(任意字符串) Number(任意数字) boolean(true/false) null(null) undefined(undefined) 对象类型（引用类型）：Object(任意对象) Array(一种特别对象，数值下表，内部数据有序) Function(一种特别对象) 分类：typeof instanceof typeof:可以判断number string boolean undefined function；不可以判断：array与object、null与object；返回数据类型是字符串表达式 instanceof：判断对象的具体类型；可以判断undefined和null 五. JS ES6特性 ECMAScript 6 简称 ES6，是 JavaScript 语言的下一代标准，已经在2015年6月正式发布。新特性： let、const块级作用域 import导入模块、export导出模块 ES6引入class(构造函数）、extends(继承)、super(原型) arrow functions （箭头函数）不需要 function 关键字来创建函数，省略 return 关键字，继承当上下文的 this 关键字 template string （模板字符串）用{${name}}嵌入 destructuring （解构）解构能让我们从对象或者数组里取出数据存为变量 default 函数默认参数 rest arguments （rest参数\\剩余参数：拿到除开始参数外的参数）function func(a, …rest) Spread Operator （展开运算符）(…person) 对象初始化简写 Promise：它主要用于处理异步回调代码，让代码不至于陷入回调嵌套的死路中。构造函数有callreject/resolve这几个方法，reject/resolve两个参数，将处理信息传递给promise函数 Generators：生成器（ generator）是能返回一个迭代器的函数。 六. JS 同步和异步的区别javascript语言是一门“单线程”的语言，所谓单线程就是按次序执行，执行完一个任务再执行下一个。同步和异步的差别就在于这单线程上各个流程的执行顺序不同。 同步：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步：不进入主线程、而进入”任务队列”（task queue）的任务，自己做自己的任务，只有等主线程任务执行完毕，自己下面的任务也做完了，”任务队列”开始通知主线程，请求执行任务，该任务才会进入主线程执行。 在JS中，异步编程只有四种情况： 定时器都是异步编程的，setTimeout和setInterval函数；setTimeout(function(){ alert(“Hello”); }, 3000); 所有的事件绑定都是异步编程的，click事件等； Ajax读取数据都是异步编程的，我们一般设置为异步编程； 回调函数callback都是异步编程的； 七. 深拷贝与浅拷贝 浅拷贝：是指只复制一层对象，当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化（就是假设B复制了A，当修改A时，B也变化了） 深拷贝：是指复制对象的所有层级（当修改A时，B没变化）。 实现方法 通过递归实现，递归去复制所有层级属性 通过JSON解析实现，借用JSON对象的parse和stringify 借用JQ的extend方法 八. JS 的引用赋值与传值赋值 number,string类型都是基本类型是通过传值赋值的，而基本类型存放在栈区，访问时按值访问，赋值是按照普通方式赋值； 对象和数组是通过引用来赋值的，所以改变arr1的同时arr2也会跟着改变; 九. js内存泄漏 内存泄漏可以定义为一个应用，由于某些原因不再需要的内存没有被操作系统或者空闲内存池回收。 常见的JavaScript泄漏 意外的全局变量js对未声明变量会在全局最高对象上创建它的引用，（是以属性存在的，而不是变量），如果在游览器上就是window对象，如果在node环境下就是global;如果未声明的变量缓存大量的数据，它可能只有在页面被刷新或者被关闭的时候才会释放内存，这样就造成了内存意外泄漏针对上面类型的内存泄漏我们在平时一定要声明变量，不要有全局直接引用。（在JavaScript文件中添加 ‘use strict’，开启严格模式，可以有效地避免上述问题。） 被遗忘的计时器或回调js中常用的定时器setInterval()、setTimeout().他们都是规定延迟一定的时间执行某个代码，而其中setInterval()和链式setTimeout()在使用完之后如果没有手动关闭，会一直存在执行占用内存，所以在不用的时候我们可以通过clearInterval()、clearTimeout() 来关闭其对应的定时器，释放内存。 超出DOM引用有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。 闭包闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。 console.log作为前端平时使用console.log在控制台打出相对应的信息可以说是非常常见。但如果没有去掉console.log可能会存在内存泄漏。因为在代码运行之后需要在开发工具能查看对象信息，所以传递给console.log的对象是不能被垃圾回收。 十. click和onclick的区别 click 是方法，由程序员写语句调用；onclick是事件；方法触发事件 click本身是方法作用是触发onclick事件，只要执行了元素的click()方法，就会触发onclick事件； 十一. DOM操作——怎样添加、移除、移动、复制、创建和查找节点。1. 创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 2. 添加、移除、替换、插入appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点 3. 查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 4. 向页面中添加30000个li标签https://www.jianshu.com/p/15c9f38e07cc 当li数量少的时候可以直接循环插入节点 &lt;!-- html --&gt; &lt;ul id=&quot;container&quot;&gt;&lt;/ul&gt; &lt;!-- js--&gt; let container = document.getElementById(&apos;container&apos;); for (let i = 0; i &lt; 4; i++) { let item = document.createElement(&apos;li&apos;); item.innerText = i + 1; ul.appendChild(item); } 当我们要添加的 li 标签的数量很多的时候，如果我们还是采取这种方法的话，页面加载的速度会很慢。 采用分治处理 / 批处理分治处理是采取分治算法思想，将很多的事件处理分为若干次处理的思想。主要方法是创建文档碎片 ：document.createDocumentFrag上面例子的改良： let container = document.getElementById(&apos;container&apos;); let totalCount = 30000; // 总共的 li 数量 let oneCount = 4; // 每次添加的 li 数量 let base = 0; // 用于计数，目前执行添加了几次批处理 let preCount = totalCount / oneCount; // 总共需要执行的批处理次数 while (base * oneCount &lt; preCount) { let fragment = document.createDocumentFragment(); for (let i = 0; i &lt; 4; i++) { let item = document.createElement(&apos;li&apos;); item.innerText = (base * oneCount) + i + 1; fragment.appendChild(item); } container.appendChild(fragment); base = base + 1; } 十二. setTimeOut，promise和主程序的执行顺序then和settimeout执行顺序，即setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.then()在本轮“事件循环”结束时执行。因此then 函数先输出，settimeout后输出。 十三. 事件机制之冒泡、捕获、传播和委托。 DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。事件捕获（event capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。 dom标准事件流的触发的先后顺序为：先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。 说到事件冒泡与捕获就不得不提一下两个用于事件绑定的方法addEventListener、attachEvent。当然还有其它的事件绑定的方式这里不做介绍。addEventListener(event, listener, useCapture)参数定义：event—（事件名称，如click，不带on），listener—事件监听函数，useCapture—是否采用事件捕获进行事件捕捉，默认为false，即采用事件冒泡方式addEventListener在 IE11、Chrome 、Firefox、Safari等浏览器都得到支持。attachEvent(event,listener)参数定义：event—（事件名称，如onclick，带on），listener—事件监听函数。attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了（微软还是挺识趣的，慢慢向标准靠拢）。 十四. Js阻塞及解决思路 Js阻塞机制，跟Js引擎的单线程处理方式有关，每个window一个JS线程。所谓单线程，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。 由于浏览器是事件驱动的（Event driven），因此浏览器中很多行为是异步的，很容易有事件被同时或者连续触发。当异步事件发生时，会创建事件并放入执行队列中，等待当前代码执行完成之后再执行这些代码，如鼠标点击事件发生、XMLHttpRequest 完成回调、定时器触发事件发生这些事件，都会被放入执行队列中等待。 js执行会阻塞DOM树的解析和渲染，那么css加载不会阻塞DOM树的解析(结构)，但是会阻塞DOM树的渲染(样式)。 解决JS阻塞(不全)： html5的defer和async关键字defer延迟js执行；async异步执行。 动态加载js。查询文档加载状态，在合适的时候加载js。 详情参考http://blog.csdn.net/talking12391239/article/details/21168489 十五. JS无缝滚动效果实现方法分析效果：1.默认缓慢往左滚动2.放到左箭头上还是向左滚动，放到右箭头上向右滚动3.放到图片上停止滚动，移出继续滚动思路：1.计算图片列表ul的宽度2.开启定时器，使其向左边距不断增大，造成向左运动的效果3.图片列表复制一份，向左移动时，当左边距大于一份的宽度时，把它的左边距拉回到0。向右移动时，当左边距大于0时，把它的左边距拉到整个两份图片列表一半的宽度（即一份的宽度）。（拉的瞬间很快，用户察觉不到，造成一种无缝滚动的假象）4.offsetLeft值的正负决定往哪边移动5.放到图片上停止这个定时器，移开再开启 十六. 轮播图的实现原理在html ，css 已经写好的情况下。最主要的就是js的功能问题了。轮播图的功能步骤如下： 先让图片轮播起来。基本就是写一个 play函数里面加定时器，每次使图片的index对象加一，当index大于最值，设置index等于第 一张图片.这样轮播图就动起来了。 轮播图动起来基本就是只显示一张图片隐藏其他的图片。我上面使用的是opacity 。 图片下面的按钮。主要就是使下面的按钮与上面的图片一一对应。然后点击下面的按钮显示对应的图片。 左右的上一张和下一张按钮。点击左边的上一张按钮图片向前显示，实现原理就是使 index 对象减一。点击边下一张按钮图片向后显示，实现原理就是使 index 对象加一。 对应上一张和下一张连续点击的问题就是给这两个按钮加上延时器。 当鼠标放在轮播图区域时停止轮播，实现原理就是清除定时器，离开开始轮播就是加上定时器。","path":"2019/08/08/面试宝典-Javascript/"},{"title":"面试宝典-CSS","text":"秋招季，总结一下CSS部分面经~ 一. CSS3盒子模型 盒子模型IE 盒子模型和标准 W3C 盒子模型的范围包括 margin、border、padding、content使用“标准 W3C 盒子模型”：在网页顶部加上Doctype声明。 在不同标准里width的区别在标准 W3C 盒子模型中，width指content部分的宽度在 IE 盒子模型中，width表示（content+padding+border）这三个部分的宽度 box-sizingbox-sizing: content-box 是 W3C 盒子模型;content-box动态大小 | 受 “边框” “边距” 等属性影响box-sizing: border-box 是 IE 盒子模型;border-box固定大小 | 不受 “边框” “边距” 等属性影响 margin和padding可以为负么？margin可以为负，而且经常用于布局。padding不能为负，即使为负，也会调整为0. margin塌陷解决办法:https://www.cnblogs.com/syp172654682/p/7671830.html 二. 对BFC规范的理解？BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。 BFC 的原理/BFC的布局规则BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：（1）BFC 内部的子元素，在垂直方向，边距会发生重叠。（2）BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1）（3）BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2）（4）计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC有以下几种方法：方法1：overflow: 不为visible，可以让属性是 hidden、auto、scroll。【最常用】方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 原理解释说明(1)解决 margin 重叠当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。(2)清除浮动儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可 三. 块级元素、行内元素、块级行内元素列举display的值： 1. 行内元素：display:inline 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea（字体、input类、span）等； 特性： (1) 设置宽高无效； (2) margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间； (3) 不会自动进行换行； 水平居中：通过给父元素设置 text-align:center 垂直居中： (1) 子元素line-height:父元素的height； (2) 父元素display 为 table-cell（设置为表格单元显示）， vertical-align：middle属性 2. 块状元素：display:block 块状元素：div、p、nav、aside、header、footer、section、article、ul-li、address、h1-h6、blockquote、dl、dt、dd； 特性 ： (1) 能够识别宽高； (2) margin和padding的上下左右均对其有效； (3) 可以自动换行； (4) 多个块状元素标签写在一起，默认排列方式为从上至下； 水平居中： (1) margin:0 auto； (2) 使用position:relative或absolute 和 left:50% 垂直居中： (1) 父元素添加display设为flex，再通过align-items:center; (2) 父元素：position：relative; 子元素：position: absolute; top: 50%; margin-top=-height（子）/2; (3) 父元素：position:relative 子元素：position:absolute; top:0; bottom:0;margin:auto; 水平垂直居中： (1)父元素：position：relative; 子元素：position: absolute; top: 50%; left: 50%; margin-top=-height（子）/2; margin-right=-width/2;(已知块级元素的宽和高) (2)父元素：position:relative 子元素：position:absolute; top:0; left:0; bottom:0; right:0; margin:auto; (3)父元素样式属性display:flex; 子元素使用margin:auto; 溢出处理：当内容大于容器 overflow: hidden;隐藏溢出内容 overflow: auto;当内容溢出时，显示滚动条 overflow-y: auto; 只显示上下滚动条 overflow: scroll;无论是否溢出，都显示滚动条占位：隐藏了元素内容，但空间仍然保持 visibility: hidden; width&amp;height：(min-width max-width用于响应式布局、width:auto与父容器等宽) 3. 行内块状元素：display:inline-block 特征：(1) 不自动换行(2) 能够识别宽高(3) 默认排列方式为从左到右；(行内元素和块状元素都使用) 4. 垂直水平居中方法 已知宽高（4种方法） &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; 未知宽高(考虑flex布局和transform) 四. css相对定位、绝对定位 静态定位(position：static)不脱离标准文档流这个是元素的默认定位方式，元素出现在正常的文档流中，会占用页面空间。不能使用top?bottom??left??right??z-index??? 相对定位(position: relative)不脱离标准文档流相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动. 绝对定位(position: absolute)脱离标准文档流这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 固定定位(position: fixed)脱离标准文档流绝对定位方式，直接以浏览器窗口作为参考进行定位。其它特性同absolute定位。 inherit 规定从父元素继承 position 属性的值。 嵌套使用：子容器在父容器底部居中：父容器：position：relative；子容器：position：absolute；bottom：0；left：0；right：0；margin: auto 五. Flex布局容器的属性以下6个属性设置在容器上： flex-direction：决定主轴的方向 flex-wrap：定义如果一条轴线排不下，如何换行 flex-flow：是flex-direction属性和flex-wrap属性的简写形式 justify-content：定义了项目在主轴上的对齐方式 align-items：定义项目在交叉轴上如何对齐 align-content：定义了多根轴线的对齐方式。 项目的属性以下6个属性设置在项目上： order：定义项目的排列顺序 flex-grow：定义项目的放大比例 flex-shrink：定义了项目的缩小比例 flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size） flex：是flex-grow, flex-shrink 和 flex-basis的简写 align-self：允许单个项目有与其他项目不一样的对齐方式 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 六. CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS 选择符： id选择器(# myid) 类选择器(.myclassname) 标签选择器(div, h1, p) 相邻选择器(h1 + p) 子选择器(ul &gt; li) 后代选择器(li a) 通配符选择器( * ) 属性选择器(a[rel = “external”]) 伪类选择器(a: hover, li:nth-child) 可继承的样式： font-size font-family color text-indent 不可继承的样式： border padding margin width height 优先级算法： 优先级就近原则，同权重情况下样式定义最近者为准; 载入样式以最后载入的定位为准; !important &gt; 内联&gt; id &gt; class &gt; tag 权值： 内联样式表的权值最高 1000； ID 选择器的权值为 100 Class 类选择器的权值为 10 HTML 标签选择器的权值为 1 多个进行累加，比较总和 七. CSS伪类1. CSS 伪类用于向某些选择器添加特殊的效果。伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。注意：first-child和last-child都得用于子元素，而不是父元素。 2. 语法selector : pseudo-class {property: value} selector.class : pseudo-class {property: value} 3. 锚伪类 锚伪类 特性 a:hover {color: #FF00FF} 必须被置于 a:link 和 a:visited 之后，才是有效的。 a:active {color: #0000FF} 选定的链接 必须被置于 a:hover 之后，才是有效的。 4. CSS3新增伪类举例： css3新增伪类 特性 p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 :first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。 :first-of-type 匹配的是该类型的第一个。 :enabled / :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 八. CSS伪元素1. CSS 伪元素用于向某些选择器设置特殊效果。与伪类针对特殊状态的元素不同的是，伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。注意：:first-line和:first-letter伪元素只能用于块级元素。 2. 语法：selector:pseudo-element {property:value;} selector.class:pseudo-element {property:value;} 九. css3动画 先创建动画：@keyframes规则是创建动画。 @keyframes规则内指定一个CSS样式和动画将逐步从目前的样式更改为新的样式。 @keyframes myfirst { from {background: red;} to {background: yellow;} } 绑定选择器：当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会有任何效果。指定至少这两个CSS3的动画属性绑定向一个选择器：规定动画的名称规定动画的时长 div { animation: myfirst 5s; -webkit-animation: myfirst 5s; /* Safari 与 Chrome */ } 十. CSS3新增内容 边框border-radius（圆角边框）box-shadow（边框阴影）border-image 背景background-size:宽高 background-origin(content-box,padding-box,border-box) 文本效果 text-shadow word-wrap(break-word)text-wrap?s 字体 @font-face {font-family:ddd;src:url(‘.ttf’)}定义自己的字体 字体描述符：font-family，src，font-sketch，font-style… 2D转换 translate(向左移动距离，向下移动)\\ratate(度数) 3D转换ratateX() ratateY() 过渡 transition 动画 @keyframes{from,to} animation 多列 column-count:数字创建多列文本 用户界面resize（用户可改变大小），box-sizing（border-box，content-box） 十一. 什么是CSS Hack?CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号，以达到应用不同的CSS样式的目的。(不同浏览器识别不同css样式)CSS Hack常见的有三种形式：CSS属性Hack、CSS选择符Hack以及IE条件注释Hack， Hack主要针对IE浏览器。1、属性级Hack：比如IE6能识别下划线“_”和星号“*”，IE7能识别星号“*”，但不能识别下划线”_ ”，而firefox两个都不能认识。2、选择符级Hack：比如IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。3、IE条件注释Hack：IE条件注释是微软IE5开始就提供的一种非标准逻辑语句。比如针对所有IE：&lt;!-[if IE]&gt;&lt;!-您的代码-&gt;&lt;![endif]&gt;，针对IE6及以下版本：&lt;!-[if it IE 7]&gt;&lt;!-您的代码-&gt;&lt;![endif]-&gt;，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。https://blog.csdn.net/qq_31635733/article/details/81660897 十二. 浏览器的内核分别是什么?经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？常见的浏览器内核可以分四种：Trident、Gecko、Blink、Webkit 浏览器 内核 IE浏览器 Trident内核，也成为IE内核 Chrome浏览器 Webkit内核，现在是Blink内核 Firefox浏览器 Gecko内核，俗称Firefox内核 Safari浏览器 Webkit内核 Opera浏览器 最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核； 360浏览器 IE+Chrome双内核 猎豹浏览器 IE+Chrome双内核 百度浏览器 IE内核 QQ浏览器 Trident（兼容模式）+Webkit（高速模式） 浏览器常见的兼容性问题： 不同浏览器的标签默认的外补丁( margin )和内补丁(padding)不同解决方案： css 里增加通配符 * { margin: 0; padding: 0; } IE6双边距问题；在 IE6中设置了float , 同时又设置margin , 就会出现边距问题解决方案：设置display:inline; 当标签的高度设置小于10px，在IE6、IE7中会超出自己设置的高度解决方案：超出高度的标签设置overflow:hidden,或者设置line-height的值小于你的设置高度 图片默认有间距解决方案：使用float 为img 布局 IE9一下浏览器不能使用opacity解决方案：opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); 边距重叠问题；当相邻两个元素都设置了margin 边距时，margin 将取最大值，舍弃最小值；解决方案：为了不让边重叠，可以给子元素增加一个父级元素，并设置父级元素为overflow:hidden； cursor:hand 显示手型在safari 上不支持解决方案：统一使用 cursor:pointer 两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；解决方案：父级元素设置position:relativehttps://blog.csdn.net/qq_38892819/article/details/75426133 十三. display:none、visibility:hidden、visibility:collapse和opacity:0的区别Collapse:是否折叠（即是否不占据文档流位置）；event：是否还能触发事件；taborder：是否还可以通过tab键选择到。其中，visibility:collapse在表格元素中yes，即不占据文档流位置，在其他元素占据位置 行内元素display:inline对应不显示为display:none块状元素display:block对应不显示为visibility: hidden display：none设置该样式的元素（对象）的宽度、高度等各种属性值都将“丢失”，其元素不占据文档空间。不会触发事件 visibility: hidden设置该样式的元素（对象）仅仅是视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也就是它仍具有高度、宽度等属性值。不会触发事件 opacity:0opacity是CSS3的属性，0（完全透明），1（完全不透明），inherit设置此样式的元素（对象）仍然占据空间，并且能触发事件。 visibility:collapse在表格元素的tr中使用时，会删除一行或者一列，但是不会影响表格布局。若在td上使用，仅隐藏此单元格内容，仍然占据位置。应用与除表格外的其他元素，则仍然会为其保留位置，不会触发事件，也不会通过tab键选择到。 十四. visibility的值 十五. Float影响，清除浮动几种方法 浮动影响的主要是设置浮动元素之后的元素，对之前没有浮动的元素不产生影响。不管是设置浮动还是未设置浮动，其垂直位置不变，紧紧跟在未设置浮动元素之后，上边距与上一个元素的下边距对齐。 如果父元素没有设置高度，在子块没有浮动的情况下，父块会被撑开，但是内部子块浮动的话，就会产生以下影响： 父元素的背景不能显示 父元素的边框不能撑开，导致父元素之后的兄弟元素布局乱掉。 margin、padding值不能正确显示 十六. 清除浮动的几种方法： 设置父元素的高度为子元素的最高高度加上父元素的上下边框宽度。 给父元素结束标签之前添加一个div标签，将此标签的css设置为：clear:both或者是clear:left;(clear规定哪一侧不允许有浮动元素) 给父元素添加overflow：hidden。 :after作用于浮动元素的父元素将其设置为display:block 其中:clear:both;指清除所有浮动；content: ‘.’; display:block;对于FF/chrome/opera/IE8不能缺少，其中content（）可以取值也可以为空。visibility:hidden;的作用是允许浏览器渲染它，但是不显示出来，这样才能实现清除浮动。 十七. 为什么要初始化CSS样式。因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议） 十八. link 和@import 的区别是？ link属于HTML标签，而@import是CSS提供的; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import只在IE5以上才能识别，而link是HTML标签，无兼容问题; link方式的样式的权重 高于@import的权重. 十九. 解释下 CSS sprites，以及你要如何在页面或网站中使用它。CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了http2。 二十. 圣杯布局、双飞翼布局两边固定，中间自适应。 与圣杯布局相比，双飞翼HTML中为main添加了一个子元素main-wrap,这个小小的改动是为了之后处理main中内容被遮盖的问题，这也是两者实现方式最大的不同点。 与圣杯布局一样，一开始三个col都设置float: left,为了把left和right定位到左右部分，采用负边距，left部分margin-left: -100%，right部分margin-right: -190px。之后就是处理main中内容的遮盖问题，只需设置main-wrap的左右外边距即可解决。 相比圣杯布局，双飞翼不必设置左右栏的position: relative，也不必设置左右left、right值，只需多添加一个子元素包含，相应的padding换成margin。总的说来简单不少。 双飞翼布局的好处：主要的内容先加载的优化；兼容目前所有的主流浏览器，包括IE6在内；衍生布局：http://www.cnblogs.com/lyzg/p/5160570.htmlCSS布局面试：http://developer.51cto.com/art/201504/473284.htm css经典布局——双飞翼布局https://blog.csdn.net/qq_38128179/article/details/86542447 css经典布局——圣杯布局https://blog.csdn.net/qq_38128179/article/details/86533976 圣杯布局和双飞翼布局达到的效果基本相同，都是侧边两栏宽度固定，中间栏宽度自适应。 主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样。 圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现 而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。 双飞翼布局要求 header和footer各自占领屏幕所有宽度，高度固定。 中间的container是一个三栏布局。 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。双飞翼布局的实现 left、center、right三种都设置左浮动 设置center宽度为100% 设置负边距，left设置负边距为100%，right设置负边距为自身宽度 设置content的margin值为左右两个侧栏留出空间，margin值大小为left和right宽度 圣杯布局要求 header和footer各自占领屏幕所有宽度，高度固定。 中间的container是一个三栏布局。 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。圣杯布局的三种实现（1）浮动 先定义好header和footer的样式，使之横向撑满。 在container中的三列设为浮动和相对定位(后面会用到)，center要放在最前面，footer清除浮动。 三列的左右两列分别定宽200px和150px，中间部分center设置100%撑满 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了 接下来设置left的 margin-left: -100%;，让left回到上一行最左侧 但这会把center给遮住了，所以这时给外层的container设置 padding-left: 200px;padding-right: 150px;，给left和right空出位置 这时left并没有在最左侧，因为之前已经设置过相对定位，所以通过 left: -200px; 把left拉回最左侧 同样的，对于right区域，设置 margin-right: -150px; 把right拉回第一行 这时右侧空出了150px的空间，所以最后设置 right: -150px;把right区域拉到最右侧就行了。 （2）flex弹性盒子 header和footer设置样式，横向撑满。 container中的left、center、right依次排布即可 给container设置弹性布局 display: flex; left和right区域定宽，center设置 flex: 1; 即可 （3）grid布局如上图所示，我们把body划分成三行四列的网格，其中有5条列网格线 给body元素添加display: grid;属性变成一个grid(网格) 给header元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第一行网格的从第一条列网格线开始到第五条列网格线结束 给footer元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第三行网格的从第一条列网格线开始到第五条列网格线结束 给left元素设置grid-row: 2; 和 grid-column: 1/2; 意思是占据第二行网格的从第一条列网格线开始到第二条列网格线结束 给center元素设置grid-row: 2; 和 grid-column: 2/4; 意思是占据第二行网格的从第二条列网格线开始到第四条列网格线结束 给right元素设置grid-row: 2; 和 grid-column: 4/5; 意思是占据第二行网格的从第四条列网格线开始到第五条列网格线结束","path":"2019/08/03/面试宝典-CSS/"},{"title":"面试宝典-HTML","text":"秋招季，总结一下HTML部分面经~ 一. 行内元素、块级元素、空元素举例 空元素没有内容的HTML元素。空元素在开始标签中关闭的。（单标签）如：br、hr、img、input、param、meta、link 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote 块级元素和行内元素区别 占据空间 块级元素总是单独占一行，并从新的一行开始； 行内元素和其他同为行内元素占据同一行。 Width,height,Margin-padding是否可设置 块级可以，行内不可以。 通过改变元素的display可改变此属性。 宽度 行内元素宽度与内容相关； 块级元素不设置则与浏览器同宽。 容纳内容 块级元素可容纳内联元素和其他块元素； 行内元素只可容纳文本和其他行内元素。 二. Repaint（重绘）和Reflow（重排|回流） repaint：重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。 reflow：重排是更明显的一种改变，可以理解为渲染树需要重新计算。重排一定会引起浏览器的重绘，会影响排版。 常见的引起重排的具体操作： 调整窗口大小； 改变字体大小； 样式表改动； 元素内容变化，尤其是输入控件； CSS伪类激活； DOM操作； offsetWidth, width, clientWidth, scrollTop/scrollHeight的计算， 会使浏览器将渐进回流队Flush，立即执行回流 减少重排次数和缩小重排方法： 将多次改变样式属性的操作合并成一次操作。 将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 在内存中多次操作节点，完成后再添加到文档中去。 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个素进行复杂的操作时，可以先隐藏它，操作完成后再显示。 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。 三. H5新增标签和删除标签删除的标签： 纯表现的元素：basefont、big、center、font等 对可用性产生负面影响的元素：frame、frameset、noframes新增标签主要是语义化的标签如： &lt;header&gt;&lt;/header&gt; &lt;!--头部--&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!--导航栏--&gt; &lt;section&gt;&lt;/section&gt; &lt;!--区块（有语义化的div）--&gt; &lt;main&gt;&lt;/main&gt; &lt;!--主要区域--&gt; &lt;article&gt;&lt;/article&gt; &lt;!--主要内容--&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!--侧边栏--&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!--底部--&gt; 除此之外新增 `&lt;video&gt;&lt;audio&gt;&lt;Progress&gt;(进度条)` 标签语义化概念及语义化好处：标签语义化就是让标签有含义，给某块内容用上一个最恰当最合适的标签，使页面有良好的结构，页面元素有含义，不论是谁，都能看懂这块内容是什么，并且有利于搜索引擎。 语义化标签好处 ：HTML结构清晰可读性较好无障碍阅读有利于搜索引擎根据标签内容确定上下文和权重问题移动设备可以完美展现页面（CSS支持较弱的设备）有利于团队维护和开发代码 四. H5新增事件H5新的Web应用API，许多API都定义了事件。如：http://blog.csdn.net/charlene0824/article/details/52165429 Audio.video触发网络事件、数据缓冲状况、播放状态。Canpaly\\durationchange\\loadstart\\play\\playing\\waiting 拖放API，（抓取一种对象后拖到另一个位置）如:dragstart,drag,dragenter,dragdrop,dragover在拖放源和放置目标上设置 历史管理机制Hashchange（location.hash，获取片段标识符） 表单验证机制当验证失败会触发invalid 离线web应用缓存支持(manifest)Offline，online 异步通信使用message事件通信如websocket，webworker，server-sent Web存储两种（前两种，cookies本来就有）Localstorage、sessionStorage、cookies 五. sessionStorage、localStorage和 cookie 之间的区别 三者都是在浏览器端存储数据。 数据存储大小限制不同。cookies：数据始终在同源的http请求中携带，即cookie在服务器和浏览器间回传。故存储的数据大小最小，一般为4k。sessionStorage和localStorage：数据在本地保存，不会自动把数据发给服务器。所以一般5M或者更大。 数据有效期不同cookies：数据在cookie设置的有效期之前都有效，即使窗口和浏览器关闭。sessionStorage：数据在关闭浏览器窗口后自动清除。存储的数据仅在同源同窗口内有效，即使在不同浏览器相同页面也是无效的。一般用于存储会话数据。localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 数据作用域不同Cookies和localStorage：在所有同源窗口敏感词享。sessionStorage：不在不同浏览器窗口敏感词享。 请你谈谈Cookie的弊端 每个特定的域名下最多生成的cookie个数有限制 IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。 web storage和cookie的区别 Cookie的大小是受限的 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽 cookie还需要指定作用域，不可以跨域调用 Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage 六. a的href有几种 超链接目标的 URL； 有效文档的相对或绝对 URL； 伪协议： JavaScript 代码段(javascript:伪协议[通过一个链接调用js函数或者表达式等]void(0)指定无返回值[没有返回值的函数真正返回的都是 undefined]，若有返回值，会覆盖掉a的内容如： &lt;a href=&quot;javascript:void(window.open(&apos;about:blank&apos;))&quot;&gt;Click me&lt;/a&gt;) 其他的伪协议还有： mailto:(邮件地址)[点击链接会打开outlook进行邮件发送] tel:(电话)[会打开弹窗选择程序拨打电话，如skype] file:本机文件地址 七. 浏览器内核 IE: trident内核 Firefox(Mozilla)：gecko内核 Safari：webkit内核 Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核 Chrome：Blink(基于webkit，Google与Opera Software共同开发) 前缀对应： -moz-对应 Firefox, -webkit-对应 Safari and Chrome -o- for Opera -ms- for Internet Explorer 八. 列举IE与其他浏览器不一样的特性？ IE的排版引擎是Trident （又称为MSHTML） Trident内核曾经几乎与W3C标准脱节（2005年） Trident内核的大量 Bug等安全性问题没有得到及时解决 JS方面，有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等 CSS方面，也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式 九. Meta 响应式metawidth,height：宽度高度initial-scale：初始比例maximum-scale：允许用户缩放到的最大比例，minimum-scale：允许用户缩放到的最小比例,user-scalable：用户是否可以手动缩放,no,yes） &lt;meta name = “viewport” content = “width = device-width, initial-scale = 1, maximum-scale = 1, user-scale = no”&gt; 防止搜索引擎爬取页面 &lt;meta name = “robots” content = “noindex”&gt; 只防止Google &lt;meta name = “googlebot” content = “noindex”&gt; 防止爬取连接指向的页面 &lt;a href = “privatepage.html” rel = “nofollow”&gt;link to pricate page&lt;/&gt; 十. 加快HTML页面加载速度1. 页面减肥删除不必要的空格、注释；将inline的script和css移到外部文件；可以使用HTML Tidy来给HTML减肥，还可以使用一些压缩工具（uglify）来给JavaScript减肥 2. 减少文件数量减少页面上引用的文件数量可以减少HTTP连接数；许多JavaScript、CSS文件可以合并最好 3. 减少域名查询DNS查询和解析域名也是消耗时间的，所以要减少对外部JavaScript、CSS、图片等资源的引用，不同域名的使用越少越好 4. 缓存重用数据使用缓存吧 5. 优化页面元素加载顺序首先加载页面最初显示的内容和与之相关的JavaScript和CSS；然后加载DHTML相关的东西；图片、flash、视频等很肥的资源就最后加载 6. 减少inline JavaScript的数量浏览器parser会假设inline JavaScript会改变页面结构，所以使用inline JavaScript开销较大不使用document.write()这种输出内容的方法，使用W3C DOM方法来为现代浏览器处理页面 7. 指定图像和tables的大小如果浏览器可以立即决定图像或tables的大小，那么它就可以马上显示页面而不要重新做一些布局安排的工作；这不仅加快了页面的显示，也预防了页面完成加载后布局的一些不当的改变；image使用height和width；table使用table-layout: fixed并使用col和colgroup标签指定columns的width，少用table，table的渲染很耗时间(table是解析完成后加载，div是读到一句就开始加载) 8. CDN加速 详情参考：https://www.cnblogs.com/larennani/p/6741289.html 十一. Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? &lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 标签之前。告知浏览器以何种模式来渲染文档。 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 你知道多少种Doctype文档类型？该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 十二. HTML与XHTML——二者有什么区别区别： 所有的标记都必须要有一个相应的结束标记 所有标签的元素和属性的名字都必须使用小写 所有的XML标记都必须合理嵌套 所有的属性必须用引号””括起来 把所有&lt;和&amp;特殊符号用编码表示 给所有属性赋一个值 不要在注释内容中使“–” 图片必须有说明文字 十三. 文档加载、渲染过程1. 浏览器加载和渲染html的顺序 IE下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。 在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完） 如果遇到语义解释性的标签嵌入文件（JS脚本，CSS样式），那么此时IE的下载过程会启用单独连接进行下载。 并且在下载后进行解析，解析过程中，停止页面所有往下元素的下载。阻塞加载 样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前经渲染的）重新进行渲染。 JS、CSS中如有重定义，后定义函数将覆盖前定义函数 2. JS的加载 不能并行下载和解析（阻塞下载） 当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，比如使用document.write或appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现.","path":"2019/07/23/面试宝典-HTML/"},{"title":"flex布局-基本页面结构","text":"我们的目的是为了实现这样的布局： 源码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;template&gt; &lt;h-page-container&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;p&gt;标题栏&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;左侧栏&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;内容一&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;内容二&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;内容三&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;内容四&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;右侧栏&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/h-page-container&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot; scoped&gt;.container &#123; display: flex; display: -webkit-flex; /* Safari */ height: 600px; flex: 1&#125;.main &#123; flex: 6; border: 2px solid red; display: flex; display: -webkit-flex; /* Safari */ flex-direction: column&#125;.right &#123; flex: 2; border: 2px solid red&#125;.header &#123; flex: 1; border: 2px solid red&#125;.content &#123; flex: 9; border: 2px solid red; display: flex; display: -webkit-flex /* Safari */&#125;.left &#123; flex: 2; border: 2px solid red&#125;.box &#123; flex: 8; border: 2px solid red; display: flex; display: -webkit-flex /* Safari */&#125;.column &#123; flex: 1; border: 2px solid red; display: flex; display: -webkit-flex; /* Safari */ flex-direction: column&#125;.item &#123; flex: 1; border: 2px solid red; display: flex; display: -webkit-flex /* Safari */&#125;&lt;/style&gt;&lt;script&gt;import EchartsPie from &apos;@/components/EchartsPie.vue&apos;export default &#123; name: &apos;Recognition&apos;, props: &#123; breadcrumbObj: &#123; type: Object, default: () =&gt; null &#125; &#125;, components: &#123; EchartsPie &#125; &#125;&lt;/script&gt; 结果展示：接下来就可以插入各种组件来填充我们的页面了例如，把上上上篇博客刚刚讲完用Echarts构建的饼图组件放入页面中！","path":"2019/06/19/flex布局-基本页面结构/"},{"title":"Vue_CLI脚手架学习与搭建","text":"今天我们来学习一下Vue CLI脚手架，本文主要是总结Vue CLI脚手架搭建过程及总结遇到的问题，跟着我一起来学习吧~ 1.node.js安装与环境配置1.1 node.js安装 安装包下载地址：https://nodejs.org/en/ 下载完成后，双击node-v10.16.0-x64.msi，开始安装Node.js，全程默认一直点击下一步（注意：安装地址最后不要默认选择C盘，选择D盘），安装完毕后点击finish结束安装进程，然后在VS code终端，依次输入命令： 12node -vnpm -v 如果正确输出版本号，说明我们的NodeJS和NPM就安装好了，如下图所示： 此处说明下：新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西 1.2 node.js环境配置 说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到C:\\Users\\用户名\\AppData\\Roaming\\npm路径中，占C盘空间。 例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹D:\\software\\nodejs下创建两个文件夹node_global及node_cache如下图： 创建完两个空文件夹之后，打开终端窗口，输入12npm config set prefix \"D:\\software\\nodejs\\node_global\"npm config set cache \"D:\\software\\nodejs\\node_cache\" 接下来设置环境变量，控制面板-系统和安全-系统-高级系统设置-高级-环境变量 进入环境变量对话框，在系统变量下新建NODE_PATH，输入D:\\software\\nodejs\\node_global\\node_modules 将用户变量下的Path修改为D:\\software\\nodejs\\node_global修改前:修改后: 配置完后，安装个module测试下，我们就安装最常用的express模块，打开终端窗口， 输入如下命令进行模块的全局安装：npm install express - # -g是全局安装的意思修改后 可以看到express被安装到我们刚刚设置的路径下，就说明配置成功 2.Vue CLI安装与配置2.1 Vue CLI安装 可以使用下列任一命令安装这个新的包： 12npm install -g @vue/cliyarn global add @vue/cli 你还可以用这个命令来检查其版本是否正确 (3.x)：vue --version 2.2Vue CLI项目搭建2.2.1Vue CLI &gt;= 3时进行项目构建 我们安装的Vue CLI &gt;= 3，所以直接运行以下命令来创建一个新项目： 1vue create hello-world 你会被提示选取一个 preset。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性，这个默认的设置非常适合快速创建一个新项目的原型，而手动设置则提供了更多的选项，它们是面向生产的项目更加需要的。 在项目创建的过程中，你也会被提示选择喜欢的包管理器或使用淘宝 npm 镜像源以更快地安装依赖。这些选择也将会存入 ~/.vuerc 直接选取默认的设置就可以快速进行创建，就可以看到在安装各种插件，我们的项目正在下载搭建中： 再来试一个自定义安装的项目搭建，方向键上下移动，空格选中，Enter确定 再根据刚刚的选择会弹出来以下选框，按照自己需求进行选择 123456? Use history mode for router? //是否使用history模式的路由? Pick a CSS pre-processor //CSS预处理器选择? Pick a linter / formatter config: (Use arrow keys) //选择哪个ESLint自动化代码格式化检测? Pick additional lint features //选择语法检查的时期? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? //配置文件的存放位置? Save this as a preset for future projects? (y/N) //是否保存此预设(选择yes的话下次就可以不用进行配置) 出现以下界面说明项目搭建成功 安装后移动到目录 并启动，启动完毕后会提示我们浏览器访问地址12cd mydemo npm run serve // 这里和版本2不一样了。2是npm run dev 而版本3 是npm run serve 浏览器访问：http://localhost:8080/，效果如下： 2.2.2Vue CLI &lt; 3时，拉取 2.x 模板 (旧版本)进行项目构建 Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： 12npm install -g @vue/cli-init # `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同vue init webpack mydemo 然后终端会出现下图“一问一答”模式，如图： 这里有几个需要说明一下，没说明的直接回车选择默认就好，对项目没多大影响，很傻瓜式：Project name：这个是项目名称，默认是输入时的那个名称，想改的话直接输入修改，也可以直接回车Install vue-router:是否需要vue-router，默认选择使用，这样生成好的项目就会有相关的路由配置文件Use ESLint to lint your code:是否使用ESLint，刚才说了我们这个项目需要使用所以也是直接回车，默认使用，这样会生成相关的ESLint配置Setup unit tests with Karma + Moch?: 是否安装单元测试。由于我们现在还没有单元测试，所以这里选择的是”N”，而不是直接回车哦Setup e2e tests with Nightwatch：是否安装e2e测试，这里我也同样选择的是“N”这几个配置选择yes 或者 no 对于我们项目最大的影响就是，如果选择了yes 则生成的项目会自动有相关的配置，有一些loader我们就要配套下载。所以如果我们确定不用的话最好不要yes，要么下一步要下很多没有用的loader 全部选择好回车就进行了生成项目，现在打开之前说过的package.json文件，找到devDependencies 和 dependencies ，在这里面可以删掉我们不需要的，其他就则都需要使用 npm install 下载安装，例如vue： npm install vue –save-dev 1npm install 依赖包 运行mydemo，输入命令 1npm run dev 在浏览器输入地址http://localhost:8080，看到页面，说明大功告成，一个Vue项目已经初始化完成 2.2.3使用图形化界面进行项目构建 你也可以通过 vue ui 命令以图形化界面创建和管理项目： 1vue ui 上述命令会打开一个浏览器窗口，并以图形化界面将你引导至项目创建的流程。 2.3项目目录结构 通过vue-cli搭建一个vue项目，会自动生成一系列文件，而这些文件具体是怎样的结构、文件对应起什么作用，可以参考网上的解释，有了这个框架，接下来就可以根据自己的喜好来重新制定网站了 2.4修改端口号 vue-cli构建的项目，在控制台npm run dev启动后，默认的调试地址是8080端口的。但是大部分时候，我们都要并行几个项目开发，很有可能已经占用了8080端口，所以就涉及到如何去更改调试地址的端口号了 修改路径：2.x：config --&gt; index.js3.0+：node_modules--&gt;@vue--&gt;cli-service--&gt;lib--&gt;commands--&gt;build--&gt;serve.j","path":"2019/06/18/Vue-CLI脚手架学习与搭建/"},{"title":"自定义构建Echarts问题描述","text":"今天我们来学习一下Echarts，本文主要是总结自定义构建Echarts遇到的问题，跟着我一起来学习吧~ 1.使用命令行，创建自己的工程：12mkdir myProjectcd myProject 2.在 myProject 目录下使用命令行，初始化工程的 npm 环境并安装 echarts（这里前提是您已经安装了 npm）：12npm initnpm install echarts --save 3.使用 echarts 提供的构建脚本自定义构建在这个例子中，我们要创建一个饼图，并且想自定义构建一个只含有饼图的 echarts 文件，从而能使 echarts 文件的大小比较小一些。echarts 已经提供了构建脚本 echarts/build/build.js，基于 Node.js 运行。我们可以在 myProject 目录下使用命令行，看到它的使用方式：1node node_modules/echarts/build/build.js --help 注意：这里会出现报错1Error: Cannot find module 'XXX' 翻译出来就是找不到 ‘XXX’ 组件，我也是通过查找的方法，进行实践，缺啥就安装啥，可能会有很多的模块找不到，就一个一个进行安装就行，执行12npm install XXX --save//这里的 XXX 指的是报错中缺少的模块名 以上几个模块安装成功就会显示如下，你可以输入–help指令查看参数的含义：其中我们在这个例子里会用到的参数有： -i：代码入口文件，可以是绝对路径或者基于当前命令行路径的相对路径。 -o：生成的 bundle 文件，可以是绝对路径或者基于当前命令行路径的相对路径。 –min：是否压缩文件（默认不压缩），并且去多余的打印错误信息的代码，形成生产环境可用的文件。 –lang ：是否使用其他语言版本，默认是中文。例如：–lang en 表示使用英文，–lang my/langXX.js 表示构建时使用 /my/langXX.js 替代 echarts/lib/lang.js 文件。 –sourcemap：是否输出 source map，以便于调试。 –format：输出的格式，可选 ‘umb’（默认）、’amd’、’iife’、’cjs’、’es’。 4.既然我们想自定义构建一个只含有饼图的 echarts 文件，我们需要创建一个入口文件，可以命名为 myProject/echarts.custom.js，文件里会引用所需要的 echarts 模块：123456// 引入 echarts 主模块。export * from 'echarts/src/echarts';// 引入饼图。import 'echarts/src/chart/pie';// 在这个场景下，可以引用 `echarts/src` 或者 `echarts/lib` 下的文件（但是不可混用），// 参见下方的解释：“引用 `echarts/lib/**` 还是 `echarts/src/**`”。 5.然后我们可以在 myProject 目录下使用命令行，这样开始构建：1node node_modules/echarts/build/build.js --min -i echarts.custom.js -o lib/echarts.custom.min.js 注意：这里会出现报错1TypeError: uglifyPlugin is not a function 出错原因是依赖插件rollup-plugin-uglify版本过高，查看当前版本：1npm view rollup-plugin-uglify versions 重新npm install特定的版本：1npm install rollup-plugin-uglify@3.0.0 --save 这回就能构建成功了这样，myProject/lib/echarts.custom.min.js 就生成了。 6.我们可以创建 myProject/pie.html 来使用它：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;myProject&lt;/title&gt; &lt;!-- 引入 lib/echarts.custom.min.js --&gt; &lt;script src=\"lib/echarts.custom.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt; &lt;script&gt; // 绘制图表。 echarts.init(document.getElementById('main')).setOption(&#123; series: &#123; type: 'pie', data: [ &#123;name: 'A', value: 1212&#125;, &#123;name: 'B', value: 2323&#125;, &#123;name: 'C', value: 1919&#125; ] &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.运行程序，这样一个饼图就出来啦","path":"2019/06/15/自定义构建Echarts问题描述/"},{"title":"Echarts的学习与使用","text":"今天我们来学习一下Echarts，ECharts是一个纯JavaScript图表库，底层依赖于轻量级的Canvas类库ZRender，基于BSD开原协议，是一款非常优秀的可视化前端框架，本文基于Vue CLI脚手架，来实现Echarts的引用，跟着我一起来学习吧~ 一.引入一个简单的图表首先npm安装Echartsnpm install echarts --save 接下来打开public-&gt;src-&gt;main.js来引入echartsimport myCharts from &apos;./comm/js/myCharts.js&apos; Vue.use(myCharts) 绘制一个简单的容器&lt;template&gt; &lt;h-page-content&gt; &lt;div id=&quot;myChart&quot; :style=&quot;{width: &apos;600px&apos;, height: &apos;400px&apos;}&quot;&gt;&lt;/div&gt; &lt;/h-page-content&gt; &lt;/template&gt; 创建一个简单的图表你可以在这里查找样例echarts图表，注意：我们要在mounted生命周期函数中实例化echarts对象。因为我们要确保dom元素已经挂载到页面中 &lt;script&gt; export default { name: &apos;EchartsIndex&apos;, mounted () { this.drawLine() }, methods: { drawLine () { // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementById(&apos;myChart&apos;)) // 绘制图表 myChart.setOption({ title: { text: &apos;ECharts 入门示例&apos; }, tooltip: { trigger: &apos;item&apos;, formatter: &quot;{a} &lt;br/&gt;{b}: {c} ({d}%)&quot; }, legend: { orient: &apos;vertical&apos;, x: &apos;left&apos;, data:[&apos;直接访问&apos;,&apos;邮件营销&apos;,&apos;联盟广告&apos;,&apos;视频广告&apos;,&apos;搜索引擎&apos;] }, series: [{ name:&apos;访问来源&apos;, type:&apos;pie&apos;, radius: [&apos;50%&apos;, &apos;70%&apos;], avoidLabelOverlap: false, label: { normal: { show: false, position: &apos;center&apos; }, emphasis: { show: true, textStyle: { fontSize: &apos;30&apos;, fontWeight: &apos;bold&apos; } } }, labelLine: { normal: { show: false } }, data:[ {value:335, name:&apos;直接访问&apos;}, {value:310, name:&apos;邮件营销&apos;}, {value:234, name:&apos;联盟广告&apos;}, {value:135, name:&apos;视频广告&apos;}, {value:1548, name:&apos;搜索引擎&apos;} ] }] }) } } } &lt;/script&gt; 这样你的第一个图表就诞生了！ 接下来就可以根据自己的需求来自定义图表了 二.图表参数配置学习更多可以查看Echarts配置项手册 1.title标题组件，包含主标题和副标题。在 ECharts 2.x 中单个 ECharts 实例最多只能拥有一个标题组件。但是在 ECharts 3 中可以存在任意多个标题组件，这在需要标题进行排版，或者单个实例中的多个图表都需要标题时会比较有用。 title: { text: &apos;金融资产详情&apos;, //主标题 subtext: &apos;金融资产次级标题&apos; //副标题 } 2.tooltip提示框组件。提示框组件的通用介绍：提示框组件可以设置在多种地方： 可以设置在全局，即 tooltip 可以设置在坐标系中，即 grid.tooltip、polar.tooltip、single.tooltip 可以设置在系列中，即 series.tooltip 可以设置在系列的每个数据项中，即 series.data.tooltip tooltip: { trigger: &apos;item&apos;, //数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用 backgroundColor: &apos;rgb(245,245,245,0.9)&apos;, //设置提示框背景颜色 padding: [15, 20], //设置提示框内边距 textStyle: { color: &apos;#4F4F4F&apos; //设置提示框内字体颜色 }, extraCssText: &apos;box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);&apos; //额外附加到浮层的 css 样式，如为浮层添加阴影 } 3.legend图例组件。图例组件展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。ECharts 3 中单个 echarts 实例中可以存在多个图例组件，会方便多个图例的布局。当图例数量过多时，可以使用 滚动图例（垂直） 或 滚动图例（水平）。 legend: { bottom: 0, //设置图例组件离容器下侧的距离 left: &apos;center&apos;, //设置图例组件离容器左侧的距离 icon: &apos;circle&apos;, //设置图例组件图标为圆形 textStyle: { color: &apos;#4F4F4F&apos;, //设置图例组件字体颜色 fontSize: &apos;14&apos; //设置图例组件字体大小 }, hoverAnimation: false, //是否开启 hover 在扇区上的放大动画效果 data: [&apos;存款余额&apos;, &apos;活期余额&apos;, &apos;定期余额&apos;, &apos;通知存款余额&apos;, &apos;贷款余额&apos;, &apos;理财余额&apos;, &apos;国债余额&apos;, &apos;基金余额&apos;] //图例的数据数组 } 4.color设置数据区域颜色。 color: [&apos;#1E90FF&apos;, &apos;#40E0D0&apos;, &apos;#43CD80&apos;, &apos;#EEC900&apos;, &apos;#FF6A6A&apos;, &apos;#9B30FF&apos;, &apos;#3A5FCD&apos;, &apos;#27408B&apos;] 5.series系列列表。每个系列通过 type 决定自己的图表类型。 series: [{ // name: &apos;&apos;, type: &apos;pie&apos;, radius: [&apos;30%&apos;, &apos;50%&apos;], //设置饼图半径 selectedMode: &apos;single&apos;, //选中模式，表示是否支持多个选中，默认关闭 hoverAnimation: false, //是否开启 hover 在扇区上的放大动画效果 label: { normal: { textStyle: { fontSize: &apos;14&apos;, //设置饼图文字格式 color: &apos;#4F4F4F&apos; //设置饼图文字颜色 }, formatter: function (data) { return data.name + &apos; : &apos; + data.percent.toFixed(2) + &apos; % &apos; //用来格式化引出文字文本，支持字符串模板和回调函数两种形式，保留两位小数 } } }, labelLine: { smooth: true //是否平滑视觉引导线，默认不平滑 }, data: [ //系列中的数据内容数组 { value: 982, name: &apos;存款余额&apos; }, { value: 968, name: &apos;活期余额&apos; }, { value: 1332, name: &apos;定期余额&apos; }, { value: 2034, name: &apos;通知存款余额&apos; }, { value: 2582, name: &apos;贷款余额&apos; }, { value: 1403, name: &apos;理财余额&apos; }, { value: 0, name: &apos;国债余额&apos; }, { value: 701, name: &apos;基金余额&apos; } ], itemStyle: { normal: { borderWidth: 2, //设置描边线宽 borderColor: &apos;white&apos; //设置描边颜色 }, emphasis: { //图形的高亮样式 shadowColor: &apos;rgba(0, 0, 0, 0.5)&apos; // 文字块的背景阴影颜色 } } }] 详细的学习教程可以参考Echarts学习网址","path":"2019/06/08/Echarts的学习与使用/"},{"title":"flex布局排布","text":"作为前端必备知识点，flex为我们页面布局提供了灵活性，今天我们来学一下flex布局吧~ 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局，行内元素也可以使用Flex布局， Webkit内核的浏览器，必须加上-webkit前缀。123.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125;注意：设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、Flex布局基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end； 交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上： flex-direction：决定主轴的方向 flex-wrap：定义如果一条轴线排不下，如何换行 flex-flow：是flex-direction属性和flex-wrap属性的简写形式 justify-content：定义了项目在主轴上的对齐方式 align-items：定义项目在交叉轴上如何对齐 align-content：定义了多根轴线的对齐方式。 3.1 flex-direction属性决定主轴的方向（即项目的排列方向）123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 3.2 flex-wrap属性决定如何换行123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认）：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 3.3 flex-flow属性是flex-direction和flex-wrap的简写形式，默认值为row nowrap123.box &#123;flex-flow: &amp;lt;flex-direction&amp;gt; &amp;lt;flex-wrap&amp;gt;;&#125; 3.4 justify-content属性定义了项目在主轴上的对齐方式123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性定义项目在交叉轴上如何对齐12.box &#123;align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性定义了多根轴线的对齐方式，会以多行作为整体进行对齐，容器必须开启换行，若项目只有一根轴线，该属性不起作用12.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上： order：定义项目的排列顺序 flex-grow：定义项目的放大比例 flex-shrink：定义了项目的缩小比例 flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size） flex：是flex-grow, flex-shrink 和 flex-basis的简写 align-self：允许单个项目有与其他项目不一样的对齐方式 4.1 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0；值相同时，以dom中元素排列为准123.item &#123; order: &amp;lt;integer&amp;gt;;&#125; 4.2 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &amp;lt;number&amp;gt;; /* default 0 */&#125; 元素放大的计算方法放大的计算方法将元素大小纳入考虑。仅仅按flex-grow声明的份数算出每个需分配多少，叠加到原来的尺寸上。 容器剩余宽度：50px 分成每份：50px / (3+2) = 10px 元素1放大为：50px + 3 * 10 = 80px所以如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。当弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论flex-grow是什么值都不会生效 4.3 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。12.item &#123; flex-shrink: &amp;lt;number&amp;gt;; /* default 1 */&#125; 元素收缩的计算方法来看下以下场景，弹性容器#container宽度是200px，一共有三个弹性元素，宽度分别是50px、100px、120px。 真的是等比缩小(每个元素各减去70/3的宽度)吗？ 弹性元素1：50px→37.03px 弹性元素2：100px→74.08px 弹性元素3：120px→88.89px 先抛结论：flex-shrink: 1并非严格等比缩小，它还会考虑弹性元素本身的大小。 容器剩余宽度：-70px 缩小因子的分母：1*50 + 1*100 + 1*120 = 270 (1为各元素flex-shrink的值) 元素1的缩小因子：1*50/270 元素1的缩小宽度为缩小因子乘于容器剩余宽度：1*50/270 * (-70) 元素1最后则缩小为：50px + (1*50/270 *(-70)) = 37.03px 加入弹性元素本身大小作为计算方法的考虑因素，主要是为了避免将一些本身宽度较小的元素在收缩之后宽度变为0的情况出现。所以如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &amp;lt;length&amp;gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 与width/height的区别： (1)两者都为0：width: 0 —— 完全没显示；flex-basis: 0 —— 根据内容撑开宽度 (2) 两者非0： 数值相同时两者等效； 同时设置，flex-basis优先级高 (3) flex-basis为auto：flex-basis为auto时，如设置了width则元素尺寸由width决定；没有设置则由内容决定 (4) flex-basis == 主轴上的尺寸 != width：将主轴方向改为：上→下，此时主轴上的尺寸是元素的height，flex-basis == height 4.5 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &amp;lt;&apos;flex-grow&apos;&amp;gt; &amp;lt;&apos;flex-shrink&apos;&amp;gt;? || &amp;lt;&apos;flex-basis&apos;&amp;gt; ]&#125; 一些简写：flex: 1 = flex: 1 1 0%flex: 2 = flex: 2 1 0%flex: auto = flex: 1 1 auto;flex: none = flex: 0 0 auto; // 常用于固定尺寸 不伸缩 flex:1 和 flex:auto 的区别其实可以归结于flex-basis:0和flex-basis:auto的区别。flex-basis是指定初始尺寸，当设置为0时（绝对弹性元素），此时相当于告诉flex-grow和flex-shrink在伸缩的时候不需要考虑我的尺寸；相反当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。因此从下图（转自W3C）可以看到绝对弹性元素如果flex-grow值是一样的话，那么他们的尺寸一定是一样的。两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。更多内容参考：https://www.runoob.com/w3cnote/flex-grammar.htmlhttps://www.cnblogs.com/qcloud1001/p/9848619.htmlhttp://www.ruanyifeng.com/blog/2015/07/flex-examples.html","path":"2019/05/25/flex布局排布/"},{"title":"VScode快捷键及常用插件","text":"VScode快捷键：https://blog.csdn.net/hypon2016/article/details/80831266 VScode快捷键： Auto Close Tag ：自动闭合 HTML/XML 标签 Auto Rename Tag ：自动重命名成对的 HTML/XML 标签 Babel ES6/ES7 ： 添加 ES6/ES7 语法的颜色提醒 Canvas Snippets ：Canvas 代码片段提示 Bracket Pair Colorizer ：多层括号颜色匹配 CSS peek ：可直接在 HTML 中查看 class、id 对应的 CSS 样式，并可以直接跳转 Document This ： JSDoc comments for both TypeScript and JavaScript filesize ：编辑器左下角显示文件大小 git history、gitlens ： git 使用必备，能够图形化显示 git 历史、编辑人物等 HTML CSS support ： HTML、CSS 快捷操作 HTML Snippets ： HTML 代码片段 Htmltagwrap ： 选中代码快速增加 html 标签 - alt + w Image Preview ： 代码中直接显示图片缩略图 Import Cost ：显示 import、require 引用的包的大小 JavaScript (ES6) snippets ：ES6 代码片段 JavaScript Snippet Pack ：ES5 代码片段 npm ：npm 支持 one dark pro ：主题风格 Open in Browser ：alt + B, 直接在浏览器打开文件 Prettier formatter ：超好用的格式化插件 Vetur、vue 2 snippets、vscode-element-helper ：提高 vue 效率的插件 vscode-icons ：给各个文件类型增加图标 Indenticator ： 高亮当前代码层级 Bracket Pair Colorizer ： 括号匹配颜色提示 Color Info ：CSS 颜色显示 Comment V ：添加 JS 注释（个性版） Background ：编辑区域背景萌萌哒 File peek ： 直接在 javascript、typescript 中查看选中区域的缩略图，并可以直接跳转 Log File Highlighter ：控制台输出信息美化 vscode-fileheader ：在文件头部添加注释信息，可在 setting.json 中自定义信息 Markdown Preview Enhanced ：markdown 直接显示 Node.js Modules Intellisense ：自动补充 node modules 输入路径","path":"2019/05/21/VScode快捷键及常用插件/"},{"title":"如何禁止chrome浏览器http自动转成https【转】","text":"转载自：https://www.cnblogs.com/zhanglianghhh/p/9706852.html Chrome浏览器阻止跨域配置：–disable-web-security –user-data-dir=C:\\ChromeDebug 自动跳转原因将HTTP请求自动转为HTTPS请求是浏览器的默认策略。当浏览器访问过某个HTTPS的网站后，再访问该网站时，一切HTTP请求会自动转为HTTPS请求。HTTP转为HTTPS的主要原因是为了安全。 Chrome 浏览器1. 地址栏中输入 chrome://net-internals/#hsts 2. 在 Delete domain security policies 中输入项目的域名，并 Delete 删除 3. 可以在 Query domain 测试是否删除成功 这里如果还是不行， 请清除浏览器缓存！ 参考文章 :如何关闭浏览器的HSTS功能 Safari 浏览器1. 完全关闭 Safari 2. 删除 ~/Library/Cookies/HSTS.plist 这个文件 3. 重新打开 Safari 即可 4. 极少数情况下，需要重启系统 Opera 浏览器和 Chrome 方法一样Firefox 浏览器 1. 关闭所有已打开的页面 2. 清空历史记录和缓存 3. 地址栏输入 about:permissions 4. 搜索项目域名，并点击 Forget About This Site","path":"2019/05/21/如何禁止chrome浏览器http自动转成https【转】/"},{"title":"Vue.js学习笔记Day5-5.08","text":"Vue.js学习笔记Day5-5.08今日主要学习内容： 复习父子组件传值问题； watch、computed和methods之间的对比； nrm的安装使用； Webpack的概念； 使用vue实例的render方法渲染组件； 在普通页面中使用render函数渲染组件； export default 和 export 使用方式； 在vue组件页面中，集成vue-router路由模块； 组件中css作用域问题（scoped属性） 开始Vue框架的学习吧～ 一、复习父子组件传值问题&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;com1 v-bind:parentmsg=&quot;msg&quot; @func=&quot;getMsgFromSon&quot;&gt;&lt;/com1&gt; &lt;/div&gt; &lt;template id=&quot;tmp1&quot;&gt; &lt;div&gt; &lt;h1&gt;这是子元素---{{parentmsg}}&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;向父组件传递消息&quot; @click=&quot;sendMsg&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var com1 = { template: &apos;#tmp1&apos;, data(){ return { msg:&apos;孝顺的孩子&apos; } }, props: [&apos;parentmsg&apos;], methods:{ sendMsg(){ this.$emit(&apos;func&apos;,this.msg) } } } //创建Vue实例，得到ViewModel var vm = new Vue({ el: &apos;#app&apos;, data:{ msg: &apos;父组件中的数据&apos;, msgFromSon: &apos;&apos; }, methods:{ getMsgFromSon(data){ this.msgFromSon = data console.log(this.msgFromSon) } }, components:{ com1 } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 二、名称案例2.1使用keyup事件实现&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 分析 --&gt; &lt;!-- 1.我们要监听到文本框数据的改变，这样才知道什么时候去拼接出一个fullname --&gt; &lt;!-- 2.如何监听到文本框的数据改变 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot; @keyup=&quot;getFullName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot; @keyup=&quot;getFullName&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { firstname:&apos;&apos;, lastname:&apos;&apos;, fullname:&apos;&apos; }, methods: { getFullName(){ this.fullname = this.firstname + &apos;-&apos; + this.lastname } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.2、watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { firstname:&apos;&apos;, lastname:&apos;&apos;, fullname:&apos;&apos; }, methods: {}, watch: { // 使用这个属性，可以监视data中指定数据的变化，然后触发这个watch中对应的function处理函数 &apos;firstname&apos;:function(newVal,oldVal){ this.fullname = newVal + &apos;-&apos; + this.lastname }, &apos;lastname&apos;:function(newVal,oldVal){ this.fullname = this.firstname + &apos;-&apos; + newVal } }, }); &lt;/script&gt; 监听路由对象的改变： &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登陆&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; // 2.创建子组件 var login = { template:&apos;&lt;h3&gt;登陆子组件&lt;/h3&gt;&apos; } var register = { template:&apos;&lt;h3&gt;注册子组件&lt;/h3&gt;&apos; } // 3.创建一个路由对象 var router = new VueRouter({ routes:[ //路由规则数组 {path:&apos;/&apos;,redirect:&apos;/login&apos;}, {path:&apos;/login&apos;,component: login}, {path:&apos;/register&apos;,component: register}, ], linkActiveClass:&apos;myactive&apos; // 激活相关的类 }) var vm = new Vue({ el:&apos;#app&apos;, data:{}, methods:{}, // router: router router, watch:{ &apos;$route.path&apos;:function(newVal,oldVal){ console.log(newVal + &apos;---&apos; + oldVal) if (newVal === &apos;/login&apos;) { console.log(&apos;欢迎进入登陆界面&apos;); } else if (newVal === &apos;/register&apos;) { console.log(&apos;欢迎进入注册界面&apos;); } } } }) &lt;/script&gt; 2.3、computed计算属性的使用 默认只有getter的计算属性： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;p&gt;{{ fullname }}&lt;/p&gt; &lt;p&gt;{{ fullname }}&lt;/p&gt; &lt;p&gt;{{ fullname }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { firstname:&apos;&apos;, lastname:&apos;&apos; }, methods: {}, computed: { &apos;fullname&apos;:function(){ console.log(&apos;ok&apos;); return this.firstname + &apos;-&apos; + this.lastname } } }); &lt;/script&gt; 注意：在computed中可以定义一些计算属性，计算属性的本质就是一个方法，只不过我们在使用这些计算属性的时候，是把他们的名称直接当作属性来使用的，并不会把计算属性当作方法来调用 计算属性再引用的时候，不要加()去调用，直接把它当普通属性去调用 只要计算属性function内部所用到的任何data中的数据发生变化，就会重新计算这个计算属性的值 计算属性的求职结果，会被缓存起来，方便下次直接使用，如果计算属性方法中，所有来的任何数据，都没有发生过变化，则不会对计算属性求值，如上例，虽然引用了三次fullname，但只输出一次‘ok’ 定义有getter和setter的计算属性： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt; &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { firstName: &apos;jack&apos;, lastName: &apos;chen&apos; }, methods: { changeName() { this.fullName = &apos;TOM - chen2&apos;; } }, computed: { fullName: { get: function () { return this.firstName + &apos; - &apos; + this.lastName; }, set: function (newVal) { var parts = newVal.split(&apos; - &apos;); this.firstName = parts[0]; this.lastName = parts[1]; } } } }); &lt;/script&gt; 2.4、watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； 三、nrm的安装使用 作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址； 什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 注意：nrm只是提供了几个常用的下载包的URL，并能够让我们在这几个地址间很方便地进行切换，但是我们每次装包的时候，使用的工具都是npm 四、Webpack的概念4.1 Webpack引入原因1. 在网页中会引用哪些常见的静态资源？ JS.js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS.css .less .sass .scss Images.jpg .png .gif .bmp .svg 字体文件（Fonts）.svg .ttf .eot .woff .woff2 模板文件.ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 2. 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系（比如bootstrap依赖于jQuery） 3. 如何解决上述两个问题合并、压缩、精灵图、图片的Base64编码可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 4.2 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程webpack官网 webpack安装的两种方式 运行cnpm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行cnpm i webpack --save-dev安装到项目依赖中 4.3 初步使用webpack打包构建列表隔行变色案例 创建项目基本的目录结构 运行cnpm init初始化项目，使用npm管理项目中的依赖包 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑： // 1.导入Jquery import $ from &apos;jquery&apos; const $ = require(&apos;jquery&apos;) $(function(){ $(&apos;li:odd&apos;).css(&apos;backgroundColor&apos;,&apos;lightblue&apos;) $(&apos;li:even&apos;).css(&apos;backgroundColor&apos;,function(){ return&apos;#&apos; + &apos;FF6900&apos; }) }) 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；运行webpack 入口文件路径 输出文件路径对main.js进行处理： webpack .\\src\\main.js .\\dist\\bundle.js 问题处理： 警告 警告：WARNING in configuration The &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for this value. Set &apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults for each environment. You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ 原因是：没有设置webpack的模式，是生产还是开发（production or development） 执行命令：webpack –mode=production 或者 webpack –mode=development 也可以在package.json中进行修改 &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack –mode development&quot;, &quot;build&quot;: &quot;webpack –mode production&quot; } 错误 错误：ERROR in multi ./src/main.js ./dist/bundle.js Module not found: Error: Can&apos;t resolve &apos;.\\dist\\bundle.js&apos; in &apos;D:\\lichang\\Vue_CLI\\Vue\\Day5\\webpack-study&apos; @ multi ./src/main.js ./dist/bundle.js main[1] 原因：目前使用的的webpack版本过高,原来的命令已经不适用了，换成指令 webpack .\\src\\main.js -o .\\dist\\bundle.js --mode development 总结：经过演示，webpack可以做哪些事情 webpack能够处理js间互相依赖关系 webpack能够处理js兼容问题，把高级的浏览器不识别的语法转为低级的浏览器能识别的语法 刚才运行的命令格式：webpack 要打包的文件路径 打包好要输出的文件路径 4.4 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径： 经过配置文件设置、直接使用命令webpack即可进行打包 // 导入处理路径的模块 const path = require(&apos;path&apos;) // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理 module.exports = { entry: path.join(__dirname, &apos;./src/main.js&apos;), // 项目入口文件 output: { // 配置输出选项 path: path.join(__dirname, &apos;./dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 } } 总结：当我们在控制台执行webpack命令时，webpack做了以下几步： 首先，我们并没有通过命令的形式，给它指定入口和出口 webpack就回去项目的根目录中，查找一个叫做webpack.config.js的配置文件 当找到配置文件后，webpack会去执行解析这个配置文件，当解析完这个配置文件后，就得到了配置文件中导出的配置对象 当webpack拿到配置对象后，就拿到了配置对象中指定的入口和出口，然后进行打包构建 4.5 使用webpack-dev-serve实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server -D安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在package.json文件的scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令 接下来运行npm run dev即可进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 此时在http://localhost:8080/ 网站是无法看到bundle.js文件的，说明webpack-dev-server并没有将打包好的bundle.js存放到实际的物理磁盘上，而是托管到电脑的内存中，所以我们在项目根目录中，根本找不到打包好的bundle.js 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为: 4.6 webpack-dev-serve常用命令参数方式1： 修改package.json的script节点如下，其中 –open表示自动打开浏览器 –port 4321表示打开的端口号为4321 –hot表示启用浏览器热更新 –contentBase src指定启动的根目录 &quot;dev&quot;: &quot;webpack-dev-server --contentBase src --hot --port 4321 --open&quot; 注意：热更新用来进行减少不必要的代码更新，每次重新编译只会更新修改过的文件（相当于打补丁）热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明 方式2： 修改webpack.config.js文件，新增devServer节点如下： devServer:{ //相对来说方法2麻烦一些，了解即可 hot:true, //启用热更新第一步 open:true, port:4321, contentBase:&apos;src&apos; } 在头部引入webpack模块： var webpack = require(&apos;webpack&apos;); // 启用热更新第二步 在plugins节点下新增： plugins:[ //配置插件的节点 new webpack.HotModuleReplacementPlugin() //启用热更新第三步 ] 4.7使用html-webpack-plugin插件配置启动页面由于使用–contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin -D安装到开发依赖 修改webpack.config.js配置文件如下： // 导入处理路径的模块 var path = require(&apos;path&apos;); // 导入自动生成HTMl文件的插件 var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); module.exports = { entry: path.resolve(__dirname, &apos;src/js/main.js&apos;), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, &apos;dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 }, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin({ template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径 filename:&apos;index.html&apos;//自动生成的HTML文件的名称 }) ] } 修改package.json中script节点中的dev指令如下： &quot;dev&quot;: &quot;webpack-dev-server&quot; html-webpack-plugin插件两个作用： 自动在内存中根据指定页面生成一个内存的页面 自动把打包好的bundle.js文件追加到页面中去，我们不再需要手动处理bundle.js的引用路径了，所以可以将index.html中script标签注释掉！ 4.8使用webpack处理第三方类型webpack默认只能处理js类型的文件，无法处理其他的非js类型的文件，如果需要非JS类型的文件，我们需要手动安装一些合适的第三方loader加载器 webpack处理第三方文件类型的过程： 发现这个要处理的文件不是js文件，然后就去配置文件中，查找有没有对应的第三方loader规则 如果能找到对应的规则，就会调用相应的loader处理这种文件类型 在调用loader的时候，是从后往前调用的 当最后一个loader调用完毕，会把处理结果，交给webpack进行打包合并，最终输出到bundle.js中去 4.8.1使用webpack打包css文件 新建index.css文件 在main.js引入index.css import &apos;./css/index.css&apos; 如果要打包处理css文件，需要安装cnpm i style-loader css-loader -D 打开webpack.config.js这个配置文件，在里面新增一个配置节点叫module，它是一个对象，在这个module对象上有一个rules属性，是个数组，这个数组中存放了所有第三方文件的匹配和处理规则 module: { // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 { test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] }//处理css文件的规则 ] } 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的 4.8.2使用webpack打包less文件 新建index.less文件 在main.js引入index.less import &apos;./css/index.less&apos; 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件的module节点： { test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] }, 4.8.3使用webpack打包sass文件 新建index.scss文件 在main.js引入index.scss import &apos;./css/index.scss&apos; 运行cnpm i sass-loader node-sass -D 在webpack.config.js中添加处理sass文件的loader模块： { test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] } 4.8.4使用webpack处理css中的路径 运行cnpm i url-loader file-loader -D 在webpack.config.js中添加处理url路径的loader模块： { test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader&apos; } 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码；通过[hash:8]来设置留八位hash编码，[name]用来保留原来的照片名，[ext]用来保留原来的后缀名 { test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=43960&amp;name=[hash:8]-[name].[ext]&apos; }, 4.8.5使用webpack处理字体文件 在main.js引入bootstrap.css import &apos;bootstrap/dist/css/bootstrap.css&apos; 运行安装cnpm i bootstrap -S 在webpack.config.js中添加处理字体文件的loader模块： { test: /\\.(svg|ttf|eot|woff|woff2)$/, use: &apos;url-loader&apos; } 注意：遇到安装完bootstrap无法显示字体的现象，原因是版本问题，默认安装最新版本4.3.1，手动改为3.4.1版本即可 cnpm i bootstrap@3.4.1-D 4.8.6使用babel处理高级JS语法 在 webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中，通过 Babel ，可以帮我们将 高级的语法转换为低级的语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime -D安装babel的相关loader包 运行cnpm i babel-preset-env babel-preset-stage-0 -D安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项： { test: /\\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ } 注意： 在配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉：原因有俩： 如果 不排除 node_modules， 则Babel 会把 node_modules 中所有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢； 哪怕，最终，Babel 把 所有 node_modules 中的JS转换完毕了，但是，项目也无法正常运行！ 在项目根目录中添加.babelrc文件，并修改这个配置文件如下： { &quot;presets&quot;:[&quot;env&quot;, &quot;stage-0&quot;], &quot;plugins&quot;:[&quot;transform-runtime&quot;] } 了解： 目前，我们安装的 babel-preset-env, 是比较新的ES语法， 之前， 我们安装的是 babel-preset-es2015, 现在，出了一个更新的 语法插件，叫做 babel-preset-env ，它包含了 所有的 和 es***相关的语法 问题描述： Error: Cannot find module &apos;@babel/core&apos; babel-loader@8 requires Babel 7.x (the package &apos;@babel/core&apos;). If you&apos;d like to use Babel 6.x (&apos;babel-core&apos;), you should install &apos;babel-loader@7&apos;. 最初以为是babel-core没有安装上。重装了好几遍babel-core还是不行。对照以前的项目,发现babel-loader的版本不一样,之前的是@7.1.5版本,而现在是@8.0.0版本。 cnpm install babel-loader@7.1.5 -D 五、使用vue实例的render方法渲染组件 在页面中渲染基本的组件 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;33333&lt;/p&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;这是登录组件&lt;/h1&gt;&apos; } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, components: { login } }); &lt;/script&gt; &lt;/body&gt; 在页面中使用render函数渲染组件 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;444444&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;这是登录组件&lt;/h1&gt;&apos; } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, render: function (createElements) { // createElements 是一个 方法，调用它，能够把 指定的 组件模板，渲染为 html 结构 return createElements(login) // 注意：这里 return 的结果，会 替换页面中 el 指定的那个 容器 } }); &lt;/script&gt; &lt;/body&gt; 两者区别：使用render函数渲染的组件直接替换整个div模块，所以不会再显示p标签444444，而在页面中直接导入组件则不会替换掉div整个模块的内容，两者区别相当于v-text和差值表达式的区别 六、在普通页面中使用render函数渲染组件在webpack中配置.vue组件页面的解析 运行cnpm i vue -S将vue安装为运行依赖； 注意： 在 webpack 中， 使用 import Vue from &#39;vue&#39;导入的 Vue 构造函数，功能不完整，只提供了 runtime-only 的方式，并没有提供 像网页中那样的使用方式； 在使用webpack构建的Vue项目中使用模板对象解决方法： 在main.js中引入import Vue from &#39;vue&#39;，查看node_modules-vue-package.json文件，可以看到我们目前引入的是vue.runtime.common.js，把这个路径换成指向vue.js文件（不提倡） 直接在main.js引入import Vue from ‘../node_modules/vue/dist/vue.js’（不提倡） 在main.js中引入import Vue from ‘vue’，在webpack.config.js中添加resolve属性 默认，webpack 无法打包 .vue 文件，需要安装 相关的loader，运行cnpm i vue-loader vue-template-compiler -D将解析转换vue的包安装为开发依赖； 运行cnpm i style-loader css-loader -D将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式； 在webpack.config.js配置文件中，添加如下module规则： module: { rules: [ { test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] }, { test: /\\.vue$/, use: &apos;vue-loader&apos; } ] } 创建App.js组件页面： &lt;template&gt; &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt; &lt;div&gt; &lt;h1&gt;这是APP组件 - {{msg}}&lt;/h1&gt; &lt;h3&gt;我是h3&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象 export default { data() { return { msg: &apos;OK&apos; } } } &lt;/script&gt; &lt;style scoped&gt; h1 { color: red; } &lt;/style&gt; 创建main.js入口文件： // 导入 Vue 组件 import Vue from &apos;vue&apos; // 导入 App组件 import App from &apos;./components/App.vue&apos; // 创建一个 Vue 实例，使用 render 函数，渲染指定的组件 var vm = new Vue({ el: &apos;#app&apos;, render: c =&gt; c(App) }); 注意：render: c =&gt; c(App)是下式的缩写 render: function (createElements) { return createElements(App) } 复习 在普通网页中如何使用vue：1. 使用 script 标签 ，引入 vue 的包 2. 在 index 页面中，创建 一个 id 为 app div 容器 3. 通过 new Vue 得到一个 vm 的实例 回顾 包的查找规则：1. 找 项目根目录中有没有 node_modules 的文件夹 2. 在 node_modules 中 根据包名，找对应的 vue 文件夹 3. 在 vue 文件夹中，找 一个叫做 package.json 的包配置文件 4. 在 package.json 文件中，查找 一个 main 属性【main属性指定了这个包在被加载时候，的入口文件】 七、export default 和 export 使用方式 ES6中导入模块，使用 import 模块名称 from ‘模块标识符’ import ‘表示路径’，使用 export default 和 export 向外暴露成员；在Node中 使用 var 名称 = require(‘模块标识符’)，module.exports 和 exports 来暴露成员，两套方法不可混用 export default 和 export的区别： var info = { name: &apos;zs&apos;, age: 20 } export default info /* export default { address: &apos;北京&apos; } */ // 注意： export default 向外暴露的成员，可以使用任意的变量来接收 // 注意： 在一个模块中，export default 只允许向外暴露1次 // 注意： 在一个模块中，可以同时使用 export default 和 export 向外暴露成员 export的引用方式： export var title = &apos;小星星&apos; export var content = &apos;哈哈哈&apos; // 注意： 使用 export 向外暴露的成员，只能使用 { } 的形式来接收，这种形式，叫做 【按需导出】 // 注意： export 可以向外暴露多个成员， 同时，如果某些成员，我们在 import 的时候，不需要，则可以 不在 {} 中定义 // 注意： 使用 export 导出的成员，必须严格按照 导出时候的名称，来使用 {} 按需接收； // 注意： 使用 export 导出的成员，如果 就想 换个 名称来接收，可以使用 as 来起别名； 使用 import from 和 import ‘路径’ 还有 import {a, b} from ‘模块标识’ 导入其他模块 import m222, { title as title123, content } from &apos;./test.js&apos; console.log(m222) console.log(title123 + &apos; --- &apos; + content) 八、在vue组件页面中，集成vue-router路由模块vue-router官网 cnpm install vue-router 导入路由模块： import Vue from &apos;vue&apos; import VueRouter from &apos;vue-router&apos; 安装路由模块： Vue.use(VueRouter); 导入需要展示的组件: import login from &apos;./components/account/login.vue&apos; import register from &apos;./components/account/register.vue&apos; 创建路由对象: var router = new VueRouter({ routes: [ { path: &apos;/&apos;, redirect: &apos;/login&apos; }, { path: &apos;/login&apos;, component: login }, { path: &apos;/register&apos;, component: register } ] }); 将路由对象，挂载到 Vue 实例上: var vm = new Vue({ el: &apos;#app&apos;, // render: c =&gt; { return c(App) } render(c) { return c(App); }, router // 将路由对象，挂载到 Vue 实例上 }); 改造App.vue组件，在 template 中，添加router-link和router-view： &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; 九、组件中css作用域问题（scoped属性） 普通的style标签，只支持普通的样式，如果想要启用scss或者less，需要为style元素设置lang属性 &lt;style lang=&quot;scss&quot; scoped&gt; 只要是style标签，是在.vue组件中定义的，那么推荐都为style开启scoped属性，可以防止组件间样式相互干扰，样式的scoped属性是通过css的属性选择器实现的","path":"2019/05/08/Vue-js学习笔记Day5-5-08/"},{"title":"Vue.js学习笔记Day4-5.06","text":"Vue.js学习笔记Day4-5.06今日主要学习内容： 使父组件向子组件传值； 子组件向父组件传值； 评论列表案例； 使用 this.$refs 来获取元素和组件； 什么是路由； 设置路由高亮； 设置路由高亮设置路由切换动效； 在路由规则中定义参数； 使用 children 属性实现路由嵌套； 命名视图实现经典布局； 开始Vue框架的学习吧～ 一、使父组件向子组件传值父组件向子组件传递数据：子组件在父组件的并作为标签引入，通过设置标签的属性传递数据，在子组件用props接受，例如下面这样，父组件parent.vue引入子组件child.vue，将父组件的数据name通过设置标签child的name属性传递给子组件，子组件通过props传递接受，接受后，在子组件内this.name就是父组件的name数据。 1. 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { msg: &apos;123 啊-父组件中的数据&apos; }, methods: {}, components: { // 结论：经过演示，发现，子组件中，默认无法访问到 父组件中的 data 上的数据 和 methods 中的方法 com1: { data() { // 注意： 子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上； // data 上的数据，都是可读可写的； return { title: &apos;123&apos;, content: &apos;qqq&apos; } }, template: &apos;&lt;h1 @click=&quot;change&quot;&gt;这是子组件 --- {{ parentmsg }}&lt;/h1&gt;&apos;, // 注意： 组件中的 所有 props 中的数据，都是通过 父组件传递给子组件的 // props 中的数据，都是只读的，无法重新赋值 props: [&apos;parentmsg&apos;], // 把父组件传递过来的 parentmsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据 directives: {}, filters: {}, components: {}, methods: { change() { this.parentmsg = &apos;被修改了&apos; } } } } }); &lt;/script&gt; data和props中数据的差别：1）子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上；props 中的数据，都是通过 父组件传递给子组件的2）data 上的数据，都是可读可写的；props 中的数据，都是只读的，无法重新赋值 2. 使用v-bind或简化指令，将数据传递到子组件中：父组件，可以在引用子组件的时候， 通过`属性绑定（v-bind:）`的形式, 把 需要传递给 子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 &lt;div id=&quot;app&quot;&gt; &lt;!-- 父组件，可以在引用子组件的时候， 通过 属性绑定（v-bind:） 的形式, 把 需要传递给 子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 --&gt; &lt;com1 v-bind:parentmsg=&quot;msg&quot;&gt;&lt;/com1&gt; &lt;/div&gt; 二、子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; 父组件向子组件 传递 方法，使用的是 事件绑定机制； v-on, 当我们自定义了一个事件属性之后，那么子组件就能够通过某些方式，来调用传递进去的这个方法了 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 &lt;div id=&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;com2 @func=&quot;show&quot;&gt;&lt;/com2&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是 子组件&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;这是子组件中的按钮 - 点击它，触发 父组件传递过来的 func 方法&quot; @click=&quot;myclick&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 定义了一个字面量类型的 子组件模板对象 var com2 = { template: &apos;#tmpl&apos;, // 通过指定了一个 Id, 表示 说，要去加载 这个指定Id的 template 元素中的内容，当作 组件的HTML结构 data() { return { sonmsg: { name: &apos;小头儿子&apos;, age: 6 } } }, methods: { myclick() { // 当点击子组件的按钮的时候，如何 拿到 父组件传递过来的 func 方法，并调用这个方法？？？ // emit 英文原意： 是触发，调用、发射的意思 // this.$emit(&apos;func123&apos;, 123, 456) this.$emit(&apos;func&apos;, this.sonmsg) } } } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { datamsgFormSon: null }, methods: { show(data) { // console.log(&apos;调用了父组件身上的 show 方法: --- &apos; + data) // console.log(data); this.datamsgFormSon = data } }, components: { com2 // com2: com2 } }); &lt;/script&gt; 兄弟组件传递数据eventBus同级传参或者隔级传参可以用eventBus（事件车），内部也是发布订阅模式实现的，适合于非常简单的小项目，一般不用(互相帮)中间键思想 :创建一个vue的实例,然后给每个子组件绑定一个方法(触发时候发布eventBus),在 每个子组件做一个订阅的监控,触发绑在created里的方法执行,靠传递参数的不同实现同步数据 (颜色) 三、评论列表案例目标：主要练习父子组件之间传值 发表评论的方法：分析：发表评论的业务逻辑 评论数据存到哪里去？？？ 存放到了 localStorage 中 localStorage.setItem(‘cmts’, ‘’) 先组织出一个最新的评论数据对象 想办法，把 第二步中，得到的评论对象，保存到 localStorage 中： localStorage 只支持存放字符串数据， 要先调用JSON.stringify 在保存最新的评论数据之前，要先从 localStorage 获取到之前的评论数据（string）， 转换为 一个 数组对象， 然后，把最新的评论， push 到这个数组 如果获取到的 localStorage 中的 评论字符串，为空不存在， 则 可以 返回一个 ‘[]’ 让 JSON.parse 去转换 把最新的评论列表数组，再次调用 JSON.stringify 转为数组字符串，然后调用 localStorage.setItem() &lt;div id=&quot;app&quot;&gt; &lt;cmt-box @func=&quot;loadComments&quot;&gt;&lt;/cmt-box&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot; v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;span class=&quot;badge&quot;&gt;评论人： {{ item.user }}&lt;/span&gt; {{ item.content }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; // 定义一个模版定义 &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论人：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论内容：&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; v-model=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;发表评论&quot; class=&quot;btn btn-primary&quot; @click=&quot;postComment&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var commentBox = { data() { return { user: &apos;&apos;, content: &apos;&apos; } }, template: &apos;#tmpl&apos;, methods: { postComment() { var comment = { id: Date.now(), user: this.user, content: this.content } // 从 localStorage 中获取所有的评论 var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) list.unshift(comment) // 重新保存最新的 评论数据 localStorage.setItem(&apos;cmts&apos;, JSON.stringify(list)) this.user = this.content = &apos;&apos; // this.loadComments() // ????? this.$emit(&apos;func&apos;) } } } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { list: [ { id: Date.now(), user: &apos;李白&apos;, content: &apos;天生我材必有用&apos; }, { id: Date.now(), user: &apos;江小白&apos;, content: &apos;劝君更尽一杯酒&apos; }, { id: Date.now(), user: &apos;小马&apos;, content: &apos;我姓马， 风吹草低见牛羊的马&apos; } ] }, beforeCreate(){ // 注意：这里不能调用 loadComments 方法，因为在执行这个钩子函数的时候，data 和 methods 都还没有被初始化好 }, created(){ this.loadComments() }, methods: { loadComments() { // 从本地的 localStorage 中，加载评论列表 var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) this.list = list } }, components: { &apos;cmt-box&apos;: commentBox } }); &lt;/script&gt; 四、使用 this.$refs 来获取元素和组件&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素&quot; @click=&quot;getElement&quot; ref=&quot;mybtn&quot;&gt; &lt;h3 id=&quot;myh3&quot; ref=&quot;myh3&quot;&gt;哈哈哈， 今天天气太好了！！！&lt;/h3&gt; &lt;hr&gt; &lt;login ref=&quot;mylogin&quot;&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;, data() { return { msg: &apos;son msg&apos; } }, methods: { show() { console.log(&apos;调用了子组件的方法&apos;) } } } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: { getElement() { // console.log(document.getElementById(&apos;myh3&apos;).innerText) // ref 是 英文单词 【reference】 值类型 和 引用类型 referenceError // console.log(this.$refs.myh3.innerText) // console.log(this.$refs.mylogin.msg) // this.$refs.mylogin.show() } }, components: { login } }); &lt;/script&gt; 五、什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；#的意义：代表网页中的一个位置，其右边的字符，就是该位置的标识符URL中的hash（井号） 路由的使用： 导入 vue-router 组件类库： &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt; 使用 router-link 组件来导航，用来切换组件 &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 router-view 组件是 vue-router 提供的元素，专门用来当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 &lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 // 4.1 使用 Vue.extend 来创建登录组件 var login = Vue.extend({ template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos; }); // 4.2 使用 Vue.extend 来创建注册组件 var register = Vue.extend({ template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; }); 创建一个路由 router 实例，通过 routes 属性来定义路由匹配规则 创建一个路由对象， 当 导入 vue-router 包之后，在 window 全局对象中，就有了一个 路由的构造函数，叫做 VueRouter 在 new 路由对象的时候，可以为 构造函数，传递一个配置对象 路由匹配规则： 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性： 属性1 是 path， 表示监听 哪个路由链接地址； 属性2 是 component， 表示，如果 路由是前面匹配到的 path ，则展示 component 属性对应的那个组件 注意： component 的属性值，必须是一个 组件的模板对象， 不能是 组件的引用名称； var routerObj = new VueRouter({ routes: [ { path: &apos;/login&apos;, component: login }, { path: &apos;/register&apos;, component: register } ] }); 使用 router 属性来使用路由规则 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 var vm = new Vue({ el: &apos;#app&apos;, router: routerObj // 使用 router 属性来使用路由规则 }); 使用redirect重定向URL路径 { path: &apos;/&apos;, redirect: &apos;/login&apos; }, // 这里的 redirect 和 Node 中的 redirect 完全是两码事 使用tag属性指定router-link渲染的标签类型 &lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;登录&lt;/router-link&gt; 示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;!-- 1.导入包 --&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登陆&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; // 2.创建子组件 var login = { template:&apos;&lt;h3&gt;登陆子组件&lt;/h3&gt;&apos; } var register = { template:&apos;&lt;h3&gt;注册子组件&lt;/h3&gt;&apos; } // 3.创建一个路由对象 var router = new VueRouter({ routes:[ //路由规则数组 {path:&apos;/&apos;,redirect:&apos;/login&apos;}, {path:&apos;/login&apos;,component: login}, {path:&apos;/register&apos;,component: register}, ], linkActiveClass:&apos;myactive&apos; // 激活相关的类 }) var vm = new Vue({ el:&apos;#app&apos;, data:{}, methods:{}, // router: router router }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 六、设置路由高亮 给router-link-active自定义样式 &lt;style&gt; .router-link-active{ color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; } &lt;/style&gt; 设置自己的激活类 给routerObj设置linkActiveClass: ‘myactive’，然后自定义myactive的样式 &lt;style&gt; .myactive { color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; } &lt;/style&gt; 七、设置路由高亮设置路由切换动效 将路由用动画符包裹起来 &lt;transition mode=&quot;out-in&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; 自定义两组动画类 &lt;style&gt; .v-enter, .v-leave-to { opacity: 0; transform: translateX(140px); } .v-enter-active, .v-leave-active { transition: all 0.5s ease; } &lt;/style&gt; 八、在路由规则中定义参数 使用query方式传递参数：如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 &lt;router-link to=&quot;/login?id=10&amp;name=zs&quot;&gt;登录&lt;/router-link&gt; var login = { template: &apos;&lt;h1&gt;登录 --- {{ $route.query.id }} --- {{ $route.query.name }}&lt;/h1&gt;&apos; } 通过 this.$route.params来获取路由中的参数： {{ path: '/login/:id/:name', component: login }} var login = { template: &apos;&lt;h1&gt;登录 --- {{ $route.params.id }} --- {{ $route.params.name }}&lt;/h1&gt;&apos; } 九、使用 children 属性实现路由嵌套&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; //父路由的组件定义 &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to=&quot;/account/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/account/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; // 父路由中的组件 var account = { template: &apos;#tmpl&apos; } // 子路由中的 login 组件 var login = { template: &apos;&lt;h3&gt;登录&lt;/h3&gt;&apos; } // 子路由中的 register 组件 var register = { template: &apos;&lt;h3&gt;注册&lt;/h3&gt;&apos; } // 路由实例：使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址；不能和父组件设置同级，不然组件无法嵌套 var router = new VueRouter({ routes: [ { path: &apos;/account&apos;, component: account, children: [ { path: &apos;login&apos;, component: login }, { path: &apos;register&apos;, component: register } ] } // { path: &apos;/account/login&apos;, component: login }, // { path: &apos;/account/register&apos;, component: register } ] }) // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, router }); 十、命名视图实现经典布局 标签代码结构： &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;container&quot;&gt; &lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： &lt;script&gt; var header = { template: &apos;&lt;h1 class=&quot;header&quot;&gt;Header头部区域&lt;/h1&gt;&apos; } var leftBox = { template: &apos;&lt;h1 class=&quot;left&quot;&gt;Left侧边栏区域&lt;/h1&gt;&apos; } var mainBox = { template: &apos;&lt;h1 class=&quot;main&quot;&gt;mainBox主体区域&lt;/h1&gt;&apos; } // 创建路由对象 var router = new VueRouter({ routes: [ /* { path: &apos;/&apos;, component: header }, { path: &apos;/left&apos;, component: leftBox }, { path: &apos;/main&apos;, component: mainBox } */ { path: &apos;/&apos;, components: { &apos;default&apos;: header, &apos;left&apos;: leftBox, &apos;main&apos;: mainBox } } ] }) // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, router }); &lt;/script&gt; CSS 样式： &lt;style&gt; html, body { margin: 0; padding: 0; } .header { background-color: orange; height: 80px; } h1 { margin: 0; padding: 0; font-size: 16px; } .container { display: flex; height: 600px; } .left { background-color: lightgreen; flex: 2; } .main { background-color: lightpink; flex: 8; } &lt;/style&gt;","path":"2019/05/06/Vue-js学习笔记Day4-5-06/"},{"title":"Vue.js学习笔记Day3-4.29","text":"Vue.js学习笔记Day3-4.29今日主要学习内容： 使用Vue-resource实现品牌的增删查功能； Vue中的动画； 使用过渡类名实现动画 使用第三方 CSS 动画库 使用动画钩子函数 v-for 的列表过渡 使用定义Vue组件； 什么是组件 组件化和模块化的不同 全局组件定义的三种方式 组件中展示数据和响应事件 使用components属性定义局部子组件 两种切换组件方法 开始和我一起Vue框架的学习吧～ 一、使用Vue-resource实现品牌的增删查功能&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-resource-1.3.4.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/bootstrap-3.3.7.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body form-inline&quot;&gt; &lt;!-- &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; --&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot; class=&quot;form-control&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot; class=&quot;btn btn-primary&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=&quot;table table-bordered table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; // 全局配置数据接口的根域名 //注意每次单独发起http请求的时候，请求的URL路径应该以相对路径开头，前面不能带‘/’，否则不会启用根路径拼接 Vue.http.options.root = &apos;http://localhost:63342/vue/&apos;; //全局启用emulateJson选项，防止未添加的时候的情况 Vue.http.options.emulateJSON = true; var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 name: &apos;&apos;, list: [ //存放所有品牌列表的数组 {id: 1, name: &apos;奔驰&apos;, ctime: new Date() }, {id: 2, name: &apos;宝马&apos;, ctime: new Date() } ] }, created(){ //当vm实例的data和methods初始化完毕后，vm实例会自动执行created这个生命周期函数 this.getAllList(); }, methods:{ //methods指示我们要触发的方法 getAllList(){ //获取所有的品牌列表 // 分析： // 1. 由于已经导入了vue-resource这个包，所以可以直接通过this.$http来发起数据请求 // 2. 根据接口API文档，知道获取列表的时候，应该发起一个get请求 // 3. this.$http.get(&apos;url&apos;).then(function(result){}) // 4. 当通过then指定回调函数之后，在回调函数中，可以拿到数据服务器返回的result // 5. 先判断result.status是否等于0，如果等于0，可以吧result.message赋值给this.list；如果不等于0，可以弹框提醒，获取数据失败！ this.$http.get(&apos;http://vue.studyit.io/api/getprodlist&apos;).then(result =&gt; { //注意： 通过$http获取到的数据，都在 result.body中放着 var result = result.body; if(result.status === 0){ //成功了 this.list = result.message; }else{ //失败了 alert(&apos;获取数据失败！&apos;); } }) }, add(){ // 添加品牌列表到后台服务器 // 分析： // 1. 通过查看数据API接口，发现要发送一个post请求this.$http.post // 2. this.$http.post()中接受三个参数： // 2.1 第一个参数：要请求的URL地址 // 2.2 第二个参数：要提交给服务器的数据，要以对象形式提交给服务器（name：this.name） // 2.3 第三个参数：是一个配置对象，要以哪种表单数据类型提交过去（emulate JSON：true），以普通表单形式，将数据提交给服务器application/x-www-form-urlencoded // 3. 在post方法中，使用.then来设置成功的回调函数，如果想要拿到成功的结果，需要result.body this.$http.post(&apos;http://vue.studyit.io/api/addproduct&apos;,{name: this.name},{emulateJSON:true}).then(result =&gt; { //注意： 通过$http获取到的数据，都在 result.body中放着 //var result = result.body; if(result.body.status === 0){ //成功了，添加完成后，只需要手动调用getAllList（）就能刷新品牌列表 this.getAllList(); this.name = &apos;&apos;; }else{ //失败了 alert(&apos;添加失败！&apos;); } }) }, del(id){ //删除品牌列表 this.$http.get(&apos;http://vue.studyit.io/api/delproduct/&apos; + id).then(result=&gt;{ if(result.body.status === 0){ //成功了 this.getAllList(); }else{ //失败了 alert(&apos;删除失败！&apos;); } }) }, } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 二、Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果，包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 1.使用过渡类名实现动画 1.1设置HTML结构： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 需求： 点击按钮，让H3显示，再点击，让H3隐藏 --&gt; &lt;!-- 1.使用transition把需要被动画控制的元素包裹起来，transition是Vue官方提供--&gt; &lt;transition&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; 1.2创建VM 实例： &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 flag: false, }, methods:{ //methods指示我们要触发的方法 } }) &lt;/script&gt; 1.3定义两组类样式： &lt;!-- 2.自定义两组样式，来控制transition内部的元素实现动画 --&gt; &lt;style&gt; /*v-enter是一个时间点，进入之前，元素的起始状态，此时还没有开始进入*/ /*v-leave-to是一个时间点，是动画离开之后，离开的终止状态，此时元素动画已经结束*/ .v-enter,.v-leave-to{ opacity: 0; transform: translateX(150px); } /*v-enter-active是入场动画时间段,v-leave-active是离场动画时间段*/ .v-enter-active,.v-leave-active{ transition: all 0.8s ease; } &lt;/style&gt; 注意：当设置时，可以自定义动画前缀，动画类改为.my-enter.my-leave-to 2.使用第三方 CSS 动画库 2.1导入动画类库： &lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/animate.css&quot;&gt; &lt;!-- 注意：入场使用bounceIn 离场使用bounceOut --&gt; 2.2定义 transition 及属性： &lt;transition enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated bounceOut&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; 2.3使用:druation=”毫秒值”来统一设置入场时长和离场时长 &lt;!-- 使用:druation=&quot;毫秒值&quot;来统一设置入场时长和离场时长--&gt; &lt;!-- 使用:druation=&quot;{enter:200,leave:400}&quot;来分别设置入场时长和离场时长--&gt; &lt;transition enter-active-class=&quot;bounceIn&quot; leave-active-class=&quot;bounceOut&quot; :druation=&quot;{enter:200,leave:400}&quot;&gt; &lt;h3 v-if=&quot;flag&quot; class=&quot;animated&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; 3.使用动画钩子函数 3.1定义 transition 组件以及三个钩子函数： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;加入购物车&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 使用transition把小球包裹起来 --&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 3.2定义三个 methods 钩子方法： methods:{ //methods指示我们要触发的方法 // 注意：动画钩子函数的第一个参数：el，表示要执行动画的那个DOM元素，是个原生的JS DOM对象 //大家可以认为，el是通过 document.getElementById(&apos;&apos;) 方式获取到的原生的JS DOM对象 beforeEnter(el){ //beforeEnter表示动画入场之前，此时动画尚未开始，可以在beforeEnter中设置元素开始动画之前的起始样式 //设置小球开始动画之前的起始位置 el.style.transform = &quot;translate(0,0)&quot;; }, enter(el,done){ //这句话没有实际效用，但写了el.offsetWidth可以出现动画效果，可以认为它强制动画刷新 el.offsetWidth; //enter 表示动画开始之后的样式，这里可以设置小球完成动画之后的结束状态 el.style.transform = &quot;translate(150px, 450px)&quot;; el.style.transition = &apos;all 1s ease&apos; //这里的done()就是afterEnter函数，也就是：done是afterEnter函数的引用，不使用done会产生延迟 done(); }, afterEnter(el){ //动画完成之后会调用afterEnter //console.log(&apos;ok!&apos;); this.flag=!this.flag; }, } 3.3定义动画过渡时长和样式： &lt;style&gt; .ball{ width: 15px; height: 15px; border-radius: 50%; background-color: red; } &lt;/style&gt; 4.v-for 的列表过渡 4.1定义过渡样式： &lt;style&gt; li{ border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; } /* 用来实现鼠标滑动时显示粉色 */ li:hover{ background-color: hotpink; transition: all 0.4s ease; } /* 用来实现新加列表向上弹出显示 */ .v-enter, .v-leave-to{ opacity: 0; transform: translateY(80px); } .v-enter-active, .v-leave-active{ transition: all 0.6s ease; } /* .v-move和.v-leave-active配合使用，能够实现列表后续的元素渐渐地漂上来的效果，更加平缓柔和 */ .v-move{ transition: all 0.6s ease; } .v-leave-active{ position: absolute; } &lt;/style&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 4.2定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- 在实现列表过度的时候，如果需要过度的元素，是通过v-for循环渲染出来的，不能使用transition包裹，需要使用transitionGroup --&gt; &lt;!-- 如果要为v-for循环创建的元素设置动画，必须为每一个元素设置：key属性 --&gt; &lt;!-- appear用于实现刚进入页面时列表滑动显示效果 --&gt; &lt;!-- 通过为transition-group元素设置tag属性，指定它渲染为指定的元素，若不指定tag属性，则渲染为span标签，不符合语法规范 --&gt; &lt;transition-group appear tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;(item,i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; {{item.id}}---{{item.name}} &lt;/li&gt; &lt;/transition-group&gt; &lt;/ul&gt; &lt;/div&gt; 4.3定义 VM中的结构： &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 id: &apos;&apos;, name: &apos;&apos;, list: [ {id:1,name: &apos;张三&apos;}, {id:2,name: &apos;李四&apos;}, {id:3,name: &apos;王五&apos;}, {id:4,name: &apos;赵六&apos;}, ] }, methods:{ //methods指示我们要触发的方法 add(){ this.list.push({ id: this.id, name: this.name}); this.id=this.name=&apos;&apos;; }, del(i){ this.list.splice(i,1); }, } }) &lt;/script&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器 三、使用定义Vue组件1. 什么是组件：组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可； 2. 组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 3. 全局组件定义的三种方式1）使用 Vue.extend 配合 Vue.component 方法：注意：如果使用Vue.component定义全局组件的时候，组件名称使用了驼峰命名，则在引用组件的时候，需要把大写的驼峰改写为小写的字母，同时，两个单词之前用-连接；如果不使用驼峰命名，则直接拿该名称来使用即可 // 1.1使用vue.extend来创建全局的Vue组件 var com1 = Vue.extend({ //通过template属性，指定了组件要展示的HTML结构 template:&apos;&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;&apos; }) // 1.2使用Vue.component(&apos;组件的名称&apos;，创建出来的组件模板对象) Vue.component(&apos;myCom1&apos;,com1) Vue.component： 第一个参数：组件的名称，将来在引用组件的时候，就是一个标签形式来引入它 第二个参数：通过Vue.extend创建的组件，其中template就是组件将来要展示的HTML内容 Vue.component(&apos;myCom1&apos;,Vue.extend({ template:&apos;&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;&apos; })) 2）直接使用 Vue.component 方法： 注意：无论是哪种方式创建出来的组件，组件的template属性指向的模板内容，必须有且只能有唯一的一个根元素 用这种方法更简单，但是html语句书写起来没有提示更不方便书写 Vue.component(&apos;mycom2&apos;, { template: &apos;&lt;div&gt;&lt;h3&gt;这是直接使用Vue.component创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;&apos; }); 3）将模板字符串，定义到script标签种： 这是通过template元素在外部定义的组件结构，这个方式有代码的智能提示和高亮 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ &lt;!-- 在被控制的#app外面，使用template元素，定义组件的HTML模板结构 --&gt; &lt;template id=&quot;temp1&quot;&gt; &lt;div&gt; &lt;h3&gt;这是通过template元素在外部定义的组件结构&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; 同时，需要使用 Vue.component 来定义组件： Vue.component(&apos;mycom3&apos;, { template: &apos;#tmp1&apos; }); 4. 组件中展示数据和响应事件1）在组件中，data需要被定义为一个方法，例如： 组件可以有自己的data数据 组件的data和实例的data有点不一样，实例中的data可以作为一个对象，但是组件中的data必须是一个方法 组件中的data出了必须作为一个方法之外，这个方法内部，还必须返回一个对象才行 组件中的data数据和实例中的使用方式一模一样 Vue.component(&apos;mycom2&apos;, { template: &apos;&lt;h3&gt;这是全局组件 ---{{msg}}&lt;/h3&gt;&apos;, data:function(){ return{ msg: &apos;这是组件中data定义的数据&apos; }; }, methods:{ } }); 2）在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问；【重点】：为什么组件中的data属性必须定义为一个方法并返回一个对象：因为共用同一个dataObj导致几个计时器会相互干扰 // 这是一个计数器的组件，身上有个按钮，每当点击按钮，让data中的count值+1 Vue.component(&apos;counter&apos;, { template: &apos;#tmp1&apos;, data:function(){ // return dataObj; return{ count:0, }; }, methods:{ increment(){ this.count +=1 } } }); 5.使用components属性定义局部子组件1）组件实例定义方式：var vm2 = new Vue({ el:&apos;#app2&apos;, data: {}, methods: {}, filters: {}, directives: {}, components: { //用于定义实例内部私有组件的 login: { template: &apos;&lt;h1&gt;这是私有的login组件&lt;/h1&gt;&apos; } }, beforeCreate(){}, created(){}, beforeMount(){}, mounted(){}, beforeUpdate(){}, updated(){}, beforeDestroy(){}, destroyed(){}, }) 2）引用组件：&lt;div id=&quot;app2&quot;&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; 6.切换组件方法方法一：使用flag标识符结合v-if和v-else切换组件（仅用于两个组件间切换） 页面结构： &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=true&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=false&quot;&gt;注册&lt;/a&gt; &lt;login v-if=&quot;flag&quot;&gt;&lt;/login&gt; &lt;register v-else=&quot;flag&quot;&gt;&lt;/register&gt; &lt;/div&gt; Vue实例定义： &lt;script&gt; Vue.component(&apos;login&apos;, { template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; }); Vue.component(&apos;register&apos;, { template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; }); var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 flag: false, }, methods:{ //methods指示我们要触发的方法 } }) &lt;/script&gt; 缺陷：只能两个组件相互切换，更多组件无法使用v-if和v-else 方法二：使用:is属性来切换不同的子组件,并添加切换动画（可用于多个组件间切换） 组件实例定义方式： &lt;script&gt; // 组件名称是一个字符串，所以放到：is里要用引号引起来 Vue.component(&apos;login&apos;, { template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; }); Vue.component(&apos;register&apos;, { template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; }); var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 comName: &apos;&apos; //当前component中的：is绑定的组件名称 }, methods:{ //methods指示我们要触发的方法 } }) &lt;/script&gt; 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;login&apos;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;register&apos;&quot;&gt;注册&lt;/a&gt; &lt;!-- Vue提供了component，来展示对应名称的组件 --&gt; &lt;!-- component是一个占位符，：is属性可以用来指定要展示的组件名称 --&gt; &lt;!-- 通过mode属性，设置组件切换时候的模式 --&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;!-- 总结：当前学习了几个Vue提供的标签 --&gt; &lt;!-- component，template,transition,transitionGroup --&gt; &lt;/div&gt; 注意： 通过mode属性，设置mode=”out-in”，设置组件切换时候先出后进的模式 –&gt; 添加切换样式： &lt;style&gt; .v-enter, .v-leave-to{ opacity: 0; transform: translateX(150px); } .v-enter-active, .v-leave-active{ transition: all 0.5s ease; } &lt;/style&gt;","path":"2019/04/29/Vue-js学习笔记Day3-4-29/"},{"title":"Vue.js学习笔记Day2-4.24","text":"Vue.js学习笔记Day2-4.24今日主要学习内容： 品牌列表案例； 全局过滤器和私有过滤器； 自定义按键修饰符； 自定义指令； Vue实例的生命周期； vue-resource 实现 get, post, jsonp请求； 配置本地数据库和数据接口API； 开始Vue框架的学习吧～ 一、品牌列表案例 1.x 版本中的filterBy指令，在2.x中已经被废除：filterBy - 指令 12345678&lt;tr v-for=\"item in list | filterBy searchName in 'name'\"&gt;&lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt;&lt;td&gt;&lt;a href=\"#\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 12&lt;hr&gt; 输入筛选名称：&lt;input type=\"text\" v-model=\"searchName\"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 12345678910&lt;tbody&gt;&lt;tr v-for=\"item in search(searchName)\"&gt;&lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt;&lt;td&gt;&lt;a href=\"#\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345search(name) &#123;return this.list.filter(x =&gt; &#123;return x.name.indexOf(name) != -1;&#125;);&#125; 二、过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 1.私有过滤器HTML元素：1&lt;td&gt;&#123;&#123;item.ctime | dataFormat()&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223filters:&#123; //定义私有过滤器，过滤器有两个条件，【过滤器名称和处理函数】 //注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ dateFormat:function(dateStr,pattern = '')&#123; var dt = new Date(dateStr); // yy-mm-dd var y = dt.getFullYear(); var m = (dt.getMonth()+1).toString().padStart(2,'0'); var d = dt.getDate().toString().padStart(2,'0'); if (pattern &amp;&amp; pattern.toLowerCase() === 'yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 else&#123; var hh = dt.getHours().toString().padStart(2,'0'); var mm = dt.getMinutes().toString().padStart(2,'0'); var ss = dt.getSeconds().toString().padStart(2,'0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;~~~`; &#125; &#125;&#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串,例如.toString().padStart(2,’0’)用于不满两位数字则向前补零。 2.全局过滤器HTML元素：1&lt;td&gt;&#123;&#123;item.ctime | dateFormat()&#125;&#125;&lt;/td&gt; 全局 filters 定义方式：1234567891011121314151617181920212223// 创建一个全局的过滤器，进行事件的格式化Vue.filter('dateFormat',function(dateStr,pattern)&#123;// 根据给定的字符串得到特定时间 var dt = new Date(dateStr); // yy-mm-dd var y = dt.getFullYear(); var m = dt.getMonth()+1; var d = dt.getDate(); // return y + '-' + m + '-' + d; // return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; if (pattern &amp;&amp; pattern.toLowerCase() === 'yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 else&#123; var hh = dt.getHours(); var mm = dt.getMinutes(); var ss = dt.getSeconds(); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;) 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 三、自定义按键修饰符1.直接使用按键码的别名1&lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.enter=\"add\"&gt; 2.使用js里面的键盘事件对应的键码1&lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.13=\"add\"&gt; js里面的键盘事件对应的键码：http://www.cnblogs.com/wuhua1/p/6686237.html 3.通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名：1&lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.f2=\"add\"&gt; 自定义键盘修饰符Vue.config.keyCodes.f2 = 113; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理 四、自定义指令1.传统使用DOM方法进行定义指令1&lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\"&gt; 在中使用DOM方法进行定义document.getElementById(‘search’).focus(); 2.使用 vue.directive()定义全局的指令 ，其中参数一是指令的名称使用 vue.directive()定义全局的指令注意：在定义的时候，指令的名称前面，不需要加v-前缀，但在调用的时候，必须在指令名称前加上v-前缀进行调用参数二是一个对象，在这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 1. 和JS行为有关的操作，最好在inserted中去执行，防止JS行为不生效，如v-focus在每一个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数，是一个原生的JS对象（DOM对象）在元素刚绑定指令的时候，还没有插入到DOM中去，这时候调用focus方法没有作用因为一个元素只有插入DOM之后，才能获得焦点，所以要用inserted 1&lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\" v-focus&gt; 12345678910Vue.directive('focus',&#123; bind:function(el)&#123; //每当指令绑定到元素上时，会立即执行这个bind指令，只执行一次 //el.focus() &#125;, inserted: function(el)&#123; //表示元素插入到DOM中的时候，会执行inserted函数，只触发一次 el.focus() ; &#125;, updated: function()&#123; //当vnode更新的时候会执行updated，可能会触发多次 &#125;,&#125;) 2. 和样式相关的操作，可以放在bind中去执行，如v-color样式：只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式将来元素肯定会显示到页面中，这时候浏览器的渲染引擎必然会解析样式，应用给这个元素 1&lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\" v-focus v-color=\"'blue'\"&gt; 12345678910//设置一个定义字体颜色的指令Vue.directive('color' ,&#123; bind:function(el,binding)&#123; //el.style.color='red'; console.log(binding.name); //输出的是样式名color console.log(binding.value); //输出的是计算后的参数blue console.log(binding.expression); //输出的是原本的参数'blue' el.style.color = binding.value; &#125;&#125;) 3. 函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:1&lt;h3 v-color=\"'pink'\" v-fontweight=\"900\" v-fontsize=\"'30px'\"&gt;&#123;&#123; dt |dateFormat() &#125;&#125;&lt;/h3&gt; 123456789101112directives:&#123; //定义私有过滤器，定义在vm2实例中 'fontweight':&#123; bind: function(el,binding)&#123; el.style.fontWeight = binding.value; &#125; &#125;, 'fontsize':function(el,binding)&#123; el.style.fontSize= parseInt(binding.value) + 'px'; &#125;&#125;parseInt(binding.value) + 'px';用于解析输入的字符串，将'30px'解析成数字30，增强代码的健壮性 五、Vue实例的生命周期什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！生命周期钩子：就是生命周期事件的别名而已；生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 六、vue-resource 实现 get, post, jsonp请求 除了 vue-resource 之外，还可以使用 axios 的第三方包实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址：get请求地址： http://vue.studyit.io/api/getlunbopost请求地址：http://vue.studyit.io/api/postjsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；带大家通过 Node.js ，来手动实现一个JSONP的请求例子； vue-resource 的配置步骤：直接在页面中，通过script标签，引入 vue-resource 的脚本文件；注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 12&lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;script src=\"./lib/vue-resource-1.3.4.js\"&gt;&lt;/script&gt; 七、配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root","path":"2019/04/24/Vue-js学习笔记Day2-4-24/"},{"title":"Vue.js学习笔记Day1-4.22","text":"Vue.js学习笔记Day1-4.22今日主要学习内容： 三大主流框架的区别； 框架和库的区别； MVC和MVVM的区别； Vue的基本代码结构、插值表达式、v-cloak、v-text、v-html、v-bind、v-on； 走马灯效果制作； 事件修饰符（.stop、.prevent、.capture、.self、.once）； v-model和实现表单元素的双向数据绑定； Vue中使用样式； v-for指令和key属性； v-if和v-show的使用和特点 今天开始和我一起Vue框架的学习吧～ 一、三大主流框架： Vue是目前最火的前端框架，用来构建用户界面，只关注与视图层，容易上手且方便与与第三方库整合，它由前谷歌员工Evan You创建，被阿里巴巴，GitLab，百度使用，并受到全球开发人员和设计师的赞赏。 React是最流行的前端框架，React由facebook维护，React被Facebook，Uber，Netflix，Twitter，Udemy，Paypal，Reddit，Tumblr，Walmart 等使用。（React除了开发网页还可以开发App，vue借助于weex也可以开发手机App） Angular是应用最广泛的前端框架，是一个由Google支持的基于TypeScript的JavaScript框架，Angular开发在全球开发人员中广泛流行，并被谷歌，福布斯，WhatsApp，Instagram，healthcare.gov和许多财富500强公司等大型组织使用。 二、框架和库的区别：框架：是一套完整的解决方案；对项目侵入性非常大，项目需要更换框架，则需要重新架构各个项目库：提供某一个小功能，对项目侵入性小，如果某个库无法完成某些需求，可以很容易切换其他库进行实现需求 三、MVC（后端）和MVVM（前端）间的区别：MVC：modal层负责数据的处理，view层负责前端显示页面，controller是业务逻辑层MVVM：是前端视图层的概念，主要关注视图层的分离，VM是最主要的部分，是整个环节的调度者 四、Vue之基本代码结构、插值表达式、v-cloak、v-text、v-html、v-bind、v-on1.Vue的基本代码结构：这是一个新建好的Vue项目结构 2.Vue的插值表达式：主要作用是进行数据绑定，最常见的形式是使用“Mustache”语法（双大括号）的文本插值。例如：&lt;span&gt;Message:&lt;/span&gt;Mustache标签将会被替代为对应数据对象上msg属性（msg定义在data对象中）的值。无论何时，绑定的数据对象上msg属性发生了改变，插值处的内容都会更新。 3.指令学习：v-cloak：解决插值闪烁问题 &lt;p v-clock&gt;{{ msg }}&lt;/p&gt; //可以解决插值闪烁问题 v-text： 操作元素中的纯文本&lt;p v-clock&gt;&lt;/p&gt;和&lt;h4 v-text=&quot;msg&quot;&gt;&lt;/h4&gt;区别：1&gt;默认v-text没有插值闪烁问题2&gt;v-text会覆盖元素中原本的内容，但插值表达式只会替换自己的占位符，不会吧整个元素内容清空 &lt;p v-clock&gt;+++{{ msg }}&lt;/p&gt; //可显示+++， &lt;h4 v-text=&quot;msg&quot;&gt;+++&lt;/h4&gt; //不能显示+++ v-html： 操作元素中的HTML标签 &lt;div v-html=&quot;msg2&quot;&gt;&lt;/div&gt; v-text会将元素当成纯文本输出，v-html会将元素当成HTML标签解析后输出 v-bind：用于提供绑定属性的指令，简写形式是： &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot;&gt; 简写形式：v-bind:title等同于:titlev-bind中可以写合法的JS表达式，可以将mytitle看做一个变量，为其添加表达式‘123’ v-on：事件绑定机制，可以替代DOM操作，简写形式是@ &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot; id=&quot;btn&quot;&gt; &lt;/div&gt; &lt;script&gt; document.getElementById(&apos;btn&apos;).onclick = function(){ alert(&apos;Hello&apos;) } &lt;/script&gt; 用vue框架可以简写为： &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot; v-on:click=&quot;alert(&apos;hello&apos;)&quot;&gt; &lt;/div&gt; 简写形式：v-on:click等同于@click如若发现alert未被定义，还需要用methods属性定义当前vue实例所有可用的方法 &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot; v-on:click=&quot;show&quot;&gt; &lt;/div&gt; &lt;script&gt; methods:{ show:function(){ alert(&apos;Hello&apos;) } } &lt;/script&gt; 五、走马灯效果制作制作步骤： 给【浪起来】按钮，绑定一个点击事件 v-on即@click 在按钮的事件处理函数中，写相关的业务逻辑代码，拿到msg字符串，然后调用字符串的substring来进行字符串的截取操作，把第一个字符截取出来，放到最后一个位置上即可 为了实现点击按钮自动截取的功能，需要把步骤2步骤中的代码，放到一个定时器中去 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;嗨起来&quot; @click=&quot;lang&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;低调&quot; @click=&quot;stop&quot;&gt; &lt;h4&gt;{{ msg }}&lt;/h4&gt; &lt;/div&gt; &lt;script&gt; //注意：在VM实例中，如果要获取data上的数据，或者想要调用methods中的方法，必须通过this.数据属性名或者this.方法名来进行访问，这里的this.就表示我们new出来的VM实例 var vm = new Vue({ el: &apos;#app&apos;, data: { msg: &apos;猥琐发育，别浪~~！&apos;, intervalId:null, //在data上面定义计时器Id }, methods:{ lang(){ if(this.intervalId != null) return; //console.log(this.msg); //var _this=this; this.intervalId = setInterval(() =&gt; { //也可以用箭头函数，解决this指向问题 //获取到头的第一个字符 var start = this.msg.substring(0,1); //获取到后面的字符 var end = this.msg.substring(1); //重新拼接得到新的字符串，并赋值给this.msg this.msg = end + start; },400) //vm实例会监听自己身上data中所有数据的改变，只要数据一发生变化，就会自动把最新的数据，从data、上同步到页面中去【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 }, stop(){ clearInterval(this.intervalId); //每当清除了定时器之后需要把intervalId重新设为null，否则无法重新开启定时器 this.intervalId = null; } } }) &lt;/Script&gt; &lt;/body&gt; &lt;/html&gt; 六、 事件修饰符.stop：用于阻止冒泡 &lt;div class=&quot;inner&quot; @click=&quot;divHander&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click.stop=&quot;btnHander&quot; &gt; &lt;/div&gt; .prevent：阻止默认行为 &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;linkClick&quot;&gt;有问题先去百度&lt;/a&gt; .capture：添加事件侦听器时使用事件捕获模式 &lt;div class=&quot;inner&quot; @click.capture=&quot;divHander&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click=&quot;btnHander&quot; &gt; &lt;/div&gt; .self：实现只有点击当前元素时，才会触发事件处理函数 &lt;div class=&quot;inner&quot; @click.self=&quot;divHander&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click=&quot;btnHander&quot; &gt; &lt;/div&gt; .once事件只触发一次,.prevent.once相当于只阻止一次默认行为 &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.once=&quot;linkClick&quot;&gt;有问题先去百度&lt;/a&gt; 注意：.stop和.self的区别：.stop是阻止所有冒泡行为的发生.self 只会阻止自己身上冒泡行为的发生，并不会真正阻止冒泡的行为 &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt; &lt;div class=&quot;inner&quot; @click=&quot;divHandler&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click.stop=&quot;btnHandler&quot; &gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;divHandler&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click=&quot;btnHandler&quot; &gt; &lt;/div&gt; &lt;/div&gt; 七、Vue指令之v-model和实现表单元素的双向数据绑定v-bind只能实现数据的单向绑定，从M自动绑定到V，无法实现数据的双向绑定 &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; style=&quot;width: 100%&quot;&gt; v-model指令可以实现表单元素和Mpdel中数据的双向数据绑定v-model只能运用在表单元素中：input（radio，text，address，email…）、select、checkbox、textarea等等 &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; style=&quot;width: 100%&quot;&gt; 使用v-model实现简易计算器的案例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;+&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;*&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;/&quot;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; @click=&quot;calc&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 n1: 0, n2: 0, result: 0, opt: &apos;+&apos;, }, methods:{ calc(){ //计算器算数的方法 switch(this.opt){ //逻辑 case &apos;+&apos;: this.result = parseInt(this.n1) + parseInt(this.n2) break; case &apos;-&apos;: this.result = parseInt(this.n1) - parseInt(this.n2) break; case &apos;*&apos;: this.result = parseInt(this.n1) * parseInt(this.n2) break; case &apos;/&apos;: this.result = parseInt(this.n1) / parseInt(this.n2) break; } // 注意eval是投机取巧的方式，正式开发中，尽量少用 // var codeStr = &apos; parseInt(this.n1) &apos; + this.opt + &apos; parseInt(this.n2) &apos; // this.result = eval(codeStr) } } }) &lt;/Script&gt; &lt;/body&gt; &lt;/html&gt; 八、Vue中使用样式使用class样式1. 数组 &lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;很大很大的标题&lt;/h1&gt; 2. 数组中使用三元表达式 &lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, flag?&apos;active&apos;:&apos;&apos;]&quot;&gt;很大很大的标题&lt;/h1&gt; 3. 数组中嵌套对象 &lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, {&apos;active&apos;:flag}]&quot;&gt;很大很大的标题&lt;/h1&gt; 4. 直接使用对象 &lt;h1 :class=&quot;{red:true,thin:true,italic:false,active:false}&quot;&gt;很大很大的标题&lt;/h1&gt; &lt;h1 :class=&quot;classObj&quot;&gt;很大很大的标题&lt;/h1&gt; data: { //data中定义样式对象 classObj:{red:true,thin:true,italic:false,active:false} }, 使用内联样式：1. 直接在元素上通过:style的形式书写样式对象 &lt;h1 :style=&quot;{color:&apos;red&apos;,&apos;font-weight&apos;:200 }&quot;&gt;这是一个标题&lt;/h1&gt; 2. 将样式对象定义到data中，并直接引用到:style中 &lt;h1 :style=&quot;styleObj1&quot;&gt;这是一个标题&lt;/h1&gt; data: { //data中定义样式对象 styleObj1:{color:&apos;red&apos;,&apos;font-weight&apos;:200 }, }, 3. 在:style中通过数组，引用多个data上的样式对象 &lt;h1 :style=&quot;[ styleObj1 , styleObj2 ]&quot;&gt;这是一个标题&lt;/h1&gt; data: { //data中定义样式对象 styleObj1: {color:&apos;red&apos;,&apos;font-weight&apos;:200 }, styleObj2: {&apos;font-style&apos;:&apos;italic&apos;} }, 九、Vue指令之v-for指令和key属性1. 迭代数组 &lt;p v-for=&quot;item in list&quot;&gt;{{ item }}&lt;/p&gt; &lt;p v-for=&quot;(item,i) in list&quot;&gt;索引值:{{ i }}---每一项:{{ item }}&lt;/p&gt; 2. 迭代对象数组 &lt;p v-for=&quot;(user,i) in list&quot;&gt;索引号:{{ i }}---序号:{{ user.id }}---姓名：{{ user.name}}&lt;/p&gt; 3. 迭代对象 &lt;p v-for=&quot;(value,key,i) in User&quot;&gt;索引号：{{i}}---键是:{{ key }}---值是:{{ value }}&lt;/p&gt; 4. 迭代数字 &lt;!-- in后面放置普通数组，对象数组，对象，还可以放置数字 --&gt; &lt;!-- 注意：如果使用v-for迭代数字，默认从1开始迭代 --&gt; &lt;p v-for=&quot;(count,i) in 10&quot;&gt;索引号：{{i}}---这是第 {{ count }} 次循环&lt;/p&gt; key属性的特性： 在2.20+的版本里，当在组件中使用v-for时，key现在是必须的 当vue.js用v-for正在更新已渲染过的元素列表时，它默认用“就地复原策略”，如果数据项的顺序被改变，vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保他在指定索引下显示已被渲染过的每个元素 为了给Vue一个提示，以便他能够跟踪每个节点的身份，从而重用和重新排序现有的元素，需要为每项提供一个唯一的key属性 注意：v-for循环的时候key属性只能使用number获取string 注意：key在使用时，必须使用v-bind属性绑定形式，指定key的值 在组件中使用v-for的时候，或者在一些特殊情况中，如果v-for有问题，必须在使用v-for的同时，指定唯一的字符串或数字类型：key值 &lt;p v-for=&quot;(user,i) in list&quot; :key=&quot;user.id&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; 索引号:{{ i }}---序号:{{ user.id }}---姓名：{{ user.name}} &lt;/p&gt; 十、v-if和v-show的使用和特点 v-if的特点：每次都会重新删除或创建元素 v-show的特点：每次不会重新进行DOM的删除和创建操作，只是切换了元素的display：none v-if有较高的切换性能，如果元素涉及到频繁的切换，最好不要使用v-if v-show有较高的初始渲染消耗，如果元素可能永远也不会显示出来被用户看到，则不推荐使用v-show &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;toggle&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是v-if控制的元素&lt;/h3&gt; &lt;h3 v-show=&quot;flag&quot;&gt;这是v-show控制的元素&lt;/h3&gt;","path":"2019/04/22/Vue-js学习笔记Day1-4-22/"},{"title":"十大排序算法","text":"今天我们来学习一下排序算法，排序算法是《数据结构与算法》中最基本的算法之一，虽说学过这门课，但几种排序总是讲述不清，今天来做一个系统的学习归纳，跟着我一起来学习吧~ 排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的十大内部排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。用一张图概括： 关于时间复杂度： O(n2) 平方阶排序: 插入排序、选择排序和冒泡排序；O(nlog2n) 线性对数阶排序: 快速排序、堆排序和归并排序；O(n1+§) 排序(§ 是介于 0 和 1 之间的常数): 希尔排序；O(n) 线性阶排序: 基数排序、桶、箱排序。 关于稳定性： 排序算法的稳定性:若待排序的序列中，存在多个具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 一.冒泡排序1.算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 2.动画演示 3.参考代码（JavaScript 代码实现） function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &lt; len - 1; i++) { for (var j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } 二.选择排序1.算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 2.动画演示 3.参考代码（JavaScript 代码实现） function selectionSort(arr) { var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) { minIndex = i; for (var j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { // 寻找最小的数 minIndex = j; // 将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr; } 三.插入排序1.算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 2.动画演示 3.参考代码（JavaScript 代码实现） function insertionSort(arr) { var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) { preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) { arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current; } return arr; } 四.希尔排序1.算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 2.动画演示 3.参考代码（JavaScript 代码实现） function shellSort(arr) { var len = arr.length, temp, gap = 1; while(gap &lt; len/3) { //动态定义间隔序列 gap =gap*3+1; } for (gap; gap &gt; 0; gap = Math.floor(gap/3)) { for (var i = gap; i &lt; len; i++) { temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) { arr[j+gap] = arr[j]; } arr[j+gap] = temp; } } return arr; } 五.归并排序1.算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 2.动画演示 3.参考代码（JavaScript 代码实现） function mergeSort(arr) { // 采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) { return arr; } var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right) { var result = []; while (left.length &amp;&amp; right.length) { if (left[0] &lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result; } 六.快速排序1.算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 2.动画演示 3.参考代码（JavaScript 代码实现） function quickSort(arr) { if (arr.length &lt;= 1) {//如果数组长度小于等于1无需判断直接返回即可 return arr; } var pivotIndex = Math.floor(arr.length / 2);//取基准点 var pivot = arr.splice(pivotIndex, 1)[0];//取基准点的值,splice(index,1)函数可以返回数组中被删除的那个数 var left = [];//存放比基准点小的数组 var right = [];//存放比基准点大的数组 for (var i = 0; i &lt; arr.length; i++){ //遍历数组，进行判断分配 if (arr[i] &lt; pivot) { left.push(arr[i]);//比基准点小的放在左边数组 } else { right.push(arr[i]);//比基准点大的放在右边数组 } } //递归执行以上操作,对左右两个数组进行操作，直到数组长度为&lt;=1； return quickSort(left).concat([pivot], quickSort(right)); }; 七.堆排序1.算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 2.动画演示 3.参考代码（JavaScript 代码实现） var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) { heapify(arr, i); } } function heapify(arr, i) { // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) { largest = left; } if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest); } } function swap(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } function heapSort(arr) { buildMaxHeap(arr); for (var i = arr.length-1; i &gt; 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0); } return arr; } 八.计数排序1.算法步骤 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1) 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数 2.动画演示 3.参考代码（JavaScript 代码实现） function countingSort(arr, maxValue) { var bucket = new Array(maxValue+1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) { if (!bucket[arr[i]]) { bucket[arr[i]] = 0; } bucket[arr[i]]++; } for (var j = 0; j &lt; bucketLen; j++) { while(bucket[j] &gt; 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } 九.桶排序1.算法步骤 设置固定数量的空桶。 把数据放到对应的桶中。 对每个不为空的桶中数据进行排序。 拼接不为空的桶中数据，得到结果。 2.动画演示 3.参考代码（JavaScript 代码实现） function bucketSort(arr, bucketSize) { if (arr.length === 0) { return arr; } var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) { if (arr[i] &lt; minValue) { minValue = arr[i]; // 输入数据的最小值 } else if (arr[i] &gt; maxValue) { maxValue = arr[i]; // 输入数据的最大值 } } //桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) { buckets[i] = []; } //利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) { buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); } arr.length = 0; for (i = 0; i &lt; buckets.length; i++) { insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) { arr.push(buckets[i][j]); } } return arr; } 十.基数排序1.算法步骤 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零 从最低位开始，依次进行一次排序 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 2.动画演示 3.参考代码（JavaScript 代码实现） //LSD Radix Sort var counter = []; function radixSort(arr, maxDigit) { var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) { for(var j = 0; j &lt; arr.length; j++) { var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } var pos = 0; for(var j = 0; j &lt; counter.length; j++) { var value = null; if(counter[j]!=null) { while ((value = counter[j].shift()) != null) { arr[pos++] = value; } } } } return arr; } 本文只是对十大排序算法进行了简要描述，本人着重于学习Web开发，所以摘取的是JavaScript的代码，如果还想进一步深入学习，可以参考菜鸟教程的 十大排序算法 的教学网站~","path":"2019/04/01/十大排序算法/"},{"title":"Markdown基本语法","text":"进行完博客搭建，让我们来学习一下怎么写博客吧，学习一下Markdown的基本语法~本站只是对Markdown语法进行简要叙述，如果想要加深一步学习，可以去Markdown官网上进行学习哦~ 什么是Markdown？ Markdown 的目标是实现「易读易写」。Markdown 语法的目标是：成为一种适用于网络的书写语言。Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 markdown的优点： 语法简单 更专注内容而非排版，排版只是为了更清楚的展现内容 md轻松转换html及pdf，网络友好 1.标题行首插入1到6个# ，对应到标题1到6阶，例如 # 这是 H1，一级标题 ## 这是 H2，二级标题 ###### 这是 H6，六级标题 2.段落一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。普通段落不该用空格或制表符来缩进。如果你确实想要依赖 Markdown 来插入 标签的话，在插入处先按入两个以上的空格然后回车。 3.列表Markdown 支持有序列表和无序列表。无序列表使用星号、加号或是减号作为列表标记，如： * 列表一 * 列表二 * 列表三 有序列表则使用数字接着一个英文句点，如： 1. 有序列表一 2. 有序列表二 3. 有序列表三 4.分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 5.链接要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，例如： [Lililich&apos;s Blog](https://lililich.work) 要建立一个自动链接，只要是用&lt;&gt;括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;https://lililich.work&gt; 6.图片Markdown 使用一种和链接很相似的语法来标记图片。行内式的图片语法详细叙述如下：1.一个惊叹号 !2.接着一个方括号，里面放上图片的替代文字3.接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 ![Lililich&apos;s photo](/path/to/img.jpg &quot;Optional title&quot;) 7.代码区要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落。 这是一个代码区块。 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： 这是一个 `行内` 代码。 如果用三个反引号（`）把它包起来即可在网页中显示为多行代码块，例如： 12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;这是一段文字&lt;/&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8.强调字体Markdown 使用星号( * )和底线( _ )作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong> ，例如： *这是斜体* **这是粗体** 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \\*这里的星号是普通符号，不会用作斜体显示\\* 9.区块引用Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式，在 Markdown 文件中建立一个区块引用，首先自己先断好行，然后在每行的最前面加上 &gt; ，例如： &gt;这是一段引用 &gt;这是另一段引用 好啦，常用的Markdown的语法学习就到这里啦，如果想要加深一步学习，可以去Markdown官网上进行学习哦~","path":"2019/03/31/Markdown基本语法/"},{"title":"Git基本用法","text":"Github是一个远程仓库，上传下载文件都需要运用到Git命令，让我们学习一下怎么运用Git吧~本站只是对Github进行简要概括，方便运用时查找，如果想要加深一步学习，可以去廖雪峰Git教学网站上进行学习哦~ 什么是Git命令？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。Git有什么特点？简单来说就是：高端大气上档次！ 集中式版本控制系统(如CVS和SVN) ：版本库是集中存放在中央服务器的，工作时从版本库下载，修改后重新上传版本库，完整的版本库保存在中央服务器，集中式版本控制系统最大的毛病就是必须联网才能工作。 分布式管理系统(如Git) ：每个人电脑里都会有完整的版本库，只推送修改即可，不必联网。Git的优势不单是不必联网这么简单，Git极其强大的分支管理，把SVN等远远抛在了后面。Git的工作描述图如下： 一.版本管理1）git init创建版本库,初始化本地仓库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。通过git init命令把这个目录变成Git可以管理的仓库： $ git init Initialized empty Git repository in /Users/michael/learngit/.git/ 2）git add 将修改好的文件上传到版本库$ git add readme.txt $ git add file2.txt file3.txt //可同时添加多个文件 3）git commit 将修改好的文件上传到仓库-m参数后面输入的是本次提交的说明 $ git commit -m &quot;wrote a readme file&quot; [master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 4）git status 命令可以让我们时刻掌握仓库当前的状态$ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 5）git diff 命令可以查看具体修改内容$ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. 6）git log 命令可以查看近期提交日志，可以获取commit id加上--pretty=oneline参数可省去多余的信息 $ git log commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) Author: Lililich &lt;lililich94@163.com&gt; Date: Fri May 18 21:06:15 2018 +0800 wrote a readme file 7）git reset 命令进行版本回退用HEAD表示当前版本，上一个版本就是HEAD^，往上100个版本写成HEAD~100；也可以用commit id来进行版本回退 $ git reset --hard HEAD^ HEAD is now at e475afc add distributed $ git reset --hard 1094a HEAD is now at 83b0afe append GPL 8）git relog 命令用来记录每一次命令，方便查找commit id$ git reflog e475afc HEAD@{1}: reset: moving to HEAD^ 1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL e475afc HEAD@{3}: commit: add distributed eaadf4e HEAD@{4}: commit (initial): wrote a readme file 9）git checkout 命令用来撤销修改--很重要，没有--，就变成了“切换到另一个分支”的命令 //若修改仅保存在工作区，可直接撤销修改 $ git checkout -- readme.txt //若已经git add到了暂存区，先将暂存区版本撤销再丢弃工作区修改 $ git reset HEAD readme.txt $ git checkout -- readme.txt //若已经git commit到了远程仓库，直接进行版本回退 $ git reset --hard HEAD^ 10）git rm 命令用来删除文件删除版本库文件先git rm再git commit提交 $ git rm test.txt rm &apos;test.txt&apos; $ git commit -m &quot;remove test.txt&quot; [master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt $ git checkout -- test.txt //还可以将误删的文件从版本库还原 11）git remote add 命令把本地仓库与GitHub远程仓库相关联$ git remote add origin git@github.com:lililich/learngit.git 12）git push命令把本地当前分支master推送到远程-u参数代表Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令 $ git push -u origin master Counting objects: 20, done. Delta compression using up to 4 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done. Total 20 (delta 5), reused 0 (delta 0) remote: Resolving deltas: 100% (5/5), done. To github.com:lililich/learngit.git * [new branch] master -&gt; master Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. 13）git clone命令用于从远程库克隆代码$ git clone git@github.com:lililich/gitskills.git Cloning into &apos;gitskills&apos;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3 Receiving objects: 100% (3/3), done. 二.分支管理1）git checkout命令用来创建并切换分支$ git checkout -b dev //用来创建并切换分支，相当于以下两条命令 Switched to a new branch &apos;dev&apos; $ git branch dev //创建分支 $ git checkout dev //切换分支 2）git branch命令用来命查看当前分支命令会列出所有分支，当前分支前面会标一个*号 $ git branch * dev master 3）git merge命令用于合并指定分支到当前分支$ git merge dev Updating d46f35e..b17d20e Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) 4）git branch命令也用于创建和操作分支不加参数git branch &lt;name&gt;表示创建分支，加上参数git branch -d &lt;name&gt;用于删除分支，git branch -D &lt;name&gt;用于删除一个还未被合并过的分支 $ git branch -d dev Deleted branch dev (was b17d20e). $ git branch -D feature-vulcan Deleted branch feature-vulcan (was 287773e). 5）git log --graph命令用于查看分之合并情况当Git无法自动合并分支时，就必须首先解决冲突。git status查看冲突文件，解决冲突后，再提交，合并完成。合并完成用git log --graph命令也用于查看分之合并情况 $ git log --graph --pretty=oneline --abbrev-commit * cf810e4 (HEAD -&gt; master) conflict fixed |\\ | * 14096d0 (feature1) AND simple * | 5dc6824 &amp; simple |/ * b17d20e branch test * d46f35e (origin/master) remove test.txt 6）git merge --no-ff命令用于表示禁用Fast forward,--no-ff参数表示使合并后的历史有分支，能看出曾做过合并通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 $ git merge --no-ff -m &quot;merge with no-ff&quot; dev Merge made by the &apos;recursive&apos; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 7）git stash命令用于处理Bug分支$ git stash //存储当前工作现场，等改完Bug再恢复 Saved working directory and index state WIP on dev: f52c633 add merge $ git stash list //查看stash内容列表 stash@{0}: WIP on dev: f52c633 add merge $ git stash pop //恢复现场的同时把stash内容也删了，相当于以下两条语句 $ git stash apply //恢复现场，但是恢复后，stash内容并不删除 $ git stash drop //删除stash内容 8）git remote命令用于处理多人协作问题$ git remote //查看远程库的信息 origin $ git remote -v //显示更详细的信息 9）git pull命令用于把最新的提交从origin/dev抓下来用于当你的小伙伴的最新提交和你试图推送的提交有冲突时，先用git pull命令用于把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 $ git branch --set-upstream-to=origin/dev dev //先建立本地dev分支与远程origin/dev分支的链接 Branch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;. $ git pull //将远程库最新更新抓取下来 Auto-merging env.txt CONFLICT (add/add): Merge conflict in env.txt Automatic merge failed; fix conflicts and then commit the result. 9）git rebase命令用于解决历史记录分叉的问题$ git rebase 三.标签管理1）git tag命令用来创建和删除标签$ git tag v1.0 //创建标签 $ git tag //查看标签 v1.0 $ git tag v0.9 f52c633 //给commit id已知的提交创建标签 $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb //创建带有说明的标签 $ git tag -d v0.1 //删除标签 Deleted tag &apos;v0.1&apos; (was f15b0dd) 2）git show命令用来查看标签信息$ git show v0.9 commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9) Author: Lililich &lt;lililich94@163.com&gt; Date: Fri May 18 21:56:54 2018 +0800 add merge diff --git a/readme.txt b/readme.txt ... 3）git push命令用来推送标签$ git push origin --tags //一次性推送全部尚未推送到远程的本地标签 Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 $ git tag -d v0.9 //先把标签从本地删除 Deleted tag &apos;v0.9&apos; (was f52c633) $ git push origin :refs/tags/v0.9 //再把标签从远程库删除 To github.com:michaelliao/learngit.git - [deleted] v0.9","path":"2019/03/28/Git基本用法/"},{"title":"Github+Hexo搭建个人博客","text":"作为一名技术小白，一直秉承着极高的热情向技术大佬们学习，可是学着学着就发现学过的东西很容易忘记，所以打算创建一个个人博客来进行记录总结，一方面可以总结学习过程中遇到的错误和困难，一方面也可以方便其他童鞋进行参考，接下来就和我一起学学怎么搭建个人博客吧！ 我们先来看一下大体的搭建步骤：• 获得个人网站域名• 安装Git和Node.js• GitHub创建个人仓库• 安装Hexo• 推送网站• 绑定域名• 更换主题 好啦，接下来就和我一起一步步进行操作吧~ 1. 获得个人网站域名首先进行域名注册的原因是，域名注册也需要审核哦，会耗费时间，所以我们先进行域名注册，在等待的时间里来进行接下来的其他操作，这样就省时省力啦！ 域名是网站的入口，也是网站的第一印象，比如饿了么的官网域名是：https://www.ele.me/，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀比如，我选择的是work后缀，原因很简单，因为在搞活动一年1块钱，所以果断下手。 申请域名的地方有很多，这里推荐阿里云：阿里云-为了无法计算的价值 ，申请入口：域名注册 购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用就好啦。 2. 安装Git和Node.js1) 安装Git什么是Git?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。Git下载地址：https://git-scm.com/download/win 现在大部分机子是64位的，选择64位的安装包下载安装，在命令行里输入git --version是否安装成功，若安装失败，参看其他详细的Git安装教程。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 2) 安装Node.jsHexo基于Node.js，Node.js下载地址：https://nodejs.org/en/download/ 下载安装包，注意安装Node.js会包含环境变量及npm的安装。检测Node.js是否安装成功，在命令行中输入node -v ；检测npm是否安装成功，在命令行中输入npm -v 。显示如下则安装成功哦！ 3. GitHub创建个人仓库登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号，创建并登录，点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：lililich.github.io。 接下来，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash。设置user.name和user.email配置信息：12$git config --global user.name \"你的GitHub用户名\"$git config --global user.email \"你的GitHub注册邮箱\" 生成ssh密钥文件,生成一个公钥和密钥，因为 GitHub 需要一个密钥才能与本地相连接。然后直接三个回车即可，默认不需要设置密码。1$ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" ssh key生成之后会默认保存在 C:/Users/电脑名用户名/.ssh目录中，打开这个目录，id_rsa.pub是公钥，id_rsa是密钥,接下来打印公钥信息：1$cat ~/.ssh/id_rsa.pub 打开 GitHub ，依次点击 头像--&gt;Settings--&gt;SSH and GPG keys--&gt;Add SSH key，Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key，SSH KEY 配置成功。在Git Bash中检测GitHub公钥设置是否成功，输入ssh git@github.com测试连接，显示如下则连接成功。 这里之所以设置GitHub密钥原因是：通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 4. 安装HexoHexo就是我们的个人博客网站的框架，这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。首先使用npm命令安装Hexo，输入：1$npm install -g hexo-cli 这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：1$hexo init blog 为了检测我们的网站雏形，分别按顺序输入以下三条命令：123$hexo new test_my_site //新建文章$hexo g //hexo generate生成$hexo s //hexo server启动服务预览 注意，当时直接在Blog文件夹中输入这三条指令一直报错，找了许久才找到了解决方法。https://www.jianshu.com/p/2f4aca924fdb这里形容得太贴切了，在大街上喊老婆肯定大海捞针啊哈哈哈，要进入相应的目录再喊指令就会成功了，就是说，我们要进入刚刚new初始化下的blog文件夹下运行上述三条指令。完成后，打开浏览器输入地址:localhost:4000就可以在本地看到我们写的第一篇博客啦！开不开心！兴不兴奋！ 5. 推送网站上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，两个网站不要搞混。 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改并保存为：1234deploy: type: gitrepo: https://github.com/lililich/lililich.github.io.git //这里填入你之前在GitHub上创建仓库的完整路径，记得加上.gitbranch: master 其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：1$npm install hexo-deployer-git --save 这时，我们分别输入三条命令：123$hexo clean //清除缓存，若是网页正常情况下可以忽略该条指令$hexo g //hexo generate生成网站$hexo d //hexo deploy部署网站 完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 http://xxxx.github.io (知乎排版可能会出现”http://“字样) 比如我的xxxx就是我的GitHub用户名：lililich你就会发现你的博客已经上线了，可以在网络上被访问了！访问网址为 http://xxxx.github.io 6. 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io (知乎排版可能会出现”http://“字样) 我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。第一步，登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析，然后添加解析。第一个记录类型是A，ping你的 http://xxxx.github.io 的ip地址，将ip地址填入记录值。第二个记录类型是CNAME，CNAME的记录值是：你的用户名.github.io,这里千万别弄错了。 第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名，如我的域名是lililich.work,保存添加。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。保存，命名为CNAME ，注意保存成所有文件而不是txt文件。完成这三步，进入blog目录中，按住shift键右击打开命令行，再依次输入：hexo clean hexo g hexo d这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 7. 更换主题如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes。 目前用的比较多的是Next主题，我自己使用的是cube主题。现在把默认主题更改成cube主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：1$https://github.com/ZEROKISEKI/hexo-theme-cube.git themes/cube //下载cube主题 这是将cube主题下载到blog目录的themes主题下的cube文件夹中。打开站点的_config.yml配置文件，修改主题theme：cube选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。接下来就去Markdown网站上学习一下写博客用到的语法吧,你就可以尽情的书写自己的博客啦！","path":"2019/03/22/Github+Hexo搭建个人博客/"},{"title":"Hexo基本语法","text":"让我们来学习下 Hexo 的基本语法。你也可以进入 documentation 来进行系统的学习。 如果在运用Hexo的时候出现疑问，你可以去 troubleshooting 上进行提问或者你可以上 GitHub 上寻求帮助。 Quick StartCreate a new post1$ hexo new \"My New Post\" //新建文章 More info: Writing Run server1$ hexo server //启动服务预览 More info: Server Generate static files1$ hexo generate //生成页面 More info: Generating Deploy to remote sites1$ hexo deploy //部署页面 More info: Deployment","path":"2019/03/20/hello-world/"}]}