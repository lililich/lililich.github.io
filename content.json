{"pages":[{"title":"categories","text":"","path":"categories/index.html"},{"title":"about-me","text":"关于我本人小姑娘，小硕一枚，年龄成谜。技术平平，可相貌上还过得去，人品上更是棒棒的；但是吧，由于大木桶原理，不能让技术成为自己的短板吧，于是奋发图强，从此小小的博客页面产生了，我会勤奋刻苦的。在我自己眼里，也许我就是一个小渣渣，但是，记住是在自己眼里，绝对不允许别人这么说哈哈哈。 马上就要开始找暑期实习了，最好是找一个可以爱上的工作，然后沉迷技术，无法自拔。加油，小姑凉！ 座右铭一天要做三件事：第一要笑，第二要微笑，第三要哈哈大笑 个人爱好喜欢听音乐，看书，运动，练瑜伽，十字绣也很厉害哦顺便提一句，如果去了KTV，那KTV麦霸就是我hhh 自我描述• 我是一个踏实认真，责任心强，敢于吃苦，从以前的工作经历中总结到，一个好的团队要有较强的团队精神，不能自己单打独斗，要知道一个团队的重要性；• 有较强的沟通和理解能力，思维活跃敢于创新，可以提出自己的看法，多交流才能多进步；• 热情开朗，自信大方，擅长与人交流，会成为团队的开心果，有较强的动手能力和学习能力。 联系我Weibo：莪叫_小畅Github：lililichEmail：lililich94.@163.comBlog：https://lililich.work 搭建博客的初衷作为一名技术小白，一直秉承着极高的热情向技术大佬们学习，可是学着学着就发现学过的东西很容易忘记，所以打算创建一个个人博客来进行记录总结，一方面可以总结学习过程中遇到的错误和困难，一方面也可以方便其他童鞋进行参考，让我们一起加油吧。","path":"about-me/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"Vue_CLI脚手架学习与搭建","text":"今天我们来学习一下Vue CLI脚手架，本文主要是总结Vue CLI脚手架搭建过程及总结遇到的问题，跟着我一起来学习吧~ 1.node.js安装与环境配置1.1 node.js安装 安装包下载地址：https://nodejs.org/en/ 下载完成后，双击node-v10.16.0-x64.msi，开始安装Node.js，全程默认一直点击下一步（注意：安装地址最后不要默认选择C盘，选择D盘），安装完毕后点击finish结束安装进程，然后在VS code终端，依次输入命令： 12node -vnpm -v 如果正确输出版本号，说明我们的NodeJS和NPM就安装好了，如下图所示： 此处说明下：新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西 1.2 node.js环境配置 说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到C:\\Users\\用户名\\AppData\\Roaming\\npm路径中，占C盘空间。 例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹D:\\software\\nodejs下创建两个文件夹node_global及node_cache如下图： 创建完两个空文件夹之后，打开终端窗口，输入12npm config set prefix \"D:\\software\\nodejs\\node_global\"npm config set cache \"D:\\software\\nodejs\\node_cache\" 接下来设置环境变量，控制面板-系统和安全-系统-高级系统设置-高级-环境变量 进入环境变量对话框，在系统变量下新建NODE_PATH，输入D:\\software\\nodejs\\node_global\\node_modules 将用户变量下的Path修改为D:\\software\\nodejs\\node_global修改前:修改后: 配置完后，安装个module测试下，我们就安装最常用的express模块，打开终端窗口， 输入如下命令进行模块的全局安装：npm install express - # -g是全局安装的意思修改后 可以看到express被安装到我们刚刚设置的路径下，就说明配置成功 2.Vue CLI安装与配置2.1 Vue CLI安装 可以使用下列任一命令安装这个新的包： 12npm install -g @vue/cliyarn global add @vue/cli 你还可以用这个命令来检查其版本是否正确 (3.x)：vue --version 2.2Vue CLI项目搭建2.2.1Vue CLI &gt;= 3时进行项目构建 我们安装的Vue CLI &gt;= 3，所以直接运行以下命令来创建一个新项目： 1vue create hello-world 你会被提示选取一个 preset。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性，这个默认的设置非常适合快速创建一个新项目的原型，而手动设置则提供了更多的选项，它们是面向生产的项目更加需要的。 在项目创建的过程中，你也会被提示选择喜欢的包管理器或使用淘宝 npm 镜像源以更快地安装依赖。这些选择也将会存入 ~/.vuerc 直接选取默认的设置就可以快速进行创建，就可以看到在安装各种插件，我们的项目正在下载搭建中： 再来试一个自定义安装的项目搭建，方向键上下移动，空格选中，Enter确定 再根据刚刚的选择会弹出来以下选框，按照自己需求进行选择 123456? Use history mode for router? //是否使用history模式的路由? Pick a CSS pre-processor //CSS预处理器选择? Pick a linter / formatter config: (Use arrow keys) //选择哪个ESLint自动化代码格式化检测? Pick additional lint features //选择语法检查的时期? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? //配置文件的存放位置? Save this as a preset for future projects? (y/N) //是否保存此预设(选择yes的话下次就可以不用进行配置) 出现以下界面说明项目搭建成功 安装后移动到目录 并启动，启动完毕后会提示我们浏览器访问地址12cd mydemo npm run serve // 这里和版本2不一样了。2是npm run dev 而版本3 是npm run serve 浏览器访问：http://localhost:8080/，效果如下：2.2.2Vue CLI &lt; 3时，拉取 2.x 模板 (旧版本)进行项目构建 Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： 12npm install -g @vue/cli-init # `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同vue init webpack mydemo 然后终端会出现下图“一问一答”模式，如图： 这里有几个需要说明一下，没说明的直接回车选择默认就好，对项目没多大影响，很傻瓜式：Project name：这个是项目名称，默认是输入时的那个名称，想改的话直接输入修改，也可以直接回车Install vue-router:是否需要vue-router，默认选择使用，这样生成好的项目就会有相关的路由配置文件Use ESLint to lint your code:是否使用ESLint，刚才说了我们这个项目需要使用所以也是直接回车，默认使用，这样会生成相关的ESLint配置Setup unit tests with Karma + Moch?: 是否安装单元测试。由于我们现在还没有单元测试，所以这里选择的是”N”，而不是直接回车哦Setup e2e tests with Nightwatch：是否安装e2e测试，这里我也同样选择的是“N”这几个配置选择yes 或者 no 对于我们项目最大的影响就是，如果选择了yes 则生成的项目会自动有相关的配置，有一些loader我们就要配套下载。所以如果我们确定不用的话最好不要yes，要么下一步要下很多没有用的loader 全部选择好回车就进行了生成项目，现在打开之前说过的package.json文件，找到devDependencies 和 dependencies ，在这里面可以删掉我们不需要的，其他就则都需要使用 npm install 下载安装，例如vue： npm install vue –save-dev 1npm install 依赖包 运行mydemo，输入命令 1npm run dev 在浏览器输入地址http://localhost:8080，看到页面，说明大功告成，一个Vue项目已经初始化完成 2.2.3使用图形化界面进行项目构建 你也可以通过 vue ui 命令以图形化界面创建和管理项目： 1vue ui 上述命令会打开一个浏览器窗口，并以图形化界面将你引导至项目创建的流程。 2.3项目目录结构 通过vue-cli搭建一个vue项目，会自动生成一系列文件，而这些文件具体是怎样的结构、文件对应起什么作用，可以参考网上的解释，有了这个框架，接下来就可以根据自己的喜好来重新制定网站了2.4修改端口号 vue-cli构建的项目，在控制台npm run dev启动后，默认的调试地址是8080端口的。但是大部分时候，我们都要并行几个项目开发，很有可能已经占用了8080端口，所以就涉及到如何去更改调试地址的端口号了 修改路径：2.x：config --&gt; index.js3.0+：node_modules--&gt;@vue--&gt;cli-service--&gt;lib--&gt;commands--&gt;build--&gt;serve.j","path":"2019/07/18/Vue-CLI脚手架学习与搭建/"},{"title":"自定义构建Echarts问题描述","text":"今天我们来学习一下Echarts，本文主要是总结自定义构建Echarts遇到的问题，跟着我一起来学习吧~ 1.使用命令行，创建自己的工程：12mkdir myProjectcd myProject 2.在 myProject 目录下使用命令行，初始化工程的 npm 环境并安装 echarts（这里前提是您已经安装了 npm）：12npm initnpm install echarts --save 3.使用 echarts 提供的构建脚本自定义构建在这个例子中，我们要创建一个饼图，并且想自定义构建一个只含有饼图的 echarts 文件，从而能使 echarts 文件的大小比较小一些。echarts 已经提供了构建脚本 echarts/build/build.js，基于 Node.js 运行。我们可以在 myProject 目录下使用命令行，看到它的使用方式：1node node_modules/echarts/build/build.js --help 注意：这里会出现报错1Error: Cannot find module 'XXX' 翻译出来就是找不到 ‘XXX’ 组件，我也是通过查找的方法，进行实践，缺啥就安装啥，可能会有很多的模块找不到，就一个一个进行安装就行，执行12npm install XXX --save//这里的 XXX 指的是报错中缺少的模块名 以上几个模块安装成功就会显示如下，你可以输入–help指令查看参数的含义：其中我们在这个例子里会用到的参数有： -i：代码入口文件，可以是绝对路径或者基于当前命令行路径的相对路径。 -o：生成的 bundle 文件，可以是绝对路径或者基于当前命令行路径的相对路径。 –min：是否压缩文件（默认不压缩），并且去多余的打印错误信息的代码，形成生产环境可用的文件。 –lang ：是否使用其他语言版本，默认是中文。例如：–lang en 表示使用英文，–lang my/langXX.js 表示构建时使用 /my/langXX.js 替代 echarts/lib/lang.js 文件。 –sourcemap：是否输出 source map，以便于调试。 –format：输出的格式，可选 ‘umb’（默认）、’amd’、’iife’、’cjs’、’es’。4.既然我们想自定义构建一个只含有饼图的 echarts 文件，我们需要创建一个入口文件，可以命名为 myProject/echarts.custom.js，文件里会引用所需要的 echarts 模块：123456// 引入 echarts 主模块。export * from 'echarts/src/echarts';// 引入饼图。import 'echarts/src/chart/pie';// 在这个场景下，可以引用 `echarts/src` 或者 `echarts/lib` 下的文件（但是不可混用），// 参见下方的解释：“引用 `echarts/lib/**` 还是 `echarts/src/**`”。 5.然后我们可以在 myProject 目录下使用命令行，这样开始构建：1node node_modules/echarts/build/build.js --min -i echarts.custom.js -o lib/echarts.custom.min.js 注意：这里会出现报错1TypeError: uglifyPlugin is not a function 出错原因是依赖插件rollup-plugin-uglify版本过高，查看当前版本：1npm view rollup-plugin-uglify versions 重新npm install特定的版本：1npm install rollup-plugin-uglify@3.0.0 --save 这回就能构建成功了这样，myProject/lib/echarts.custom.min.js 就生成了。 6.我们可以创建 myProject/pie.html 来使用它：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;myProject&lt;/title&gt; &lt;!-- 引入 lib/echarts.custom.min.js --&gt; &lt;script src=\"lib/echarts.custom.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt; &lt;script&gt; // 绘制图表。 echarts.init(document.getElementById('main')).setOption(&#123; series: &#123; type: 'pie', data: [ &#123;name: 'A', value: 1212&#125;, &#123;name: 'B', value: 2323&#125;, &#123;name: 'C', value: 1919&#125; ] &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.运行程序，这样一个饼图就出来啦","path":"2019/06/15/自定义构建Echarts问题描述/"},{"title":"Echarts的学习与使用","text":"今天我们来学习一下Echarts，ECharts是一个纯JavaScript图表库，底层依赖于轻量级的Canvas类库ZRender，基于BSD开原协议，是一款非常优秀的可视化前端框架，本文基于Vue CLI脚手架，来实现Echarts的引用，跟着我一起来学习吧~ 一.引入一个简单的图表首先npm安装Echarts1npm install echarts --save 接下来打开public-&gt;src-&gt;main.js来引入echarts12import myCharts from './comm/js/myCharts.js'Vue.use(myCharts) 绘制一个简单的容器12345&lt;template&gt;&lt;h-page-content&gt;&lt;div id=\"myChart\" :style=\"&#123;width: '600px', height: '400px'&#125;\"&gt;&lt;/div&gt;&lt;/h-page-content&gt;&lt;/template&gt; 创建一个简单的图表你可以在这里查找样例echarts图表，注意：我们要在mounted生命周期函数中实例化echarts对象。因为我们要确保dom元素已经挂载到页面中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script&gt;export default &#123; name: 'EchartsIndex', mounted () &#123; this.drawLine() &#125;, methods: &#123; drawLine () &#123; // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption(&#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123; trigger: 'item', formatter: \"&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)\" &#125;, legend: &#123; orient: 'vertical', x: 'left', data:['直接访问','邮件营销','联盟广告','视频广告','搜索引擎'] &#125;, series: [&#123; name:'访问来源', type:'pie', radius: ['50%', '70%'], avoidLabelOverlap: false, label: &#123; normal: &#123; show: false, position: 'center' &#125;, emphasis: &#123; show: true, textStyle: &#123; fontSize: '30', fontWeight: 'bold' &#125; &#125; &#125;, labelLine: &#123; normal: &#123; show: false &#125; &#125;, data:[ &#123;value:335, name:'直接访问'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:234, name:'联盟广告'&#125;, &#123;value:135, name:'视频广告'&#125;, &#123;value:1548, name:'搜索引擎'&#125; ] &#125;] &#125;) &#125; &#125;&#125;&lt;/script&gt; 这样你的第一个图表就诞生了！ 接下来就可以根据自己的需求来自定义图表了 二.图表参数配置学习更多可以查看Echarts配置项手册 1.title标题组件，包含主标题和副标题。在 ECharts 2.x 中单个 ECharts 实例最多只能拥有一个标题组件。但是在 ECharts 3 中可以存在任意多个标题组件，这在需要标题进行排版，或者单个实例中的多个图表都需要标题时会比较有用。1234title: &#123; text: '金融资产详情', //主标题 subtext: '金融资产次级标题' //副标题&#125; 2.tooltip提示框组件。提示框组件的通用介绍：提示框组件可以设置在多种地方： 可以设置在全局，即 tooltip 可以设置在坐标系中，即 grid.tooltip、polar.tooltip、single.tooltip 可以设置在系列中，即 series.tooltip 可以设置在系列的每个数据项中，即 series.data.tooltip123456789tooltip: &#123; trigger: 'item', //数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用 backgroundColor: 'rgb(245,245,245,0.9)', //设置提示框背景颜色 padding: [15, 20], //设置提示框内边距 textStyle: &#123; color: '#4F4F4F' //设置提示框内字体颜色 &#125;, extraCssText: 'box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);' //额外附加到浮层的 css 样式，如为浮层添加阴影&#125; 3.legend图例组件。图例组件展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。ECharts 3 中单个 echarts 实例中可以存在多个图例组件，会方便多个图例的布局。当图例数量过多时，可以使用 滚动图例（垂直） 或 滚动图例（水平）。1234567891011legend: &#123; bottom: 0, //设置图例组件离容器下侧的距离 left: 'center', //设置图例组件离容器左侧的距离 icon: 'circle', //设置图例组件图标为圆形 textStyle: &#123; color: '#4F4F4F', //设置图例组件字体颜色 fontSize: '14' //设置图例组件字体大小 &#125;, hoverAnimation: false, //是否开启 hover 在扇区上的放大动画效果 data: ['存款余额', '活期余额', '定期余额', '通知存款余额', '贷款余额', '理财余额', '国债余额', '基金余额'] //图例的数据数组&#125; 4.color设置数据区域颜色。1color: ['#1E90FF', '#40E0D0', '#43CD80', '#EEC900', '#FF6A6A', '#9B30FF', '#3A5FCD', '#27408B'] 5.series系列列表。每个系列通过 type 决定自己的图表类型。123456789101112131415161718192021222324252627282930313233343536373839404142series: [&#123; // name: '', type: 'pie', radius: ['30%', '50%'], //设置饼图半径 selectedMode: 'single', //选中模式，表示是否支持多个选中，默认关闭 hoverAnimation: false, //是否开启 hover 在扇区上的放大动画效果 label: &#123; normal: &#123; textStyle: &#123; fontSize: '14', //设置饼图文字格式 color: '#4F4F4F' //设置饼图文字颜色 &#125;, formatter: function (data) &#123; return data.name + ' : ' + data.percent.toFixed(2) + ' % ' //用来格式化引出文字文本，支持字符串模板和回调函数两种形式，保留两位小数 &#125; &#125; &#125;, labelLine: &#123; smooth: true //是否平滑视觉引导线，默认不平滑 &#125;, data: [ //系列中的数据内容数组 &#123; value: 982, name: '存款余额' &#125;, &#123; value: 968, name: '活期余额' &#125;, &#123; value: 1332, name: '定期余额' &#125;, &#123; value: 2034, name: '通知存款余额' &#125;, &#123; value: 2582, name: '贷款余额' &#125;, &#123; value: 1403, name: '理财余额' &#125;, &#123; value: 0, name: '国债余额' &#125;, &#123; value: 701, name: '基金余额' &#125; ], itemStyle: &#123; normal: &#123; borderWidth: 2, //设置描边线宽 borderColor: 'white' //设置描边颜色 &#125;, emphasis: &#123; //图形的高亮样式 shadowColor: 'rgba(0, 0, 0, 0.5)' //文字块的背景阴影颜色 &#125; &#125;&#125;] 详细的学习教程可以参考Echarts学习网址","path":"2019/06/08/Echarts的学习与使用/"},{"title":"十大排序算法","text":"今天我们来学习一下排序算法，排序算法是《数据结构与算法》中最基本的算法之一，虽说学过这门课，但几种排序总是讲述不清，今天来做一个系统的学习归纳，跟着我一起来学习吧~ 排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的十大内部排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。用一张图概括： 关于时间复杂度： O(n2) 平方阶排序: 插入排序、选择排序和冒泡排序；O(nlog2n) 线性对数阶排序: 快速排序、堆排序和归并排序；O(n1+§) 排序(§ 是介于 0 和 1 之间的常数): 希尔排序；O(n) 线性阶排序: 基数排序、桶、箱排序。 关于稳定性： 排序算法的稳定性:若待排序的序列中，存在多个具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 一.冒泡排序1.算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 二.选择排序1.算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 三.插入排序1.算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 2.动画演示 3.参考代码（JavaScript 代码实现）1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex+1] = arr[preIndex]; preIndex--; &#125; arr[preIndex+1] = current; &#125; return arr;&#125; 四.希尔排序1.算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 2.动画演示 3.参考代码（JavaScript 代码实现）123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len/3) &#123; //动态定义间隔序列 gap =gap*3+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; return arr;&#125; 五.归并排序1.算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516171819202122232425262728293031function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; 六.快速排序1.算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 2.动画演示 3.参考代码（JavaScript 代码实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr;&#125;function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function partition2(arr, low, high) &#123; let pivot = arr[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; arr[high] &gt; pivot) &#123; --high; &#125; arr[low] = arr[high]; while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123; ++low; &#125; arr[high] = arr[low]; &#125; arr[low] = pivot; return low;&#125;function quickSort2(arr, low, high) &#123; if (low &lt; high) &#123; let pivot = partition2(arr, low, high); quickSort2(arr, low, pivot - 1); quickSort2(arr, pivot + 1, high); &#125; return arr;&#125; 七.堆排序1.算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 2.动画演示 3.参考代码（JavaScript 代码实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest); &#125;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length-1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr;&#125; 八.计数排序1.算法步骤 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1) 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue+1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr;&#125; 九.桶排序1.算法步骤 设置固定数量的空桶。 把数据放到对应的桶中。 对每个不为空的桶中数据进行排序。 拼接不为空的桶中数据，得到结果。 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; //桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; //利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125; 十.基数排序1.算法步骤 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零 从最低位开始，依次进行一次排序 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516171819202122232425//LSD Radix Sortvar counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125; 本文只是对十大排序算法进行了简要描述，本人着重于学习Web开发，所以摘取的是JavaScript的代码，如果还想进一步深入学习，可以参考菜鸟教程的 十大排序算法 的教学网站~","path":"2019/04/01/十大排序算法/"},{"title":"Markdown基本语法","text":"进行完博客搭建，让我们来学习一下怎么写博客吧，学习一下Markdown的基本语法~本站只是对Markdown语法进行简要叙述，如果想要加深一步学习，可以去Markdown官网上进行学习哦~ 什么是Markdown？ Markdown 的目标是实现「易读易写」。Markdown 语法的目标是：成为一种适用于网络的书写语言。Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 markdown的优点： 语法简单 更专注内容而非排版，排版只是为了更清楚的展现内容 md轻松转换html及pdf，网络友好 1.标题行首插入1到6个# ，对应到标题1到6阶，例如 # 这是 H1，一级标题 ## 这是 H2，二级标题 ###### 这是 H6，六级标题 2.段落一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。普通段落不该用空格或制表符来缩进。如果你确实想要依赖 Markdown 来插入 标签的话，在插入处先按入两个以上的空格然后回车。 3.列表Markdown 支持有序列表和无序列表。无序列表使用星号、加号或是减号作为列表标记，如： * 列表一 * 列表二 * 列表三 有序列表则使用数字接着一个英文句点，如： 1. 有序列表一 2. 有序列表二 3. 有序列表三 4.分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 5.链接要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，例如： [Lililich&apos;s Blog](https://lililich.work) 要建立一个自动链接，只要是用&lt;&gt;括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;https://lililich.work&gt; 6.图片Markdown 使用一种和链接很相似的语法来标记图片。行内式的图片语法详细叙述如下：1.一个惊叹号 !2.接着一个方括号，里面放上图片的替代文字3.接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 ![Lililich&apos;s photo](/path/to/img.jpg &quot;Optional title&quot;) 7.代码区要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落。 这是一个代码区块。 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： 这是一个 `行内` 代码。 如果用三个反引号（`）把它包起来即可在网页中显示为多行代码块，例如： 12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;这是一段文字&lt;/&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8.强调字体Markdown 使用星号( * )和底线( _ )作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong> ，例如： *这是斜体* **这是粗体** 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \\*这里的星号是普通符号，不会用作斜体显示\\* 9.区块引用Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式，在 Markdown 文件中建立一个区块引用，首先自己先断好行，然后在每行的最前面加上 &gt; ，例如： &gt;这是一段引用 &gt;这是另一段引用 好啦，常用的Markdown的语法学习就到这里啦，如果想要加深一步学习，可以去Markdown官网上进行学习哦~","path":"2019/03/31/Markdown基本语法/"},{"title":"Git基本用法","text":"Github是一个远程仓库，上传下载文件都需要运用到Git命令，让我们学习一下怎么运用Git吧~本站只是对Github进行简要概括，方便运用时查找，如果想要加深一步学习，可以去廖雪峰Git教学网站上进行学习哦~ 什么是Git命令？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。Git有什么特点？简单来说就是：高端大气上档次！ 集中式版本控制系统(如CVS和SVN) ：版本库是集中存放在中央服务器的，工作时从版本库下载，修改后重新上传版本库，完整的版本库保存在中央服务器，集中式版本控制系统最大的毛病就是必须联网才能工作。 分布式管理系统(如Git) ：每个人电脑里都会有完整的版本库，只推送修改即可，不必联网。Git的优势不单是不必联网这么简单，Git极其强大的分支管理，把SVN等远远抛在了后面。Git的工作描述图如下： 一.版本管理1）git init创建版本库,初始化本地仓库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。通过git init命令把这个目录变成Git可以管理的仓库： $ git init Initialized empty Git repository in /Users/michael/learngit/.git/ 2）git add 将修改好的文件上传到版本库$ git add readme.txt $ git add file2.txt file3.txt //可同时添加多个文件 3）git commit 将修改好的文件上传到仓库-m参数后面输入的是本次提交的说明 $ git commit -m &quot;wrote a readme file&quot; [master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 4）git status 命令可以让我们时刻掌握仓库当前的状态$ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 5）git diff 命令可以查看具体修改内容$ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. 6）git log 命令可以查看近期提交日志，可以获取commit id加上--pretty=oneline参数可省去多余的信息 $ git log commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) Author: Lililich &lt;lililich94@163.com&gt; Date: Fri May 18 21:06:15 2018 +0800 wrote a readme file 7）git reset 命令进行版本回退用HEAD表示当前版本，上一个版本就是HEAD^，往上100个版本写成HEAD~100；也可以用commit id来进行版本回退 $ git reset --hard HEAD^ HEAD is now at e475afc add distributed $ git reset --hard 1094a HEAD is now at 83b0afe append GPL 8）git relog 命令用来记录每一次命令，方便查找commit id$ git reflog e475afc HEAD@{1}: reset: moving to HEAD^ 1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL e475afc HEAD@{3}: commit: add distributed eaadf4e HEAD@{4}: commit (initial): wrote a readme file 9）git checkout 命令用来撤销修改--很重要，没有--，就变成了“切换到另一个分支”的命令 //若修改仅保存在工作区，可直接撤销修改 $ git checkout -- readme.txt //若已经git add到了暂存区，先将暂存区版本撤销再丢弃工作区修改 $ git reset HEAD readme.txt $ git checkout -- readme.txt //若已经git commit到了远程仓库，直接进行版本回退 $ git reset --hard HEAD^ 10）git rm 命令用来删除文件删除版本库文件先git rm再git commit提交 $ git rm test.txt rm &apos;test.txt&apos; $ git commit -m &quot;remove test.txt&quot; [master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt $ git checkout -- test.txt //还可以将误删的文件从版本库还原 11）git remote add 命令把本地仓库与GitHub远程仓库相关联$ git remote add origin git@github.com:lililich/learngit.git 12）git push命令把本地当前分支master推送到远程-u参数代表Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令 $ git push -u origin master Counting objects: 20, done. Delta compression using up to 4 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done. Total 20 (delta 5), reused 0 (delta 0) remote: Resolving deltas: 100% (5/5), done. To github.com:lililich/learngit.git * [new branch] master -&gt; master Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. 13）git clone命令用于从远程库克隆代码$ git clone git@github.com:lililich/gitskills.git Cloning into &apos;gitskills&apos;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3 Receiving objects: 100% (3/3), done. 二.分支管理1）git checkout命令用来创建并切换分支$ git checkout -b dev //用来创建并切换分支，相当于以下两条命令 Switched to a new branch &apos;dev&apos; $ git branch dev //创建分支 $ git checkout dev //切换分支 2）git branch命令用来命查看当前分支命令会列出所有分支，当前分支前面会标一个*号 $ git branch * dev master 3）git merge命令用于合并指定分支到当前分支$ git merge dev Updating d46f35e..b17d20e Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) 4）git branch命令也用于创建和操作分支不加参数git branch &lt;name&gt;表示创建分支，加上参数git branch -d &lt;name&gt;用于删除分支，git branch -D &lt;name&gt;用于删除一个还未被合并过的分支 $ git branch -d dev Deleted branch dev (was b17d20e). $ git branch -D feature-vulcan Deleted branch feature-vulcan (was 287773e). 5）git log --graph命令用于查看分之合并情况当Git无法自动合并分支时，就必须首先解决冲突。git status查看冲突文件，解决冲突后，再提交，合并完成。合并完成用git log --graph命令也用于查看分之合并情况 $ git log --graph --pretty=oneline --abbrev-commit * cf810e4 (HEAD -&gt; master) conflict fixed |\\ | * 14096d0 (feature1) AND simple * | 5dc6824 &amp; simple |/ * b17d20e branch test * d46f35e (origin/master) remove test.txt 6）git merge --no-ff命令用于表示禁用Fast forward,--no-ff参数表示使合并后的历史有分支，能看出曾做过合并通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 $ git merge --no-ff -m &quot;merge with no-ff&quot; dev Merge made by the &apos;recursive&apos; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 7）git stash命令用于处理Bug分支$ git stash //存储当前工作现场，等改完Bug再恢复 Saved working directory and index state WIP on dev: f52c633 add merge $ git stash list //查看stash内容列表 stash@{0}: WIP on dev: f52c633 add merge $ git stash pop //恢复现场的同时把stash内容也删了，相当于以下两条语句 $ git stash apply //恢复现场，但是恢复后，stash内容并不删除 $ git stash drop //删除stash内容 8）git remote命令用于处理多人协作问题$ git remote //查看远程库的信息 origin $ git remote -v //显示更详细的信息 9）git pull命令用于把最新的提交从origin/dev抓下来用于当你的小伙伴的最新提交和你试图推送的提交有冲突时，先用git pull命令用于把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 $ git branch --set-upstream-to=origin/dev dev //先建立本地dev分支与远程origin/dev分支的链接 Branch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;. $ git pull //将远程库最新更新抓取下来 Auto-merging env.txt CONFLICT (add/add): Merge conflict in env.txt Automatic merge failed; fix conflicts and then commit the result. 9）git rebase命令用于解决历史记录分叉的问题$ git rebase 三.标签管理1）git tag命令用来创建和删除标签$ git tag v1.0 //创建标签 $ git tag //查看标签 v1.0 $ git tag v0.9 f52c633 //给commit id已知的提交创建标签 $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb //创建带有说明的标签 $ git tag -d v0.1 //删除标签 Deleted tag &apos;v0.1&apos; (was f15b0dd) 2）git show命令用来查看标签信息$ git show v0.9 commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9) Author: Lililich &lt;lililich94@163.com&gt; Date: Fri May 18 21:56:54 2018 +0800 add merge diff --git a/readme.txt b/readme.txt ... 3）git push命令用来推送标签$ git push origin --tags //一次性推送全部尚未推送到远程的本地标签 Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 $ git tag -d v0.9 //先把标签从本地删除 Deleted tag &apos;v0.9&apos; (was f52c633) $ git push origin :refs/tags/v0.9 //再把标签从远程库删除 To github.com:michaelliao/learngit.git - [deleted] v0.9","path":"2019/03/28/Git基本用法/"},{"title":"Github+Hexo搭建个人博客","text":"作为一名技术小白，一直秉承着极高的热情向技术大佬们学习，可是学着学着就发现学过的东西很容易忘记，所以打算创建一个个人博客来进行记录总结，一方面可以总结学习过程中遇到的错误和困难，一方面也可以方便其他童鞋进行参考，接下来就和我一起学学怎么搭建个人博客吧！ 我们先来看一下大体的搭建步骤：• 获得个人网站域名• 安装Git和Node.js• GitHub创建个人仓库• 安装Hexo• 推送网站• 绑定域名• 更换主题 好啦，接下来就和我一起一步步进行操作吧~ 1. 获得个人网站域名首先进行域名注册的原因是，域名注册也需要审核哦，会耗费时间，所以我们先进行域名注册，在等待的时间里来进行接下来的其他操作，这样就省时省力啦！ 域名是网站的入口，也是网站的第一印象，比如饿了么的官网域名是：https://www.ele.me/，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀比如，我选择的是work后缀，原因很简单，因为在搞活动一年1块钱，所以果断下手。 申请域名的地方有很多，这里推荐阿里云：阿里云-为了无法计算的价值 ，申请入口：域名注册 购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用就好啦。 2. 安装Git和Node.js1) 安装Git什么是Git?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。Git下载地址：https://git-scm.com/download/win 现在大部分机子是64位的，选择64位的安装包下载安装，在命令行里输入git --version是否安装成功，若安装失败，参看其他详细的Git安装教程。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 2) 安装Node.jsHexo基于Node.js，Node.js下载地址：https://nodejs.org/en/download/ 下载安装包，注意安装Node.js会包含环境变量及npm的安装。检测Node.js是否安装成功，在命令行中输入node -v ；检测npm是否安装成功，在命令行中输入npm -v 。显示如下则安装成功哦！ 3. GitHub创建个人仓库登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号，创建并登录，点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：lililich.github.io。 接下来，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash。设置user.name和user.email配置信息：12$git config --global user.name \"你的GitHub用户名\"$git config --global user.email \"你的GitHub注册邮箱\" 生成ssh密钥文件,生成一个公钥和密钥，因为 GitHub 需要一个密钥才能与本地相连接。然后直接三个回车即可，默认不需要设置密码。1$ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" ssh key生成之后会默认保存在 C:/Users/电脑名用户名/.ssh目录中，打开这个目录，id_rsa.pub是公钥，id_rsa是密钥,接下来打印公钥信息：1$cat ~/.ssh/id_rsa.pub 打开 GitHub ，依次点击 头像--&gt;Settings--&gt;SSH and GPG keys--&gt;Add SSH key，Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key，SSH KEY 配置成功。在Git Bash中检测GitHub公钥设置是否成功，输入ssh git@github.com测试连接，显示如下则连接成功。 这里之所以设置GitHub密钥原因是：通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 4. 安装HexoHexo就是我们的个人博客网站的框架，这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。首先使用npm命令安装Hexo，输入：1$npm install -g hexo-cli 这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：1$hexo init blog 为了检测我们的网站雏形，分别按顺序输入以下三条命令：123$hexo new test_my_site //新建文章$hexo g //hexo generate生成$hexo s //hexo server启动服务预览 注意，当时直接在Blog文件夹中输入这三条指令一直报错，找了许久才找到了解决方法。https://www.jianshu.com/p/2f4aca924fdb这里形容得太贴切了，在大街上喊老婆肯定大海捞针啊哈哈哈，要进入相应的目录再喊指令就会成功了，就是说，我们要进入刚刚new初始化下的blog文件夹下运行上述三条指令。完成后，打开浏览器输入地址:localhost:4000就可以在本地看到我们写的第一篇博客啦！开不开心！兴不兴奋！ 5. 推送网站上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，两个网站不要搞混。 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改并保存为：1234deploy: type: gitrepo: https://github.com/lililich/lililich.github.io.git //这里填入你之前在GitHub上创建仓库的完整路径，记得加上.gitbranch: master 其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：1$npm install hexo-deployer-git --save 这时，我们分别输入三条命令：123$hexo clean //清除缓存，若是网页正常情况下可以忽略该条指令$hexo g //hexo generate生成网站$hexo d //hexo deploy部署网站 完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 http://xxxx.github.io (知乎排版可能会出现”http://“字样) 比如我的xxxx就是我的GitHub用户名：lililich你就会发现你的博客已经上线了，可以在网络上被访问了！访问网址为 http://xxxx.github.io 6. 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io (知乎排版可能会出现”http://“字样) 我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。第一步，登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析，然后添加解析。第一个记录类型是A，ping你的 http://xxxx.github.io 的ip地址，将ip地址填入记录值。第二个记录类型是CNAME，CNAME的记录值是：你的用户名.github.io,这里千万别弄错了。 第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名，如我的域名是lililich.work,保存添加。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。保存，命名为CNAME ，注意保存成所有文件而不是txt文件。完成这三步，进入blog目录中，按住shift键右击打开命令行，再依次输入：hexo clean hexo g hexo d这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 7. 更换主题如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes。 目前用的比较多的是Next主题，我自己使用的是cube主题。现在把默认主题更改成cube主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：1$https://github.com/ZEROKISEKI/hexo-theme-cube.git themes/cube //下载cube主题 这是将cube主题下载到blog目录的themes主题下的cube文件夹中。打开站点的_config.yml配置文件，修改主题theme：cube选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。接下来就去Markdown网站上学习一下写博客用到的语法吧,你就可以尽情的书写自己的博客啦！","path":"2019/03/22/Github+Hexo搭建个人博客/"},{"title":"Hexo基本语法","text":"让我们来学习下 Hexo 的基本语法。你也可以进入 documentation 来进行系统的学习。 如果在运用Hexo的时候出现疑问，你可以去 troubleshooting 上进行提问或者你可以上 GitHub 上寻求帮助。 Quick StartCreate a new post1$ hexo new \"My New Post\" //新建文章 More info: Writing Run server1$ hexo server //启动服务预览 More info: Server Generate static files1$ hexo generate //生成页面 More info: Generating Deploy to remote sites1$ hexo deploy //部署页面 More info: Deployment","path":"2019/03/20/hello-world/"}]}