{"pages":[{"title":"categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"},{"title":"about-me","text":"关于我本人小姑娘，小硕一枚，年龄成谜。技术平平，可相貌上还过得去，人品上更是棒棒的；但是吧，由于大木桶原理，不能让技术成为自己的短板吧，于是奋发图强，从此小小的博客页面产生了，我会勤奋刻苦的。在我自己眼里，也许我就是一个小渣渣，但是，记住是在自己眼里，绝对不允许别人这么说哈哈哈。 马上就要开始找暑期实习了，最好是找一个可以爱上的工作，然后沉迷技术，无法自拔。加油，小姑凉！ 座右铭一天要做三件事：第一要笑，第二要微笑，第三要哈哈大笑 个人爱好喜欢听音乐，看书，运动，练瑜伽，十字绣也很厉害哦顺便提一句，如果去了KTV，那KTV麦霸就是我hhh 自我描述• 我是一个踏实认真，责任心强，敢于吃苦，从以前的工作经历中总结到，一个好的团队要有较强的团队精神，不能自己单打独斗，要知道一个团队的重要性；• 有较强的沟通和理解能力，思维活跃敢于创新，可以提出自己的看法，多交流才能多进步；• 热情开朗，自信大方，擅长与人交流，会成为团队的开心果，有较强的动手能力和学习能力。 联系我Weibo：莪叫_小畅Github：lililichEmail：lililich94@163.comBlog：https://lililich.work 搭建博客的初衷作为一名技术小白，一直秉承着极高的热情向技术大佬们学习，可是学着学着就发现学过的东西很容易忘记，所以打算创建一个个人博客来进行记录总结，一方面可以总结学习过程中遇到的错误和困难，一方面也可以方便其他童鞋进行参考，让我们一起加油吧。","path":"about-me/index.html"}],"posts":[{"title":"EventLoop详解","text":"EventLoop详解什么是进程与线程？相信大家经常会听到 JS 是单线程执行的，但是你是否疑惑过什么是线程？讲到线程，那么肯定也得说一下进程。本质上来说，两个名词都是 CPU 工作时间片的一个描述。 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。 线程是进程中的更小单位，描述了执行一段指令所需的时间。 把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。当然前面两点在服务端中更容易体现，对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。 什么是执行栈？ 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。 当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，foo 函数后执行，当执行完毕后就从栈中弹出了。 平时在开发中，大家也可以在报错中找到执行栈的痕迹 function foo() { throw new Error(&apos;error&apos;) } function bar() { foo() } bar() 大家可以在上图清晰的看到报错在 foo 函数，foo 函数又是在 bar 函数中调用的。 当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题 function bar() { bar() } bar() 浏览器中的 Event Loop 当我们执行 JS 代码的时候其实就是往执行栈中放入函数，那么遇到异步代码的时候该怎么办？其实当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。下面来看以下代码的执行顺序： //执行顺序 script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout 首先先来解释下上述代码的 async 和 await 的执行顺序。当我们调用 async1 函数时，会马上输出 async2 end，并且函数返回一个 Promise，接下来在遇到 await的时候会就让出线程开始执行 async1 外的代码，所以我们完全可以把 await 看成是让出线程的标志。 然后当同步代码全部执行完毕以后，就会去执行所有的异步代码，那么又会回到 await 的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，接下来去执行 then 中的回调，当两个 then 中的回调全部执行完毕以后，又会回到 await 的位置处理返回值，这时候你可以看成是 Promise.resolve(返回值).then()，然后 await 后的代码全部被包裹进了 then 的回调中，所以 console.log(‘async1 end’) 会优先执行于 setTimeout。 如果你觉得上面这段解释还是有点绕，那么我把 async 的这两个函数改造成你一定能理解的代码 new Promise((resolve, reject) =&gt; { console.log(&apos;async2 end&apos;) // Promise.resolve() 将代码插入微任务队列尾部 // resolve 再次插入微任务队列尾部 resolve(Promise.resolve()) }).then(() =&gt; { console.log(&apos;async1 end&apos;) }) 也就是说，如果 await 后面跟着 Promise 的话，async1 end 需要等待三个 tick 才能执行到。那么其实这个性能相对来说还是略慢的，所以 V8 团队借鉴了 Node 8 中的一个 Bug，在引擎底层将三次 tick 减少到了二次 tick。但是这种做法其实是违法了规范的，当然规范也是可以更改的，这是 V8 团队的一个 PR，目前已被同意这种做法。 Event Loop 执行顺序如下所示： 首先执行同步代码，这属于宏任务 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行 执行所有微任务 当执行完所有微任务后，如有必要会渲染页面 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数 所以以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout属于宏任务，所以会有以上的打印。 微任务:包括 process.nextTick ，promise ，MutationObserver。 宏任务:包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。 这里很多人会有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。 更多详情参考：https://blog.csdn.net/itKingOne/article/details/86502910","path":"2019/09/20/EventLoop详解/"},{"title":"webpack基本原理","text":"Webpack引入原因1.在网页中会引用哪些常见的静态资源？ JS.js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS.css .less .sass .scss Images.jpg .png .gif .bmp .svg 字体文件（Fonts）.svg .ttf .eot .woff .woff2 模板文件.ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 2.网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系（比如bootstrap依赖于jQuery） 3.如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； webpack是一个js打包工具，不一个完整的前端构建工具。它的流行得益于模块化和单页应用的流行。webpack提供扩展机制，在庞大的社区支持下各种场景基本它都可找到解决方案。 webpack原理 webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。并不是什么commonjs或者amd之类的模块化规范。 webpack就是识别你的 入口文件。识别你的模块依赖，来打包你的代码。至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。 webpack做的就是分析代码。转换代码，编译代码，输出代码。webpack本身是一个node的模块，所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的) webpack中每个模块有一个唯一的id，是从0开始递增的。整个打包后的bundle.js是一个匿名函数自执行。参数则为一个数组。数组的每一项都为个function。function的内容则为每个模块的内容，并按照require的顺序排列。 核心思想： 一切皆模块：正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。 按需加载：传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。 webpack核心概念 entry 一个可执行模块或库的入口文件。 chunk 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 chunk 这体现了webpack的打包机制。 loader 文件转换器，例如把es6转换为es5，scss转换为css。 plugin 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack加入功能。 webpack构建流程从启动webpack构建到输出结果经历了一系列过程，它们是： 解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。 从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。 递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。输出所有chunk到文件系统。 需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如UglifyJsPlugin会在loader转换递归完后对结果再使用UglifyJs压缩覆盖之前的结果。 如何实现一个简单的webpack 读取文件分析模块依赖 对模块进行解析执行(深度遍历) 针对不同的模块使用相应的loader 编译模块，生成抽象语法树AST。 循环遍历AST树，拼接输出js。 打包原理把所有依赖打包成一个bundle.js文件，通过代码分割成单元片段并按需加载。 如图，entry.js是入口文件，调用了util1.js和util2.js，而util1.js又调用了util2.js。 打包后的bundle.js例子 ******/ ([ /* 0 */ //模块id /***/ function(module, exports, __webpack_require__) { __webpack_require__(1); //require资源文件id __webpack_require__(2); /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { //util1.js文件 __webpack_require__(2); var util1=1; exports.util1=util1; /***/ }, /* 2 */ /***/ function(module, exports) { //util2.js文件 var util2=1; exports.util2=util2; /***/ } ... ... /******/ ]); bundle.js是以模块 id 为记号，通过函数把各个文件依赖封装达到分割效果，如上代码 id 为 0 表示 entry 模块需要的依赖， 1 表示 util1模块需要的依赖 require资源文件 id 表示该文件需要加载的各个模块，如上代码_webpack_require__(1) 表示 util1.js 模块，webpack_require(2) 表示 util2.js 模块 exports.util1=util1 模块化的体现，输出该模块 webpack-dev-serve常用命令参数修改package.json的script节点如下，其中 --open表示自动打开浏览器 --port 4321表示打开的端口号为4321 --hot表示启用浏览器热更新 --contentBase src指定启动的根目录 &quot;dev&quot;: &quot;webpack-dev-server --contentBase src --hot --port 4321 --open&quot; 注意：热更新用来进行减少不必要的代码更新，每次重新编译只会更新修改过的文件（相当于打补丁）热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明 使用webpack处理第三方类型在解析对于文件，会自动去调用响应的loaderloader 本质上是一个函数，输入参数是一个字符串，输出参数也是一个字符串。当然，输出的参数会被当成是 JS 代码，从而被 esprima 解析成 AST，触发进一步的依赖解析。webpack会按照从右到左的顺序执行loader。 webpack默认只能处理js类型的文件，无法处理其他的非js类型的文件，如果需要非JS类型的文件，我们需要手动安装一些合适的第三方loader加载器 webpack处理第三方文件类型的过程： 发现这个要处理的文件不是js文件，然后就去配置文件中，查找有没有对应的第三方loader规则 如果能找到对应的规则，就会调用相应的loader处理这种文件类型 在调用loader的时候，是从后往前调用的 当最后一个loader调用完毕，会把处理结果，交给webpack进行打包合并，最终输出到bundle.js中去 如使用webpack打包css文件 新建index.css文件 在main.js引入index.css import &apos;./css/index.css&apos; 如果要打包处理css文件，需要安装cnpm i style-loader css-loader -D 打开webpack.config.js这个配置文件，在里面新增一个配置节点叫module，它是一个对象，在这个module对象上有一个rules属性，是个数组，这个数组中存放了所有第三方文件的匹配和处理规则 module: { // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 { test: /.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] }//处理css文件的规则 ] } 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的","path":"2019/09/18/webpack基本原理/"},{"title":"js实现继承","text":"实现两个类 A 和 B, 且B类继承自A类，B类的实例可以调用A类的方法 1. 借用构造函数继承：用.call()和.apply()将父类构造函数引入子类函数；call() 方法：B.call(A, args1,args2);即A对象调用B对象的方法；apply() 方法：用作 this 的对象和要传递给函数的参数的数组 B.apply(A, arguments);即A对象应用B对象的方法 function A(propertyA){ this.propertyA=propertyA; this.fn1 = function(){ }; } function B(propertyB){ A.call(this,args1,args2);//A.apply(this,[]) this.propertyB = propertyB; } var b1 = new B(&quot;大毛&quot;); b.fn1(); 2. 原型链继承function A(propertyA){ this,propertyA = propertyA; this.fn = function(){} } function B(propertyB){ this.propertyB = propertyB; } B.prototype = new A(&quot;&quot;); var b1 = new B(&quot;&quot;); b1.fn(); 3. 混合方式：组合继承（组合原型链继承和借用构造函数继承）function A(propertyA){ this,propertyA = propertyA; this.fn = function(){} } function B(propertyB){ A.call(this,args1,args2);//A.apply(this,[]) this.propertyB = propertyB; } B.prototype = Object.create(A.prototype);//创建一个父类的原型对象，并返回这个新对象 B.prototype.constructor = B; var B=new B(&quot;张&quot;); b1.fn(); console.log(B instanceof A) //true 4. 对象冒充function A(){ this.name = &quot;name&quot;; this.sayName = function(){ console.log(this.name); } } function B(){ this.temp = A;//创建对象 this.temp();//调用方法 delete this.temp;//删除对象，以免覆盖父类 this.id = &quot;1&quot;; } var b = new B(); b.sayName();","path":"2019/09/06/js实现继承/"},{"title":"七种实现左侧固定，右侧自适应两栏布局的方法","text":"总结一下左边固定，右边自适应的两栏布局的七种方法。其中有老生常谈的float方法,BFC方法，也有CSS3的flex布局与grid布局。并非所有的布局都会在开发中使用，但是其中也会涉及一些知识点。常用的宽度自适应的方法通常是利用了block水平的元素宽度能随父容器调节的流动特性。另外一种思路是利用CSS中的calc()方法来动态设定宽度。还有一种思路是，利用CSS中的新型布局flex layout与grid layout。 首先创建基本的HTML布局和最基本的样式。 &lt;div class=&quot;wrapper&quot; id=&quot;wrapper&quot;&gt; &lt;div class=&quot;left&quot;&gt; 左边固定宽度，高度不固定 &lt;/br&gt; &lt;/br&gt;&lt;/br&gt;&lt;/br&gt;高度有可能会很小，也可能很大。 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 这里的内容可能比左侧高，也可能比左侧低。宽度需要自适应。&lt;/br&gt; 基本的样式是，两个div相距20px, 左侧div宽 120px &lt;/div&gt; &lt;/div&gt; 基本的样式是，两个盒子相距20px, 左侧盒子宽 120px，右侧盒子宽度自适应。基本的CSS样式如下: .wrapper { padding: 15px 20px; border: 1px dashed #ff6c60; } .left { width: 120px; border: 5px solid #ddd; } .right { margin-left: 20px; border: 5px solid #ddd; } 下面的代码都是基于这套基本代码做覆盖，通过给容器添加不同的类来实现效果。 1.双inline-block方案.wrapper-inline-block { box-sizing: content-box; font-size: 0; // 消除空格的影响 } .wrapper-inline-block .left, .wrapper-inline-block .right { display: inline-block; vertical-align: top; // 顶端对齐 font-size: 14px; box-sizing: border-box; } .wrapper-inline-block .right { width: calc(100% - 140px); } 这种方法是通过width: calc(100% - 140px)来动态计算右侧盒子的宽度。需要知道右侧盒子距离左边的距离，以及左侧盒子具体的宽度(content+padding+border)，以此计算父容器宽度的100%需要减去的数值。同时，还需要知道右侧盒子的宽度是否包含border的宽度。 在这里，为了简单的计算右侧盒子准确的宽度，设置了子元素的box-sizing:border-box;以及父元素的box-sizing: content-box;。 同时，作为两个inline-block的盒子，必须设置vertical-align来使其顶端对齐。 另外，为了准确地应用计算出来的宽度，需要消除div之间的空格，需要通过设置父容器的font-size: 0;,或者用注释消除html中的空格等方法。 缺点: 需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的box-sizing 需要消除空格字符的影响 需要设置vertical-align: top满足顶端对齐。 2.双float方案.wrapper-double-float { overflow: auto; // 清除浮动 box-sizing: content-box; } .wrapper-double-float .left, .wrapper-double-float .right { float: left; box-sizing: border-box; } .wrapper-double-float .right { width: calc(100% - 140px); } 本方案和双float方案原理相同，都是通过动态计算宽度来实现自适应。但是，由于浮动的block元素在有空间的情况下会依次紧贴，排列在一行，所以无需设置display: inline-block;，自然也就少了顶端对齐，空格字符占空间等问题。 不过由于应用了浮动，父元素需要清除浮动。 缺点: 需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的box-sizing。 父元素需要清除浮动。 3.float+margin-left方案.wrapper-float { overflow: hidden; // 清除浮动 } .wrapper-float .left { float: left; } .wrapper-float .right { margin-left: 150px; } 上面两种方案都是利用了CSS的calc()函数来计算宽度值。下面两种方案则是利用了block级别的元素盒子的宽度具有填满父容器，并随着父容器的宽度自适应的流动特性。 但是block级别的元素都是独占一行的，所以要想办法让两个block排列到一起。 我们知道，block级别的元素会认为浮动的元素不存在，但是inline级别的元素能识别到浮动的元素。这样，block级别的元素就可以和浮动的元素同处一行了。 为了让右侧盒子和左侧盒子保持距离，需要为左侧盒子留出足够的距离。这个距离的大小为左侧盒子的宽度以及两个盒子之间的距离之和。然后将该值设置为右侧盒子的margin-left。 缺点： 需要清除浮动 需要计算右侧盒子的margin-left 4.使用absolute+margin-left方法另外一种让两个block排列到一起的方法是对左侧盒子使用position: absolute的绝对定位。这样，右侧盒子也能无视掉它。 .wrapper-absolute .left { position: absolute; } .wrapper-absolute .right { margin-left: 150px; } 缺点: 使用了绝对定位，若是用在某个div中，需要更改父容器的position。 没有清除浮动的方法，若左侧盒子高于右侧盒子，就会超出父容器的高度。因此只能通过设置父容器的min-height来放置这种情况。 5.使用float+BFC方法上面的方法都需要通过左侧盒子的宽度，计算某个值，下面三种方法都是不需要计算的。只需要设置两个盒子之间的间隔。 .wrapper-float-bfc { overflow: auto; } .wrapper-float-bfc .left { float: left; margin-right: 20px; } .wrapper-float-bfc .right { margin-left: 0; overflow: auto; } 这个方案同样是利用了左侧浮动，但是右侧盒子通过overflow: auto;形成了BFC，因此右侧盒子不会与浮动的元素重叠。 这种情况下，只需要为左侧的浮动盒子设置margin-right，就可以实现两个盒子的距离了。而右侧盒子是block级别的，所以宽度能实现自适应。 缺点:父元素需要清除浮动 6.flex方案.wrapper-flex { display: flex; align-items: flex-start; } .wrapper-flex .left { flex: 0 0 auto; } .wrapper-flex .right { flex: 1 1 auto; } flex可以说是最好的方案了，代码少，使用简单。有朝一日，大家都改用现代浏览器，就可以使用了。 需要注意的是，flex容器的一个默认属性值:align-items: stretch;。这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start; 7.grid方案又一个新型的布局方式。可以满足需求，但这并不是它发挥用处的真正地方。 .wrapper-grid { display: grid; grid-template-columns: 120px 1fr; align-items: start; } .wrapper-grid .left, .wrapper-grid .right { box-sizing: border-box; } .wrapper-grid .left { grid-column: 1; } .wrapper-grid .right { grid-column: 2; } 注意: grid布局也有列等高的默认效果。需要设置: align-items: start;。 grid布局还有一个值得注意的小地方和flex不同:在使用margin-left的时候，grid布局默认是box-sizing设置的盒宽度之间的位置。而flex则是使用两个div的border或者padding外侧之间的距离。 极限情况最后可以再看一下在父容器极限小的情况下，不同方案的表现。主要分成四种情况： 动态计算宽度的情况两种方案: 双inline-block方案和双float方案。宽度极限小时，右侧的div宽度会非常小，由于遵循流动布局，所以右侧div会移动到下一行。 动态计算右侧margin-left的情况两种方案:float+margin-left方案和absolute+margin-left方案。宽度极限小时，由于右侧的div忽略了文档流中左侧div的存在，所以其依旧会存在于这一行，并被隐藏。 float+BFC方案的情况这种情况下，由于BFC与float的特殊关系，右侧div在宽度减小到最小后，也会掉落到下一行。 flex和grid的情况这种情况下，默认两种布局方式都不会放不下的div移动到下一行。不过 flex布局可以通过 flex-flow: wrap;来设置多余的div移动到下一行。 grid布局暂不支持。如果感觉写的有问题，恳请指出。 详情参考：https://segmentfault.com/a/1190000010698609","path":"2019/09/06/七种实现左侧固定，右侧自适应两栏布局的方法/"},{"title":"跨域常用解决方案","text":"同源与同源策略我们知道，同源指的是协议、域名、端口号全部相同。同源策略（Same Origin Policy）是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能都可能会受到影响。浏览器引入同源策略主要是为了防止XSS，CSRF攻击。Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略是处于对用户安全的考量的，如果缺少了同源的限制，那又怎么能够确定别人的网站始终对你是友好的呢。 针对非同源的情况制定了一些限制条件: 无法读取不同源的cookie、LocalStorage、indexDB。 无法获得不同源的DOM。 不能向不同源的服务器发送Ajax请求。 在浏览器中，script、img、iframe、link等标签都可以跨域加载资源，而不受同源策略的限制。事实上，在大多数情境下，我们经常是需要借用非同源来提供数据的，所以这就要用到跨域方面的技术了。 跨域解决方案1.JSONPJSONP是指JSON Padding，JSONP是一种非官方跨域数据交换协议，由于script的src属性可以跨域请求，所以JSONP利用的就是浏览器的这个原理，需要通信时，动态插入一个javascript标签。请求的地址一般带有一个callback参数，假设需要请求的地址为 http://localhost:3000?callback=show， 服务器返回的代码一般是show()的JSON数据，而show函数恰恰是前端需要用的这个数据的函数。JSONP非常简单易用，自动补全API利用的就是JSONP。 一个简单的例子：当远程数据一返回的时候，随着动态脚本的执行，这个handleResponse函数就会被执行。 var script = doxument.createElement(&quot;script&quot;); script.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;); script.src=&quot;http://example.com/ip?callback=handleResponse&quot;; document.body.appendChild(script); function handleResponse(data) { console.log(&apos;Your public IP address is: &apos;+data.ip); } JSONP解决跨域的本质：script标签可以请求不同域名下的资源，即script请求不受浏览器同源策略的影响。上例中的script会向http://example.com/ 服务器发送请求，这个请求的url后面带了个callback参数，是用来告诉服务器回调方法的方法名的。因为服务器收到请求后，会把相应的数据写进handleResponse的参数，也就是服务器会返回如下的脚本： handleResponse({ &quot;ip&quot; : &quot;8.8.8.8&quot; }); 这样浏览器通过script标签下载的资源就是上面的脚本了，script标签下载完就会立即执行，也就是说http://example.com/ip?callback=handleResponse 这个请求返回后就会立即执行上面的脚本代码，而这个脚本代码就是调用回调方法和拿到json数据了。 缺点： 只能发送get请求，无法发送post请求 无法判断请求成功还是失败 2.跨域源资源共享（CORS） CORS是W3C制定的跨站资源分享标准，可以让AJAX实现跨域访问，定义了在必须访问跨域资源时浏览器与服务器该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应应该成功还是失败。 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。 比如一个简单的使用GET或POST的请求，它没有自定义的头部，而主体内容是text/plain。在发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名、端口号），以便服务器根据该头部信息来决定是否给予响应。 Origin: http://www.example.com 如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中发回相同的源信息（如果是公共资源，可以发“*”）。例如： Access-Control-Allow-Origin: http://www.example.com 如果没有这个头部信息或信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。此时，请求和响应都不包含Cookie信息。 HTTP响应首部字段Access-Control-Allow-Origin: &lt;origin&gt; | * Access-Control-Expose-Headers: 头让服务器把允许浏览器访问的头放入白名单 Access-Control-Max-Age: 头指定了preflight请求的结果能够被缓存多久 Access-Control-Allow-Credentials: 头指定了当浏览器的credentials设置为true时是否允许浏览器读sponse的内容。 Access-Control-Allow-Methods: 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。 Access-Control-Allow-Headers: 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段 3.document.domain实现跨域此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 （1）父窗口：(http://www.domain.com/a.html) &lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = &apos;domain.com&apos;; var user = &apos;admin&apos;; &lt;/script&gt; （2）子窗口：(http://child.domain.com/b.html) &lt;script&gt; document.domain = &apos;domain.com&apos;; // 获取父窗口中变量 alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user); &lt;/script&gt; 4.window.postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递用法： postMessage(data,origin)方法接受两个参数 data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。 origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 使用方法如下：（1）a.html：(http://www.domain1.com/a.html) &lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); iframe.onload = function() { var data = { name: &apos;aym&apos; }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;); }; // 接受domain2返回数据 window.addEventListener(&apos;message&apos;, function(e) { alert(&apos;data from domain2 ---&gt; &apos; + e.data); }, false); &lt;/script&gt; （2）b.html：(http://www.domain2.com/b.html) &lt;script&gt; // 接收domain1的数据 window.addEventListener(&apos;message&apos;, function(e) { alert(&apos;data from domain1 ---&gt; &apos; + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;); } }, false); &lt;/script&gt; 5.window.name实现跨域window.name 传输技术的基本原理：当在浏览器中打开一个页面，或者在页面中添加一个iframe时即会创建一个对应的window对象，当页面加载另一个新的页面时，window.name的属性是不会变的。这样就可以利用在页面动态添加一个iframe然后加载数据页面，在数据页面将需要的数据赋值给window.name。然而此时承载的iframe的parent页面还是不能直接访问不在同一域下的iframe的那么属性，这时，只需要将iframe再加载一个与承载页面同域的空白页面，即可对window.name进行数据读取。通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 具体实现：http://www.domain1.com/a.html 主页面http://http://www.domain2.com/b.html 数据页面http://www.domain1.com/proxy.html 代理页面 a.html：(http://www.domain1.com/a.html) &lt;script&gt; var proxy = function(url, callback) { var state = 0; var iframe = document.createElement(&apos;iframe&apos;); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(&apos;&apos;); iframe.contentWindow.close(); document.body.removeChild(iframe); } }; // 请求跨域b页面数据 proxy(&apos;http://www.domain2.com/b.html&apos;, function(data){ alert(data); }); &lt;/script&gt; proxy.html：(http://www.domain1.com/proxy....中间代理页，与a.html同域，内容为空即可。 b.html：(http://www.domain2.com/b.html) &lt;script&gt; window.name = &apos;This is domain2 data!&apos;; &lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。","path":"2019/08/26/跨域常用解决方案/"},{"title":"js如何判断数组是Array类型","text":"在说明如何判断一个对象为数组类型前，我们先巩固下js的数据类型，js一共有六大数据类型：number、string、object、Boolean、null、undefined。 var str=&quot;string&quot;; console.log(typeof str); //string var num=1; console.log(typeof num); //number var bn=false; console.log(typeof bn); //boolean var a; console.log(typeof a); //undfined var obj = null; console.log(typeof obj); //object var doc = document; console.log(typeof doc);//object var arr = []; console.log(arr); //object var fn = function(){}; console.log(typeof fn); //function 除了前四个类型外，null、对象、数组返回的都是object类型；对于函数类型返回的则是function，再比如typeof(Date)，typeof(eval)等。 接下来进入正题，js判断数组类型的方法。 方法一： 使用instanceof方法instanceof 用于判断一个变量是否某个对象的实例，左边操作数是一个对象，右边操作数是一个函数对象或者函数构造器。原理是通过判断左操作数的对象的原型链上是否具有右操作数的构造函数的prototype属性。 a instanceof b?alert(&quot;true&quot;):alert(&quot;false&quot;) //注意b值是你想要判断的那种数据类型，不是一个字符串，比如Array。 举一个例子： var arr=[]; console.log(arr instanceof Array) //返回true 方法二： 使用constructor方法在W3C定义中的定义：constructor 属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数。从定义上来说跟instanceof不太一致，但效果都是一样的。那么判断各种类型的方法： console.log([].constructor == Array); //true console.log({}.constructor == Object); //true console.log(&quot;string&quot;.constructor == String); //true console.log((123).constructor == Number); //true console.log(true.constructor == Boolean); //true 注意：使用instaceof和construcor,被判断的array必须是在当前页面声明的！比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量，Array ==object.constructor;会返回false；原因：1、array属于引用型数据，在传递过程中，仅仅是引用地址的传递。2、每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array。 方法三： 使用Object.prototype.toString.call(arr) === ‘[object Array]’方法function isArray(o) { return Object.prototype.toString.call(o); } var arr=[2,5,6,8]; var obj={name:&apos;zhangsan&apos;,age:25}; var fn = function () {} console.log(isArray(arr)); //[object Array] console.log(isArray(obj)); //[object Object] console.log(isArray(fn)); //[object function] 方法四：ES5定义了Array.isArrayArray.isArray([]) //true","path":"2019/08/23/js如何判断数组是Array类型/"},{"title":"js字符串方法总结","text":"ES5String.fromCharCode()该方法的参数是一系列Unicode码点，返回对应的字符串 charAt()该方法返回指定位置的字符，参数是从0开始编号的位置 str.charAt(index) index 为必须参数，类型为number（0到str.length-1之间，否则该方法返回 空串）另外：str.charAt()即不带参数和str.charAt(NaN)均返回字符串的第一个字符 charCodeAt()方法返回给定位置字符的Unicode码点（十进制表示），相当于String.fromCharCode()的逆操作 str.charCodeAt(index) index 为必须参数，类型为number（0到str.length-1之间，否则该方法返回 NaN） concat()方法用于连接两个字符串，返回一个新字符串，不改变原字符串 var a = &quot;hello&quot;,b = &quot;kitty&quot;,c = &quot;!&quot;;a.concat(b,c) // 功能和 “+” 拼接没啥两样 slice()方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置） str.slice(startIndex,endIndex) 返回值包含startIndex不包含endIndex忽略endIndex则返回包括startIndex到原字符串结尾的字符串另外参数还有负数反向用法 substring()方法用于从原字符串取出子字符串并返回，不改变原字符串。它与slice作用相同，但有一些奇怪的规则，因此不建议使用这个方法，优先使用slice。此方法的第一个参数表示子字符串的开始位置，第二个位置表示结束位置。 str.substring(startIndex,endIndex) 忽略endIndex则返回从startIndex到字符串尾字符 substr()方法用于从原字符串取出子字符串并返回，不改变原字符串。此方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。 str.substr(startIndex,length) 忽略length则返回从startIndex到字符串尾字符 indexOf()，lastIndexOf()这两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回-1，就表示不匹配。两者的区别在于，indexOf从字符串头部开始匹配，lastIndexOf从尾部开始匹配。 str.indexOf(searchStr,startIndex) searchStr必选，表示需要匹配的字符串值；startIndex可选，取值范围0到str.length-1，省略则默认首字符开始检索。 trim()方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。 toLowerCase(),toUpperCase()它们都返回一个新字符串，不改变原字符串。toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。 localeCompare()方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 match()方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 search()方法的用法等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 str.search(regexp/substr) 返回值：str中第一个与正则或字符串相匹配的子串的起始位置。 说明 search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。 replace()方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 split()方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。 str.split() ES6字符的 Unicode 表示法codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。 字符串的遍历器接口ES6 为字符串添加了遍历器接口（Iterator），使得字符串可以被for…of循环遍历。 at()ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。 normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。 一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。 includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。repeat()方法返回一个新字符串，表示将原字符串重复n次。 padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 模板字符串模板编译标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 String.raw()方法往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。","path":"2019/08/19/js字符串方法总结/"},{"title":"js数组操作","text":"传统的js数组方法: concat(),push(),pop(),shift(),unshift(),splice(),slice(),join(),sort(),reverse(); ES5新增数组方法: indexOf(),lastIndexOf(),map(),filter(),forEach(),some(),every(),reduce(),reduceRight(); Array.map()此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组 let arr = [1, 2, 3, 4, 5] let newArr = arr.map(x =&gt; x*2) //arr= [1, 2, 3, 4, 5] 原数组保持不变 //newArr = [2, 4, 6, 8, 10] 返回新数组 Array.forEach()此方法是将数组中的每个元素执行传进提供的函数，没有返回值，直接改变原数组，注意和map方法区分 let arr = [1, 2, 3, 4, 5] num.forEach(x =&gt; x*2) // arr = [2, 4, 6, 8, 10] 数组改变,注意和map区分 Array.filter()此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回 let arr = [1, 2, 3, 4, 5] const isBigEnough =&gt; value =&gt; value &gt;= 3 let newArr = arr.filter(isBigEnough ) //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组 Array.every()此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回true，否则为false： let arr = [1, 2, 3, 4, 5] const isLessThan4 =&gt; value =&gt; value &lt; 4 const isLessThan6 =&gt; value =&gt; value &lt; 6 arr.every(isLessThan4 ) //false arr.every(isLessThan6 ) //true Array.some()此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false： let arr= [1, 2, 3, 4, 5] const isLessThan4 =&gt; value =&gt; value &lt; 4 const isLessThan6 =&gt; value =&gt; value &gt; 6 arr.some(isLessThan4 ) //true arr.some(isLessThan6 ) //false Array.reduce()此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型： let arr = [1, 2, 3, 4, 5] const add = (a, b) =&gt; a + b let sum = arr.reduce(add) //sum = 15 相当于累加的效果 与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的 Array.push()此方法是在数组的后面添加新加元素，此方法改变了数组的长度： let arr = [1, 2, 3, 4, 5] arr.push(6) console.log(arr) //[1, 2, 3, 4, 5, 6] console.log(arr.length) //6 Array.pop()此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度： let arr = [1, 2, 3, 4, 5] arr.pop() console.log(arr) //[1, 2, 3, 4] console.log(arr.length) //4 Array.shift()此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度： let arr = [1, 2, 3, 4, 5] arr.shift() console.log(arr) //[2, 3, 4, 5] console.log(arr.length) //4 Array.unshift()此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度： let arr = [1, 2, 3, 4, 5] arr.unshift(6, 7) console.log(arr) //[6, 7, 1, 2, 3, 4, 5] console.log(arr.length) //7 Array.isArray()判断一个对象是不是数组，返回的是布尔值 let arr = [1, 2, 3] console.log(arr.isArray()) //true Array.concat()此方法是一个可以将多个数组拼接成一个数组： let arr1 = [1, 2, 3] arr2 = [4, 5] let arr = arr1.concat(arr2) console.log(arr)//[1, 2, 3, 4, 5] Array.toString()此方法将数组转化为字符串： let arr = [1, 2, 3, 4, 5]; let str = arr.toString() console.log(str)// 1,2,3,4,5 Array.join()此方法也是将数组转化为字符串： let arr = [1, 2, 3, 4, 5]; let str1 = arr.join() let str2 = arr.join(&apos;,&apos;) let str3 = arr.join(&apos;##&apos;) console.log(str1)// 12345 console.log(str2)// 1,2,3,4,5 console.log(str3)// 1##2##3##4##5 通过例子可以看出和toString的区别，可以设置元素之间的间隔~ Array.splice(开始位置， 删除的个数，元素)万能方法，可以实现增删改： let arr = [1, 2, 3, 4, 5]; let arr1 = arr.splice(2, 0 &apos;haha&apos;) let arr2 = arr.splice(2, 3) let arr1 = arr.splice(2, 1 &apos;haha&apos;) console.log(arr1) //[1, 2, &apos;haha&apos;, 3, 4, 5]新增一个元素 console.log(arr2) //[1, 2] 删除三个元素 console.log(arr3) //[1, 2, &apos;haha&apos;, 4, 5] 替换一个元素","path":"2019/08/19/js数组操作/"},{"title":"二叉树的前序遍历、中序遍历和后序遍历之间还原二叉树","text":"1、概念（1）前序遍历 a、访问根节点；b、前序遍历左子树；c、前序遍历右子树。 （2）中序遍历 a、中序遍历左子树；b、访问根节点；c、中序遍历右子树。 （3）后序遍历 a、后序遍历左子树；b、后续遍历右子树；c、访问根节点。 2、前序遍历和中序遍历还原二叉树思想如下： a、根据前序遍历结果，第一个元素为二叉树的根结点； b、观察中序遍历结果，根结点左侧的为左子树，若左子树根结点前（后）再无任何元素，则左（右）子树的左分支为空；根结点右侧的为右子树，若右子树根结点前（后）再无任何元素，则左（右）子树的左分支为空； c、上面的过程是递归的。先找到当前树的根结点，然后划分为左右子树，再进入左子树重复上面的过程，最后进入右子树重复上面的过程，最终还原一棵树。 例：已知前序遍历：ABDHIEJKCFLMGNO中序遍历：HDIBJEKALFMCNGO 按照上述步骤先画出二叉树，然后在进行求解后序遍历结果。结果为：HIDJKEBLMFNOGCA 练习： 1、前序遍历：GDAFEMHZ 中序遍历：ADEFGHMZ 求得后序遍历结果为：AEFDHZMG 2序遍历：ADCEFGHB 中序遍历：CDFEGHAB 求得后序遍历结果为：CFHGEDBA 3、中序遍历和后序遍历还原二叉树思想如下： a、根据后序遍历结果，最后一个元素为二叉树的根结点； b、观察中序遍历结果，其中根结点左侧为左子树，若左子树根结点前（后）再无任何元素，则左（右）子树的左分支为空；其中根结点右侧为右子树，若右子树根结点前（后）再无任何元素，则左（右）子树的左分支为空； c、上面的过程是递归的。先根据后序遍历结果找根结点，根结点左侧为左子树，右侧为右子树，再进入左子树重复上面的过程，最后进入右子树重复上面的过程，最终还原一棵树。 例：已知中序遍历：HDIBJEKALFMCNGO后序遍历：HIDJKEBLMFNOGCA 按照上述步骤先画出二叉树，然后在进行求解前序遍历结果。结果为：ABDHIEJKCFLMGNO 4、前序遍历和后序遍历还原二叉树已知前序和中序，后序和中序遍历序列之后，可以唯一确定一棵二叉树。但是，只知道前序和后序遍历序列，是无法知道哪个结点是左子树还算右子树。","path":"2019/08/19/二叉树的前序遍历、中序遍历和后序遍历之间还原二叉树/"},{"title":"算法编程题","text":"本文总结了很多简单的算法编程： 降维 排序 去重 统计一个字符串出现最多的字母 不借助临时变量，进行两个整数的交换 找出下列正数组的最大差值 随机生成指定长度的字符串 实现类似getElementsByClassName 的功能 判断一个单词是否是回文？ 找出最长单词 string 里的每个单词首字母大写 判断字符串是否是指定字符结尾 重复字符串指定次数 使用canvas 绘制一个有限度的斐波那契数列的曲线？ 实现阶乘 过滤敏感词 二分查找 App版本比较 生成菲波那切数列 使用JS 实现二叉查找树(Binary Search Tree) 跟着我一起学习吧~ js降维//二维数组变一维数组 //遍历数组两遍，放入新数组 var arr=[[1,2,3],[&quot;sy&quot;,1,&quot;jh&quot;,null],[&quot;&quot;,9],1] function jiangwei(arr){ var newarr=[] arr.forEach(item =&gt; { //判断是不是数组，是进入下一个判断，不是直接push item.forEach?item.forEach(val =&gt; { newarr.push(val) }):newarr.push(item) }); return newarr } //用apply的特性，将数组作为参数展开传入新的空数组[]，再contact var arr=[[1,2,3],[&quot;sy&quot;,1,&quot;jh&quot;,null],[&quot;&quot;,9],1] function jiangwei(arr){ var newarr=[] newarr=newarr.concat.apply(newarr,arr) return newarr } //使用ES6特性-扩展运算符将数组展开 function jiangwei(arr){ var newarr=[] newarr=[].concat(...arr) return newarr } console.log(jiangwei(arr)) //多维数组变成一维数组 //es6新增的flat方法 var arr = [3, [&apos;a&apos;, [0, 1], null], [4, &apos;4j&apos;, [3]], -2] function jiangwei(arr){ var newarr=[] //数字参数指定降维次数 newarr=arr.flat(3) return newarr } console.log(jiangwei(arr)) js排序//js数组排序，冒泡，相邻元素比较交换 var arr=[9,-2,1,30,-59] function paixu(arr){ for(var i=0; i&lt;arr.length-1; i++){ for(var j=0; j&lt;arr.length-1-i; j++){ if (arr[j]&gt;arr[j+1]){ var temp=arr[j] arr[j]=arr[j+1] arr[j+1]=temp } } } return arr } console.log(paixu(arr)) //快速排序 function quickSort(arr) { if (arr.length &lt;= 1) { return arr; } let leftArr = []; let rightArr = []; let q = arr[0]; for (let i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; q) { rightArr.push(arr[i]); } else { leftArr.push(arr[i]); } } return [].concat(quickSort(leftArr), [q], quickSort(rightArr)); } console.log(quickSort(arr));//[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;] js去重var arr = [&apos;1&apos;,&apos;hello&apos;,&apos;ree&apos;,&apos;ke&apos;,&apos;yi&apos;,&apos;1&apos;,&apos;e&apos;,&apos;1&apos;] //ES6数组去重，无法去{}空对象 function quchong(arr){ return Array.from(new Set(arr)) } //splice去重，一个数据和后面所有数据比较，相同的删除 function quchong(arr){ for (var i=0; i&lt;arr.length; i++){ for (var j=i+1; j&lt;arr.length; j++){ if (arr[i]==arr[j]){ arr.splice(j,1) j-- } } } return arr } //使用indexOf去重，新建一个数组，把原数组的数据与新数组里的数据比较newarr.indexOf(arr[i])===-1，不存在就push进去，存在的就跳过 function quchong(arr){ var newarr=[] for (var i=0; i&lt;arr.length; i++){ if(newarr.indexOf(arr[i])===-1){ newarr.push(arr[i]) } } return newarr } //使用sort去重，先将数组排序，然后前后数据相比较，不存在就放入新的数组 function quchong(arr){ var newarr=[] arr= arr.sort() for (var i=0; i&lt;arr.length; i++){ if(arr[i]!==arr[i+1]){ newarr.push(arr[i]) } } return newarr } console.log(quchong(arr)) 统计一个字符串出现最多的字母给出一段英文连续的英文字符窜，找出重复出现次数最多的字母比如：输入：afjghdfraaaasdenas ;输出 ： a前面出现过去重的算法，这里需要是统计重复次数。利用Object中key的唯一性，利用key来进行筛选，然后计数。 var string = &apos;afjghdfraaaasdenas&apos; function findMaxDuplicateChar(str) { if(str.length == 1) { return str; } let charObj = {}; for(let i=0;i&lt;str.length;i++) { if(!charObj[str.charAt(i)]) { charObj[str.charAt(i)] = 1; }else{ charObj[str.charAt(i)] += 1; } } let maxChar = &apos;&apos;, maxValue = 1; for(var k in charObj) { if(charObj[k] &gt;= maxValue) { maxChar = k; maxValue = charObj[k]; } } return maxChar; } console.log(findMaxDuplicateChar(string)) 不借助临时变量，进行两个整数的交换 举例：输入 a = 2, b = 4 输出 a = 4, b =2 这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b进行置换。 主要是利用 + - 去进行运算，类似 a = a + ( b - a) 实际上等同于最后 的 a = b; var a = 2 var b = 4 function swap(a , b) { b = b - a; a = a + b; b = a - b; return [a,b]; } console.log(swap(a,b)) 找出下列正数组的最大差值比如：输入 [10,5,11,7,8,9] ;输出 6这是通过一道题目去测试对于基本的数组的最大值的查找，很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。 function getMaxProfit(arr) { var minPrice = arr[0]; var maxProfit = 0; for (var i = 0; i &lt; arr.length; i++) { var currentPrice = arr[i]; minPrice = Math.min(minPrice, currentPrice); var potentialProfit = currentPrice - minPrice; maxProfit = Math.max(maxProfit, potentialProfit); } return maxProfit; } 随机生成指定长度的字符串实现一个算法，随机生成指指定长度的字符窜。比如：给定 长度 8 输出 4ldkfg9j function randomString(n) { let str = &apos;abcdefghijklmnopqrstuvwxyz9876543210&apos;; let tmp = &apos;&apos;, i = 0, l = str.length; for (i = 0; i &lt; n; i++) { tmp += str.charAt(Math.floor(Math.random() * l)); } return tmp; } console.log(randomString(8)) 实现类似getElementsByClassName 的功能 自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供DOM查找函数。 function queryClassName(node, name) { var starts = &apos;(^|[ \\n\\r\\t\\f])&apos;, ends = &apos;([ \\n\\r\\t\\f]|$)&apos;; var array = [], regex = new RegExp(starts + name + ends), elements = node.getElementsByTagName(&quot;*&quot;), length = elements.length, i = 0, element; while (i &lt; length) { element = elements[i]; if (regex.test(element.className)) { array.push(element); } i += 1; } return array; } 判断一个单词是否是回文？回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider很多人拿到这样的题目非常容易想到用for 将字符串颠倒字母顺序然后匹配就行了。其实重要的考察的就是对于reverse的实现。其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。 // 简易好理解的方法 var str = &apos;helloolleh&apos;; function checkPalindrom(str) { return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;); } console.log(checkPalindrom(str));//true // 复杂方法 function isPalindrome(str){ if (typeof str !== &apos;string&apos; || str.constructor !== String) { return false; } var len = parseInt((str.length+1)/2); for(var i=0; i&lt;len; i++){ if (str[i] !== str[str.length-i-1]) { return false; } } return true; } console.log(isPalindrome(&apos;adddddda&apos;));//true console.log(isPalindrome(&apos;addddda&apos;));//true console.log(isPalindrome(&apos;adddasd&apos;));//false 找出最长单词这个有很多种解决办法 我只是用了个蠢一点最早想到的方法Find the Longest Word in a String function findLongestWord(str) { // 请把你的代码写在这里 var new_str = str.split(&quot; &quot;); var arr = []; for(var i = 0;i&lt;new_str.length;i++){ arr.push(new_str[i].length); } return arr.sort(function(a,b){ return b-a; })[0]; } findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;); string 里的每个单词首字母大写Title Case a Sentence function titleCase(str) { return str.toLowerCase().split(&quot; &quot;).map((item)=&gt;{ return item.replace(item.charAt(0),item[0].toUpperCase()) }).join(&quot; &quot;) } titleCase(&quot;I&apos;m a little tea pot&quot;); 判断字符串是否是指定字符结尾这只是一种思路 我这个有点过去简单粗暴了 小伙伴们如果有更多答案 可以留言 探讨下 function confirmEnding(str, target) { return (str.substr(-target.length)==target) ? true:false; } confirmEnding(&quot;He has to give me a new name&quot;, &quot;name&quot;); 重复字符串指定次数这个折腾了一会儿 刚开始得保存一次 没想到Repeat a string repeat a string function repeat(str, num) { if(num&lt;=0) return &quot;&quot;; var save_ = str for(var i=1;i&lt;num;i++) str+=save_ ; return str; } repeat(&quot;abc&quot;, 3); 使用canvas 绘制一个有限度的斐波那契数列的曲线？数列长度限定在9.斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。我们一般都知道定义fibo[i] = fibo[i-1]+fibo[i-2]; 生成斐波那契数组的方法 function getFibonacci(n) { var fibarr = []; var i = 0; while(i&lt;n) { if(i&lt;=1) { fibarr.push(i); }else{ fibarr.push(fibarr[i-1] + fibarr[i-2]) } i++; } return fibarr; } 实现阶乘 非递归实现? function factorialize(num) { var result = 1; if(num &lt; 0) return -1; if(num == 0 || num == 1) return 1; while(num&gt;1) result *= num--; return result; } 递归实现 function factorialize(num) { if (num &lt; 0) { return -1; } else if (num === 0 || num === 1) { return 1; } else { return (num * factorialize(num - 1)); } } factorialize(5); 过滤敏感词function sensitive(content){ var keywords=[&quot;暴力&quot;, &quot;色情&quot;, &quot;fuck&quot;, &quot;TMD&quot;];//敏感词词库 var value = content;//获取需要过滤的内容 //遍历敏感词数组 for(var i=0;i&lt;keywords.length;i++){ var reg = new RegExp(keywords[i],&quot;g&quot;);//全局替换 //判断内容中是否包括敏感词 if(value.indexOf(keywords[i])!=-1){ var result = value.replace(reg,&quot;****&quot;); value = result; } } return value; } 二分查找二分查找又称折半查找，是在有序数组查找中用到的较为频繁的一种算法，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。 非递归实现 function binary_search(arr, key) { var low = 0, high = arr.length - 1; while(low &lt;= high){ var mid = parseInt((high + low) / 2); if(key == arr[mid]){ return mid; }else if(key &gt; arr[mid]){ low = mid + 1; }else if(key &lt; arr[mid]){ high = mid -1; } } return -1; }; 递归实现 function binary_search2(arr, low, high, key) { if(low &gt; high) return -1; var mid = parseInt((low + high)/2); if(key == arr[mid]) return mid; else if(key &gt; arr[mid]) return binary_search2(arr, mid+1, high, key); else if(key &lt; arr[mid]) return binary_search2(arr, low, mid-1, key); } App版本比较function Version(curV, reqV) { var arr1 = curV.toString().split(&apos;.&apos;); var arr2 = reqV.toString().split(&apos;.&apos;); //将两个版本号拆成数字 var minL = Math.min(arr1.length, arr2.length); var pos = 0; //当前比较位 var diff = 0; //当前为位比较是否相等 var flag = false; //逐个比较如果当前位相等则继续比较下一位 while(pos &lt; minL) { diff = parseInt(arr1[pos]) - parseInt(arr2[pos]); if(diff == 0) { pos++; continue; } else if(diff &gt; 0) { flag = true; break; } else { flag = false; break; } } if(flag){ return curV + &apos;,&apos; + reqV } else { return reqV + &apos;,&apos; + curV } } let test_v = Version(&apos;4.1.3&apos;,&apos;5.0.1&apos;) console.log(test_v ) 生成菲波那切数列斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。通过定义fibo[i] = fibo[i-1]+fibo[i-2];来生成斐波那契数组。 强行递归实现 function getfib(n){ if(n == 0) return 0; if(n == 1) return 1; if(n &gt; 1){ return getfib(n-1) + getfib(n-2); } } function fibo(len){ var fibo = []; for(var i=0;i&lt;len;i++) fibo.push(getfib(i)); return fibo; } 简约非递归版 function getFibonacci(n) { var fibarr = []; var i = 0; while(i &lt; n) { if(i &lt;= 1) { fibarr.push(i); } else { fibarr.push(fibarr[i - 1] + fibarr[i - 2]) } i++; } return fibarr; } 使用JS 实现二叉查找树(Binary Search Tree)一般叫全部写完的概率比较少，但是重点考察你对它的理解和一些基本特点的实现。 二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树： 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。在写的时候需要足够理解二叉搜素树的特点，需要先设定好每个节点的数据结构 class Node { constructor(data, left, right) { this.data = data; this.left = left; this.right = right; } } 树是有节点构成，由根节点逐渐延生到各个子节点，因此它具备基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法. class BinarySearchTree { constructor() { this.root = null; } insert(data) { let n = new Node(data, null, null); if (!this.root) { return this.root = n; } let currentNode = this.root; let parent = null; while (1) { parent = currentNode; if (data &lt; currentNode.data) { currentNode = currentNode.left; if (currentNode === null) { parent.left = n; break; } } else { currentNode = currentNode.right; if (currentNode === null) { parent.right = n; break; } } } } remove(data) { this.root = this.removeNode(this.root, data) } removeNode(node, data) { if (node == null) { return null; } if (data == node.data) { // no children node if (node.left == null &amp;&amp; node.right == null) { return null; } if (node.left == null) { return node.right; } if (node.right == null) { return node.left; } let getSmallest = function(node) { if(node.left === null &amp;&amp; node.right == null) { return node; } if(node.left != null) { return node.left; } if(node.right !== null) { return getSmallest(node.right); } } let temNode = getSmallest(node.right); node.data = temNode.data; node.right = this.removeNode(temNode.right,temNode.data); return node; } else if (data &lt; node.data) { node.left = this.removeNode(node.left,data); return node; } else { node.right = this.removeNode(node.right,data); return node; } } find(data) { var current = this.root; while (current != null) { if (data == current.data) { break; } if (data &lt; current.data) { current = current.left; } else { current = current.right } } return current.data; } } module.exports = BinarySearchTree; .ajaxhttps://www.runoob.com/ajax/ajax-examples.html function ajaxtest(){ var xmlhttp; if (window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); } else { // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)//0-4和200，404 { // responseText 获得字符串形式的响应数据。 // responseXML 获得 XML 形式的响应数据。 document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; } } /* 规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步）*/ xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true); /* 将请求发送到服务器。 string：仅用于 POST 请求 */ xmlhttp.send(); }","path":"2019/08/18/算法编程题/"},{"title":"HTML5语义化标签的理解","text":"语义化标签的好处要从HTML 全局属性说起，即有的标签有默认的HTML全局属性，所以最好用语义化标签。1：以下元素支持 tabindex 属性： &lt;a&gt;, &lt;area&gt;, &lt;button&gt;, &lt;input&gt;, &lt;object&gt;, &lt;select&gt; 以及 &lt;textarea&gt;。 用法：number规定元素的 tab 键控制次序（1 是第一个）。作用：增强用户键盘的可操作性，所以不要用div代替2：以下元素支持 accesskey 属性： &lt;a&gt;, &lt;area&gt;, &lt;button&gt;, &lt;input&gt;, &lt;label&gt;, &lt;legend&gt; 以及 &lt;textarea&gt;。 用法：character规定激活（使元素获得焦点）元素的便捷按键。作用：增强用户键盘的可操作性，所以不要用div代替3：contextmenu 属性的值是要打开的 menu 元素的 id。目前只有火狐支持 4：spellcheck 属性规定是否对元素进行拼写和语法检查。可以对以下内容进行拼写检查： input 元素中的文本值（非密码） &lt;textarea&gt; 元素中的文本 可编辑元素中的文本 5：lang 属性在以下标签中无效： &lt;base&gt;, &lt;br&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;hr&gt;, &lt;iframe&gt;, &lt;param&gt; 以及 &lt;script&gt;。 对外的意义：有利于SEO的！！有利于解析代码！！可读性可维护性增强！！ 1：定义上的： &lt;!--...--&gt; 定义注释。 &lt;!DOCTYPE&gt; 定义文档类型。 &lt;html&gt; 定义 HTML 文档。 &lt;body&gt; 定义文档的主体。 &lt;script&gt; 定义客户端脚本。 &lt;frame&gt; 定义框架集的窗口或框架。 &lt;frameset&gt; 定义框架集。 &lt;head&gt; 定义关于文档的信息。 &lt;iframe&gt; 定义内联框架。 &lt;meta&gt; 定义关于 HTML 文档的元信息。 &lt;link&gt; 定义文档与外部资源的关系。 &lt;noframes&gt; 定义针对不支持框架的用户的替代内容。 &lt;noscript&gt; 定义针对不支持客户端脚本的用户的替代内容。 2：功能上的（js或者css上的作用比较有特色的语义化标签）： &lt;a&gt; 定义锚。 &lt;abbr&gt; 定义缩写。 &lt;address&gt; 定义文档作者或拥有者的联系信息。 &lt;area&gt; 定义图像映射内部的区域。 &lt;audio&gt; 定义声音内容。 &lt;base&gt; 定义页面中所有链接的默认地址或默认目标。 &lt;br&gt; 定义简单的折行。 &lt;button&gt; 定义按钮 (push button)。 &lt;col&gt; 定义表格中一个或多个列的属性值。 &lt;colgroup&gt; 定义表格中供格式化的列组。 &lt;dfn&gt; 定义一个定义项目。 &lt;code&gt; 定义计算机代码文本。 &lt;samp&gt; 定义样本文本。 &lt;kbd&gt; 定义键盘文本。它表示文本是从键盘上键入的。它经常用在与计算机相关的文档或手册中。 &lt;var&gt; 定义变量。您可以将此标签与 &lt;pre&gt; 及 &lt;code&gt; 标签配合使用。 &lt;cite&gt; 定义引用。可使用该标签对参考文献的引用进行定义，比如书籍或杂志的标题。 &lt;datalist&gt; 定义下拉列表。 &lt;wbr&gt; 定义长单词在哪里换号；元素来添加 Word Break Opportunity（单词换行时机） &lt;video&gt; 定义视频。 &lt;track&gt; 标签为诸如 video 元素之类的媒介规定外部文本轨道。 &lt;title&gt; 定义文档的标题。 &lt;time&gt; 定义日期/时间。 &lt;textarea&gt; 定义多行的文本输入控件。 &lt;strong&gt; 定义强调文本。 &lt;style&gt; 定义文档的样式信息。 &lt;sub&gt; 定义下标文本。 &lt;summary&gt; 有关文档的详细信息 &lt;details&gt; 元素定义可见的标题。 &lt;sup&gt; 定义上标文本。 &lt;source&gt; 定义媒介源。 &lt;samp&gt; 定义计算机代码样本。 &lt;section&gt; 定义 section。 &lt;select&gt; 定义选择列表（下拉列表）。 &lt;rt&gt; 定义 ruby 注释的解释。 &lt;ruby&gt; 定义 ruby 注释。 &lt;q&gt; 定义短的引用。 &lt;progress&gt; 定义任何类型的任务的进度。 &lt;param&gt; 定义对象的参数。 &lt;pre&gt; 定义预格式文本。 &lt;optgroup&gt; 定义选择列表中相关选项的组合。 &lt;option&gt; 定义选择列表中的选项。 &lt;output&gt; 定义输出的一些类型。 &lt;details&gt; 定义元素的细节。 &lt;dir&gt; 不赞成使用。定义目录列表。 &lt;div&gt; 定义文档中的节。 &lt;dfn&gt; 定义定义项目。 &lt;dialog&gt; 定义对话框或窗口。 &lt;dl&gt; 定义定义列表。 &lt;dt&gt; 定义定义列表中的项目。 &lt;embed&gt; 定义外部交互内容或插件。 &lt;fieldset&gt; 定义围绕表单中元素的边框。 &lt;figcaption&gt; 定义 figure 元素的标题。 &lt;figure&gt; 定义媒介内容的分组，以及它们的标题。 &lt;form&gt; 定义供用户输入的 HTML 表单。 &lt;hr&gt; 定义水平线。 &lt;img&gt; 定义图像。 &lt;input&gt; 定义输入控件。 &lt;ins&gt; 定义被插入文本。 &lt;kbd&gt; 定义键盘文本。 &lt;keygen&gt; 定义生成密钥。 &lt;label&gt; 定义 input 元素的标注。 &lt;legend&gt; 定义 fieldset 元素的标题。 &lt;map&gt; 定义图像映射。 &lt;mark&gt; 定义有记号的文本。 &lt;menu&gt; 定义命令的列表或菜单。 &lt;menuitem&gt; 定义用户可以从弹出菜单调用的命令/菜单项目。 &lt;meter&gt; 定义预定义范围内的度量。 &lt;nav&gt; 定义导航链接。 &lt;object&gt; 定义内嵌对象。 3：结构上的（方便分块查看，这个很重要）：结构上的可以被其他div+css代替但是好的前端会用这些标签来使代码可读性增强。 &lt;header&gt; 定义 section 或 page 的页眉。 &lt;dd&gt; 定义定义列表中项目的描述。 &lt;article&gt; 定义文章。 &lt;aside&gt; 定义页面内容之外的内容。尤其上面的四位主要用于划分页面块，一般不做样式处理 &lt;p&gt; 定义段落。 &lt;em&gt; 把文本定义为强调的内容。 &lt;strong&gt; 把文本定义为语气更强的强调的内容。 &lt;bdo&gt; 定义文字方向。 &lt;bdi&gt; 定义文本的文本方向，使其脱离其周围文本的方向设置，与bdo配合使用试试。 &lt;big&gt; 定义大号文本。 &lt;b&gt; 定义粗体字。 &lt;del&gt; 定义被删除文本。 &lt;ul&gt; 定义无序列表。 &lt;ol&gt; 定义有序列表。 &lt;table&gt; 定义表格。 &lt;tbody&gt; 定义表格中的主体内容。 &lt;td&gt; 定义表格中的单元。 &lt;tfoot&gt; 定义表格中的表注内容（脚注）。 &lt;th&gt; 定义表格中的表头单元格。 &lt;thead&gt; 定义表格中的表头内容。 &lt;tr&gt; 定义表格中的行。 &lt;footer&gt; 定义 section 或 page 的页脚。 &lt;h1&gt; to &lt;h6&gt; 定义 HTML 标题。 &lt;i&gt; 定义斜体字。 &lt;li&gt; 定义列表的项目。","path":"2019/08/16/HTML5语义化标签的理解/"},{"title":"前后端交互总结","text":"秋招季，总结一下前后端交互部分面经~ 一. 跨域问题：什么是跨域？跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。所谓同源是指，协议，域名，端口均相同。注意：如果是协议和端口造成的跨域问题“前台”是无能为力的；在跨域问题上，域仅仅是通过“URL的首部”来识别 解决方案：特别注意两点：第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。1. JSONP方式解决跨域问题script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。2. CORS解决跨域问题对后台进行配置，例如：PHP端修改header，然后配置Apache web服务器跨域3. 代理请求方式解决接口跨域问题前端对接口进行代理：（前端ajax请求的是本地接口；本地接口接收到请求后向实际的接口请求数据，然后再将信息返回给前端；一般用node.js即可代理；）详情参考https://segmentfault.com/a/1190000012469713 二. Jsonp实现原理 拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;\\script&gt;、&lt;\\img&gt;、&lt;\\iframe&gt;当需要通讯时，本站脚本创建一个script元素，地址指向第三方的API网址，形如： &lt;script src=&quot;http://www.example.net/api?param1=1¶m2=2&quot;&gt;&lt;/script&gt; 并提供一个回调函数localHandler来接收数据（函数名可约定，或通过地址参数传递）。 &lt;script src=&quot;http://www.example.net/api?param1=1&amp;callback=localHandler&quot; type=&quot;text/javascript&quot;&gt; var localHandler = function(data){ alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); }; &lt;/script&gt; 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如： localHandler( { &quot;result&quot;:&quot;hax&quot;, &quot;gender&quot;:&quot;Male&quot; } ) 这样浏览器会调用localHandler函数，并传递解析后json对象作为参数。 三. 从输入一个URL到页面加载完成的过程中都发生了什么事情？ 主要分为6步： DNS域名解析 浏览器与服务器建立TCP连接（3次握手过程） 浏览器向服务器发起HTTP请求 服务器接受请求，进行响应结果，将生成的html返回给客户端 浏览器解析HTML,并请求html代码中的资源 浏览器对页面进行渲染呈现给用户 网络通信的整个流程：流程描述： 第一步：打开浏览器，想要请求访问京东，在地址栏输入了网址：www.jd.com。（www.jd.com是域名就是一个IP地址的名称，IP地址不好记，所有有了域名。） 第二步：先将请求信息发给了交换机，然后交给了路由器，路由发给DNS服务器，通过DNS协议去找我们要访问的京东的IP地址： 第三步：查到的京东服务器对应的IP地址之后，路由器通过路由协议找到一个路由转发的最优路径，将你的请求信息还送给这个IP地址的京东的路由器 第四步：京东的路由器发给了京东网站的服务器上 第五步：京东网站服务器按照来的时候的路径，在返回给你他自己的网站 第六步：当你打开浏览器的时候，你的电脑给你的浏览器这个运行起来的程序给了一个编号，叫做端口号，当你的电脑收到京东发送过来的消息的时候，你的电脑通过端口号找到你的浏览器，你的浏览器拿到了京东的网站信息，然后将网站呈现在了自己的浏览器上 四. 进程和线程的区别 进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。 线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个程序至少一个进程，一个进程至少一个线程。 对资源的管理和保护要求高，不限制开销和效率时，使用多进程。要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。 线程共享进程资源，进程之间的资源独立一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。进程切换时，消耗的资源大，效率高 线程与进程的区别：a. 一个程序至少有一个进程，一个进程至少有一个线程b. 线程的划分尺度小于进程，使得多线程程序的并发性高c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 五. 队列和栈介绍 队列：先进先出，表尾插入，表头删除栈：先进后出，表尾删除插入 栈与队列的相同点： 1.都是线性结构。 2.插入操作都是限定在表尾进行。 3.都可以通过顺序结构和链式结构实现。 4.插入与删除的时间复杂度都是O(1)，在空间复杂度上两者也一样。 5.多链栈和多链队列的管理模式可以相同。 六. Post和get区别 Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE，对URL地址（网络上的资源）的查，改，增，删4个操作。5、HEAD；6、TRACE；7、OPTIONS；方法 Post和put区别PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源） 七. 计算机网络的七层OSI应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 八. TCP/IP五层模型的协议应用层、传输层、网络层、数据链路层、物理层 九. TCP和UDP的区别是什么 十. TCP与HTTP的不同，HTTP是什么，HTTPS是什么 HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。 HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间。 TCP是传输层，而http是应用层，http是要基于TCP连接基础上的。TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。 十一. TCP的三次握手,为什么不是两次？ 三次握手：请求，确认，建立连接第一次：客户端C发送一个请求连接的位码SYN(1)和一个随机产生的序列号Seq(x)给服务器S，C进入SYN_SEND状等待服务器确认。第二次：S收到了这个请求连接的位码SYN(1)，实现确认一下，发送了一个确认码ACK（x+1)+SYN(1)+Seq（y）给进入SYN_RECV状态。第三次：C收到了SYN＋ACK，一比较一样，于是他又发送了一个ACK(y+1)+Seq(z)给S，S收到以后就确定建立连接，C和S进入ESTABLISHED状态，TCP连接建立完成。 为什么不是两次？三次是①C能和S通信②S能和C通信③S和C建立连接，两次的话，不能确定S和C是否能通信，会产生问题 十二. 四次挥手：确保数据能够完整传输。 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。C没数据传输了 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。S说我也没了 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。C请求关闭 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。S同意并关闭 十三. Ajax工作原理 创建XMLHttpRequest对象,也就是创建一个异步调用对象. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. 设置响应HTTP请求状态变化的函数. 发送HTTP请求. 获取异步调用返回的数据. 使用JavaScript和DOM实现局部刷新. 十四. HTTP状态码及常见举例1** ：信息，服务器收到请求，需要请求者继续执行操作2** ：成功，操作被成功接收并处理3** ：重定向，需要进一步的操作以完成请求4** ：客户端错误，请求包含语法错误或无法完成请求5** ：服务器错误，服务器在处理请求的过程中发生了错误100 ：继续。客户端应继续其请求。101 ：切换协议，服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200 ：OK。请求成功，一般用于Get和post请求。201 ：已创建。成功请求并创建了新的资源。202 ：已接受。已经接受请求，但未处理完成203 ：非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本。204：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。300：多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。301 ：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。302：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。304：服务端资源无变化，可使用缓存资源307：临时重定向。与302类似。使用GET请求重定向。400：客户端请求的语法错误，服务器无法理解401：请求要求用户的身份认证403：服务端禁止访问该资源404：服务器无法根据客户端的请求找到资源（网页）。408：服务器等待客户端发送的请求时间过长，超时。410：客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置。411：服务器无法处理客户端发送的不带Content-Length的请求信息414：请求的URI过长（URI通常为网址），服务器无法处理417：服务器无法满足Expect的请求头信息。500：服务器内部错误，无法完成请求。501：服务器不支持请求的功能，无法完成请求。502：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求503：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。504：充当网关或代理的服务器，未及时从远端服务器获取请求。505：服务器不支持请求的HTTP协议的版本，无法完成处理。 十五. 死锁是什么死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。永远在互相等待的进程称为死锁进程。 十六. 自适应和响应式区别两者都是优化适应互联网中越来越分化的视口.应该说响应式的范畴更广一些。响应式可以自动适应不同尺寸的屏幕，无论你的设备尺寸多么奇葩。响应式使用CSS media queries的方法，根据目标设备自动改变风格如显示类型,宽度、高度等，这能很好解决不同屏幕尺寸的显示问题。是一个网站能够兼容多个终端而不是为每个终端做一个特定的版本，这个概念是为移动互联网浏览而诞生。自适应设计是基于断点使用静态布局，一旦页面被加载就无法再进行自动适应，自适应会自动检测屏幕的大小来加载适当的工作布局，也就是说，当你要采用自适应设计网站时，你得一个一个设计6种常见的屏幕布局。[自适应设计要求为每一个布局单独开发和维护HTML和CSS代码]1、320 2、480 3、760 4、960 5、1200 6、1600自适应设计需要做更多的工作，你必须至少设计6种常见的布局。而响应式设计可以更好地适应复杂的媒体设备要求，能很好地解决显示和性能问题，修改相当麻烦。修改相当麻烦。 十七. 谈谈你对前端性能优化的理解 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽：开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体 缓存利用：使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验：避免CSS表达式，避免重定向 十八. 请说出三种减少页面加载时间的方法 尽量减少页面中重复的HTTP请求数量 服务器开启gzip压缩 css样式的定义放置在文件头部 Javascript脚本放在文件末尾 压缩合并Javascript、CSS代码 使用多域名负载网页内的多个文件、图片 十九. 什么叫优雅降级和渐进增强？ 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。渐进增强和优雅降级的区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带 二十. 一次js请求一般情况下有哪些地方会有缓存处理？ 浏览器端存储 浏览器端文件缓存 HTTP缓存304 服务器端文件类型缓存 表现层&amp;DOM缓存 二十一. 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验[性能优化]。 图片懒加载，滚动到相应位置才加载图片。 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 二十二. 网站重构的理解重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化，针对于SEO进行优化 减少代码间的耦合，让代码保持弹性 压缩或合并JS、CSS、image等前端资源 二十三. 谈谈以前端角度出发做好SEO需要考虑什么？ 了解搜索引擎如何抓取网页和如何索引网页 meta标签优化 关键词分析 付费给搜索引擎 链接交换和链接广泛度（Link Popularity） 合理的标签使用 二十四. 前端页面有哪三层构成，分别是什么？作用是什么？ 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。 行为层：由脚本负责。解决了页面上“内容应该如何对事件作出反应”的问题。 二十五. 系统访问量变高了，速度变慢了怎么办？优化。优化方式很多，如：读写分离、负载均衡资源服务器和应用服务器分离，即应用部署在应用服务器上，资源部署在资源服务器上。这时候，js和css的引用就需要更改为绝对URL，指向对应的资源服务器。 二十六. WEB应用从服务器主动推送Data到客户端有那些方式？ html5 websoket WebSocket 通过 Flash XHR长时间连接 XHR Multipart Streaming 不可见的Iframe 标签的长时间连接(可跨域) 二十七. 知道的网页制作会用到的图片格式有哪些？png-8，png-24，jpeg，gif，svgWebp：谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准。 二十八. AMD和CMD 规范的区别？AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现CMD 按需执行依赖 - 懒执行，seaJS 是它的实现 二十九. CDN（内容分发网络，Content Distribute Network）的概念以及使用CDN加速的优点。CDN解决的是如何将数据快速可靠从源站传递到用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。 三十. 前端 MV*框架的意义 早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，基本不太需要框架。 随着 AJAX 的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了。 如果是页面型产品，多数确实不太需要它，因为页面中的 JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。 长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。 从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的 MV框架，这个状况会大有改观。 之所以感受不到 MV*框架的重要性，是因为Model部分代码较少，View的相对多一些。如果主要在操作View和Controller，那当然 jQuery 这类库比较好用了。 三十一. 对前端工程师这个职位是怎么看的？前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 实现界面交互 提升用户体验 有了Node.js，前端可以实现服务端的一些事情 前景： 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更?? 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 三十二. 平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 三十三. 说说最近最流行的一些东西吧？常去哪些网站？CSDN、SegmentFault、php.net、MDN、css参考手册、iconfont、underscore、github、Bootstrap、W3Shool、W3Cplus、caniuse","path":"2019/08/10/前后端交互总结/"},{"title":"Javascript总结","text":"秋招季，总结一下HTML部分面经~ 一. JS作用域和作用域链1. 作用域:作用域就是变量和函数的可访问范围，或者说变量或函数起作用的区域。 javascript函数的作用域：函数内的区域，就是这个函数的作用域，变量和函数在这个区域都可以访问操作。最外层函数外的区域叫全局用域，函数内的区域叫局部作用域。 javascript变量的作用域：在源代码中变量所在的区域，就是这个变量的作用域，变量在这个区域内可被访问操作。在全局作用域上定义的变量叫全局变量，在函数内定义的变量叫局部变量。 2. 作用域链作用域链（Scope Chain）是javascript内部中一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。 3. 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 4. 当全局变量跟局部变量重名的时候，局部变量会覆盖掉全局变量(变量提升)在函数中存在同名的局部变量，如何使用全局变量？window.全局变量名，客户端中，window为全局对象，不在任何函数内的js代码，也可以使用this来引用全局对象，如：var global = this。不加var，相当于给全局对象创建一个同名属性。 5. var和不加var的全局变量区别： 在严格模式和非严格模式下不同，严格模式下，给一个没有声明的变量赋值会报错。 《js权威P58》使用var声明一个变量，创建的全局对象的属性是不可配置的，也就是说无法通过delete运算符删除；而没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量，以这种方式创建的变量是全局对象的正常的可配置属性，并可以删除它们。js全局变量是全局对象的属性。this可以引用全局对象。 作用域详细解读：https://www.cnblogs.com/hfxm/p/5547922.html 二. JS构造函数、原型和原型链1. 构造函数构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。另外就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。 2. 原型在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。 3. 原型链 在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的条，专业术语称之为原型链。举例说明:person → Person → Object ，普通人继承人类，人类继承对象类 原型链查找过程当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。 4. 写一个原型链继承的例子// 动物 function Animal() { this.eat = function () { console.log(&apos;animal eat&apos;) } } // 狗 function Dog() { this.bark = function () { console.log(&apos;dog bark&apos;) } } Dog.prototype = new Animal() // 哈士奇 var hashqi = new Dog() 5. 描述new一个对象的过程 创建一个新对象 this 指向这个新对象 执行代码，即对 this 赋值 返回 this function Foo(neme, age) { this.name = name this.age = age this.class= &apos;class-1&apos; // return this // 默认有这一行 } var f = new Foo(&apos;zhangsan&apos;, 20) 如何判断一个变量是数组类型 var arr = [] arr instanceof Array //true typeof arr //object,typeof是无法判断是否是数组的 原型链详细解读：https://www.cnblogs.com/jianghao233/p/8983176.html 三. js闭包、继承1. 闭包：闭包是能够读取其他函数内部变量的函数，是函数内部和函数外部连接起来的桥梁。闭包连接起来了一个函数和当函数声明时的词法作用域。 闭包最大用处有两个： 读取函数内部的变量； 让这些变量的值始终保存在内存中。使用闭包主要是为了设计私有的方法和变量。 闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 函数嵌套函数（外部嵌套的函数将嵌套的函数对象作为返回值返回） 函数内部可以引用外部的参数和变量（子函数可以使用父函数的变量，反之则不能） 参数和变量不会被垃圾回收机制回收（会让变量的值始终在内存中） 2. ES6中闭包： let命令：块级作用域；不存在变量提升：var定义变量：可以先使用，后声明；而let定义变量：只可先声明，后使用；暂时性死区：只要一进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量；不允许重复声明 const命令：const命令用来声明常量，一旦声明，其值就不能改变；在声明时必须初始化；块级作用域，所以其变量只在块级作用域内使用或其中的闭包使用；不存在变量提升；不可重复声明常量；变量名指向的地址不变，并不保证该地址的数据不变； 3. 继承：创建的子类将继承超类的所有属性和方法，包括构造函数及方法的实现。子类还可添加超类中没有的新属性和方法，也可以覆盖超类的属性和方法。 继承的方式： 原型链继承:将子类的prototype属性赋值为父类实例对象，则子类的proto属性继承父类。 借用构造函数继承：用.call()和.apply()将父类构造函数引入子类函数；call() 方法：它的第一个参数是用作 this 的对象，其他参数都直接传递给函数自身，B.call(A, args1,args2);即A对象调用B对象的方法；apply() 方法：用作 this 的对象和要传递给函数的参数的数组 B.apply(A, arguments);即A对象应用B对象的方法混合方式： 组合继承（组合原型链继承和借用构造函数继承） 对象冒充 寄生式继承 call()、apply()、和bind()的区别js改变this指向的方法var obj = {name:”wang”} 函数对象的call()方法,用于指定this调用函数,第一参数是指定的this对象,从第二个参数开始,是调用自身函数所传递的参数，this指向objtest.call(obj,1,3); 函数对象的apply()方法,也用于指定this调用函数,第一个参数也是指定的this对象,和call的区别是:第二个参数是一个数组,数组中存放本次调用要传递的参数，this指向objtest.apply(obj,[1,3]); 函数对象的bind()方法,不会调用本函数,而是生成一个新的函数,这个函数的代码逻辑和原函数一样,但是this指向不一样，指向.bind(demo),demo this.name=&quot;jack&quot;; var demo={ name:&quot;rose&quot;, getName:function(){return this.name;} } console.log(demo.getName());//输出rose 这里的this指向demo var another=demo.getName; console.log(another())//输出jack 这里的this指向全局对象= //运用bind方法更改this指向 var another2=another.bind(demo); console.log(another2());//输出rose 这里this指向了demo对象了; 四. JS ES6特性 ECMAScript 6 简称 ES6，是 JavaScript 语言的下一代标准，已经在2015年6月正式发布。新特性： let、const块级作用域 import导入模块、export导出模块 ES6引入class(构造函数）、extends(继承)、super(原型) arrow functions （箭头函数）不需要 function 关键字来创建函数，省略 return 关键字，继承当上下文的 this 关键字 template string （模板字符串）用{${name}}嵌入 destructuring （解构）解构能让我们从对象或者数组里取出数据存为变量 default 函数默认参数 rest arguments （rest参数\\剩余参数：拿到除开始参数外的参数）function func(a, …rest) Spread Operator （展开运算符）(…person) 对象初始化简写 Promise：它主要用于处理异步回调代码，让代码不至于陷入回调嵌套的死路中。构造函数有callreject/resolve这几个方法，reject/resolve两个参数，将处理信息传递给promise函数 Generators：生成器（ generator）是能返回一个迭代器的函数。 五. JS 同步和异步的区别javascript语言是一门“单线程”的语言，所谓单线程就是按次序执行，执行完一个任务再执行下一个。同步和异步的差别就在于这单线程上各个流程的执行顺序不同。 同步：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步：不进入主线程、而进入”任务队列”（task queue）的任务，自己做自己的任务，只有等主线程任务执行完毕，自己下面的任务也做完了，”任务队列”开始通知主线程，请求执行任务，该任务才会进入主线程执行。 在JS中，异步编程只有四种情况： 定时器都是异步编程的，setTimeout和setInterval函数；setTimeout(function(){ alert(“Hello”); }, 3000); 所有的事件绑定都是异步编程的，click事件等； Ajax读取数据都是异步编程的，我们一般设置为异步编程； 回调函数callback都是异步编程的； 六. 深拷贝与浅拷贝 浅拷贝：是指只复制一层对象，当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化（就是假设B复制了A，当修改A时，B也变化了） 深拷贝：是指复制对象的所有层级（当修改A时，B没变化）。 实现方法 通过递归实现，递归去复制所有层级属性 通过JSON解析实现，借用JSON对象的parse和stringify 借用JQ的extend方法 七. JS 的引用赋值与传值赋值 number,string类型都是基本类型是通过传值赋值的，而基本类型存放在栈区，访问时按值访问，赋值是按照普通方式赋值； 对象和数组是通过引用来赋值的，所以改变arr1的同时arr2也会跟着改变; 八. js内存泄漏 内存泄漏可以定义为一个应用，由于某些原因不再需要的内存没有被操作系统或者空闲内存池回收。 3种常见的JavaScript泄漏 意外的全局变量 被遗忘的计时器或回调 超出DOM引用 闭包 九. click和onclick的区别 click 是方法，由程序员写语句调用；onclick是事件；方法触发事件 click本身是方法作用是触发onclick事件，只要执行了元素的click()方法，就会触发onclick事件； 十. DOM操作——怎样添加、移除、移动、复制、创建和查找节点。1. 创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 2. 添加、移除、替换、插入appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点 3. 查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 十一. setTimeOut，promise和主程序的执行顺序then和settimeout执行顺序，即setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.then()在本轮“事件循环”结束时执行。因此then 函数先输出，settimeout后输出。 十二. 事件机制之冒泡、捕获、传播和委托。 DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。事件捕获（event capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。 dom标准事件流的触发的先后顺序为：先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。 说到事件冒泡与捕获就不得不提一下两个用于事件绑定的方法addEventListener、attachEvent。当然还有其它的事件绑定的方式这里不做介绍。addEventListener(event, listener, useCapture)参数定义：event—（事件名称，如click，不带on），listener—事件监听函数，useCapture—是否采用事件捕获进行事件捕捉，默认为false，即采用事件冒泡方式addEventListener在 IE11、Chrome 、Firefox、Safari等浏览器都得到支持。attachEvent(event,listener)参数定义：event—（事件名称，如onclick，带on），listener—事件监听函数。attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了（微软还是挺识趣的，慢慢向标准靠拢）。 十三. Js阻塞及解决思路 Js阻塞机制，跟Js引擎的单线程处理方式有关，每个window一个JS线程。所谓单线程，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。 由于浏览器是事件驱动的（Event driven），因此浏览器中很多行为是异步的，很容易有事件被同时或者连续触发。当异步事件发生时，会创建事件并放入执行队列中，等待当前代码执行完成之后再执行这些代码，如鼠标点击事件发生、XMLHttpRequest 完成回调、定时器触发事件发生这些事件，都会被放入执行队列中等待。 js执行会阻塞DOM树的解析和渲染，那么css加载不会阻塞DOM树的解析(结构)，但是会阻塞DOM树的渲染(样式)。 解决JS阻塞(不全)： html5的defer和async关键字defer延迟js执行；async异步执行。 动态加载js。查询文档加载状态，在合适的时候加载js。 详情参考http://blog.csdn.net/talking12391239/article/details/21168489 十四. JS无缝滚动效果实现方法分析效果：1.默认缓慢往左滚动2.放到左箭头上还是向左滚动，放到右箭头上向右滚动3.放到图片上停止滚动，移出继续滚动思路：1.计算图片列表ul的宽度2.开启定时器，使其向左边距不断增大，造成向左运动的效果3.图片列表复制一份，向左移动时，当左边距大于一份的宽度时，把它的左边距拉回到0。向右移动时，当左边距大于0时，把它的左边距拉到整个两份图片列表一半的宽度（即一份的宽度）。（拉的瞬间很快，用户察觉不到，造成一种无缝滚动的假象）4.offsetLeft值的正负决定往哪边移动5.放到图片上停止这个定时器，移开再开启 十五. 轮播图的实现原理在html ，css 已经写好的情况下。最主要的就是js的功能问题了。轮播图的功能步骤如下： 先让图片轮播起来。基本就是写一个 play函数里面加定时器，每次使图片的index对象加一，当index大于最值，设置index等于第 一张图片.这样轮播图就动起来了。 轮播图动起来基本就是只显示一张图片隐藏其他的图片。我上面使用的是opacity 。 图片下面的按钮。主要就是使下面的按钮与上面的图片一一对应。然后点击下面的按钮显示对应的图片。 左右的上一张和下一张按钮。点击左边的上一张按钮图片向前显示，实现原理就是使 index 对象减一。点击边下一张按钮图片向后显示，实现原理就是使 index 对象加一。 对应上一张和下一张连续点击的问题就是给这两个按钮加上延时器。 当鼠标放在轮播图区域时停止轮播，实现原理就是清除定时器，离开开始轮播就是加上定时器。","path":"2019/08/08/Javascript总结/"},{"title":"CSS总结","text":"秋招季，总结一下CSS部分面经~ 一. CSS3盒子模型 盒子模型IE 盒子模型和标准 W3C 盒子模型的范围包括 margin、border、padding、content使用“标准 W3C 盒子模型”：在网页顶部加上Doctype声明。 在不同标准里width的区别在标准 W3C 盒子模型中，width指content部分的宽度在 IE 盒子模型中，width表示（content+padding+border）这三个部分的宽度 box-sizingbox-sizing: content-box 是 W3C 盒子模型;content-box动态大小 | 受 “边框” “边距” 等属性影响box-sizing: border-box 是 IE 盒子模型;border-box固定大小 | 不受 “边框” “边距” 等属性影响 margin和padding可以为负么？margin可以为负，而且经常用于布局。padding不能为负，即使为负，也会调整为0. margin塌陷解决办法:https://www.cnblogs.com/syp172654682/p/7671830.html 二. 块级元素、行内元素、块级行内元素列举display的值： 1. 行内元素：display:inline 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea（字体、input类、span）等； 特性： (1) 设置宽高无效； (2) margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间； (3) 不会自动进行换行； 水平居中：通过给父元素设置 text-align:center 垂直居中： (1) 子元素line-height:父元素的height； (2) 父元素display 为 table-cell（设置为表格单元显示）， vertical-align：middle属性 2. 块状元素：display:block 块状元素：div、p、nav、aside、header、footer、section、article、ul-li、address、h1-h6、blockquote、dl、dt、dd； 特性 ： (1) 能够识别宽高； (2) margin和padding的上下左右均对其有效； (3) 可以自动换行； (4) 多个块状元素标签写在一起，默认排列方式为从上至下； 水平居中： (1) margin:0 auto； (2) 使用position:relative或absolute 和 left:50% 垂直居中： (1) 父元素添加display设为flex，再通过align-items:center; (2) 父元素：position：relative; 子元素：position: absolute; top: 50%; margin-top=-height（子）/2; (3) 父元素：position:relative 子元素：position:absolute; top:0; bottom:0;margin:auto; 水平垂直居中： (1)父元素：position：relative; 子元素：position: absolute; top: 50%; left: 50%; margin-top=-height（子）/2; margin-right=-width/2;(已知块级元素的宽和高) (2)父元素：position:relative 子元素：position:absolute; top:0; left:0; bottom:0; right:0; margin:auto; (3)父元素样式属性display:flex; 子元素使用margin:auto; 溢出处理：当内容大于容器 overflow: hidden;隐藏溢出内容 overflow: auto;当内容溢出时，显示滚动条 overflow-y: auto; 只显示上下滚动条 overflow: scroll;无论是否溢出，都显示滚动条占位：隐藏了元素内容，但空间仍然保持 visibility: hidden; width&amp;height：(min-width max-width用于响应式布局、width:auto与父容器等宽) 3. 行内块状元素：display:inline-block 特征：(1) 不自动换行(2) 能够识别宽高(3) 默认排列方式为从左到右；(行内元素和块状元素都使用) 4. 垂直水平居中方法 已知宽高（4种方法） 未知宽高(考虑flex布局和transform) 三. css相对定位、绝对定位 静态定位(position：static)不脱离标准文档流这个是元素的默认定位方式，元素出现在正常的文档流中，会占用页面空间。不能使用top?bottom??left??right??z-index??? 相对定位(position: relative)不脱离标准文档流相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动. 绝对定位(position: absolute)脱离标准文档流这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 固定定位(position: fixed)脱离标准文档流绝对定位方式，直接以浏览器窗口作为参考进行定位。其它特性同absolute定位。 inherit 规定从父元素继承 position 属性的值。 嵌套使用：子容器在父容器底部居中：父容器：position：relative；子容器：position：absolute；bottom：0；left：0；right：0；margin: auto 四. Flex布局容器的属性以下6个属性设置在容器上： flex-direction：决定主轴的方向 flex-wrap：定义如果一条轴线排不下，如何换行 flex-flow：是flex-direction属性和flex-wrap属性的简写形式 justify-content：定义了项目在主轴上的对齐方式 align-items：定义项目在交叉轴上如何对齐 align-content：定义了多根轴线的对齐方式。 项目的属性以下6个属性设置在项目上： order：定义项目的排列顺序 flex-grow：定义项目的放大比例 flex-shrink：定义了项目的缩小比例 flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size） flex：是flex-grow, flex-shrink 和 flex-basis的简写 align-self：允许单个项目有与其他项目不一样的对齐方式 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 五. CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS 选择符： id选择器(# myid) 类选择器(.myclassname) 标签选择器(div, h1, p) 相邻选择器(h1 + p) 子选择器(ul &gt; li) 后代选择器(li a) 通配符选择器( * ) 属性选择器(a[rel = “external”]) 伪类选择器(a: hover, li:nth-child) 可继承的样式： font-size font-family color text-indent 不可继承的样式： border padding margin width height 优先级算法： 优先级就近原则，同权重情况下样式定义最近者为准; 载入样式以最后载入的定位为准; !important &gt; 内联&gt; id &gt; class &gt; tag 权值： 内联样式表的权值最高 1000； ID 选择器的权值为 100 Class 类选择器的权值为 10 HTML 标签选择器的权值为 1 多个进行累加，比较总和 六. CSS伪类1. CSS 伪类用于向某些选择器添加特殊的效果。伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。注意：first-child和last-child都得用于子元素，而不是父元素。 2. 语法selector : pseudo-class {property: value} selector.class : pseudo-class {property: value} 3. 锚伪类a:hover {color: #FF00FF} / 必须被置于 a:link 和 a:visited 之后，才是有效的/a:active {color: #0000FF} / 选定的链接 必须被置于 a:hover 之后，才是有效的/ 4. CSS3新增伪类举例：p:first-of-type 选择属于其父元素的首个p元素的每个p元素。p:last-of-type 选择属于其父元素的最后p元素的每个p元素。p:only-of-type 选择属于其父元素唯一的p元素的每个p元素。p:only-child 选择属于其父元素的唯一子元素的每个p元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个p元素。 :first-child与:first-of-type的不同:first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。:first-of-type 匹配的是该类型的第一个:enabled / :disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中。 七. CSS伪元素1. CSS 伪元素用于向某些选择器设置特殊效果。与伪类针对特殊状态的元素不同的是，伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。注意：:first-line和:first-letter伪元素只能用于块级元素。 2. 语法：selector:pseudo-element {property:value;} selector.class:pseudo-element {property:value;} 八. css3动画 先创建动画：@keyframes规则是创建动画。 @keyframes规则内指定一个CSS样式和动画将逐步从目前的样式更改为新的样式。 @keyframes myfirst { from {background: red;} to {background: yellow;} } 绑定选择器：当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会有任何效果。指定至少这两个CSS3的动画属性绑定向一个选择器：规定动画的名称规定动画的时长 div { animation: myfirst 5s; -webkit-animation: myfirst 5s; /* Safari 与 Chrome */ } 九. CSS3新增内容 边框border-radius（圆角边框）box-shadow（边框阴影）border-image 背景background-size:宽高 background-origin(content-box,padding-box,border-box) 文本效果 text-shadow word-wrap(break-word)text-wrap?s 字体 @font-face {font-family:ddd;src:url(‘.ttf’)}定义自己的字体 字体描述符：font-family，src，font-sketch，font-style… 2D转换 translate(向左移动距离，向下移动)\\ratate(度数) 3D转换ratateX() ratateY() 过渡 transition 动画 @keyframes{from,to} animation 多列 column-count:数字创建多列文本 用户界面resize（用户可改变大小），box-sizing（border-box，content-box） 十. 什么是CSS Hack?CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号，以达到应用不同的CSS样式的目的。(不同浏览器识别不同css样式)比如IE6能识别下划线“”和星号“”，IE7能识别星号“”，但不能识别下划线” ”，而firefox两个都不能认识。https://blog.csdn.net/qq_31635733/article/details/81660897 十一. 浏览器的内核分别是什么?经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？IE浏览器的内核Trident、Mozilla的Gecko、google的WebKit、Opera内核Presto； 浏览器的兼容性： png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8位. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。…https://blog.csdn.net/qq_38892819/article/details/75426133 十二. display:none、visibility:hidden、visibility:collapse和opacity:0的区别Collapse:是否折叠（即是否不占据文档流位置）；event：是否还能触发事件；taborder：是否还可以通过tab键选择到。其中，visibility:collapse在表格元素中yes，即不占据文档流位置，在其他元素占据位置 行内元素display:inline对应不显示为display:none块状元素display:block对应不显示为visibility: hidden display：none设置该样式的元素（对象）的宽度、高度等各种属性值都将“丢失”，其元素不占据文档空间。不会触发事件 visibility: hidden设置该样式的元素（对象）仅仅是视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也就是它仍具有高度、宽度等属性值。不会触发事件 opacity:0opacity是CSS3的属性，0（完全透明），1（完全不透明），inherit设置此样式的元素（对象）仍然占据空间，并且能触发事件。 visibility:collapse在表格元素的tr中使用时，会删除一行或者一列，但是不会影响表格布局。若在td上使用，仅隐藏此单元格内容，仍然占据位置。应用与除表格外的其他元素，则仍然会为其保留位置，不会触发事件，也不会通过tab键选择到。 十三. visibility的值 十四. Float影响，清除浮动几种方法 浮动影响的主要是设置浮动元素之后的元素，对之前没有浮动的元素不产生影响。不管是设置浮动还是未设置浮动，其垂直位置不变，紧紧跟在未设置浮动元素之后，上边距与上一个元素的下边距对齐。 如果父元素没有设置高度，在子块没有浮动的情况下，父块会被撑开，但是内部子块浮动的话，就会产生以下影响： 父元素的背景不能显示 父元素的边框不能撑开，导致父元素之后的兄弟元素布局乱掉。 margin、padding值不能正确显示 十五. 清除浮动的几种方法： 设置父元素的高度为子元素的最高高度加上父元素的上下边框宽度。 给父元素结束标签之前添加一个div标签，将此标签的css设置为：clear:both或者是clear:left;(clear规定哪一侧不允许有浮动元素) 给父元素添加overflow：hidden。 :after作用于浮动元素的父元素将其设置为display:block 其中:clear:both;指清除所有浮动；content: ‘.’; display:block;对于FF/chrome/opera/IE8不能缺少，其中content（）可以取值也可以为空。visibility:hidden;的作用是允许浏览器渲染它，但是不显示出来，这样才能实现清除浮动。 十六. 为什么要初始化CSS样式。因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议） 十七. link 和@import 的区别是？ link属于HTML标签，而@import是CSS提供的; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import只在IE5以上才能识别，而link是HTML标签，无兼容问题; link方式的样式的权重 高于@import的权重. 十八. 对BFC规范的理解？BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。） 十九. 解释下 CSS sprites，以及你要如何在页面或网站中使用它。CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了http2。 二十. 圣杯布局、双飞翼布局两边固定，中间自适应。 与圣杯布局相比，双飞翼HTML中为main添加了一个子元素main-wrap,这个小小的改动是为了之后处理main中内容被遮盖的问题，这也是两者实现方式最大的不同点。 与圣杯布局一样，一开始三个col都设置float: left,为了把left和right定位到左右部分，采用负边距，left部分margin-left: -100%，right部分margin-right: -190px。之后就是处理main中内容的遮盖问题，只需设置main-wrap的左右外边距即可解决。 相比圣杯布局，双飞翼不必设置左右栏的position: relative，也不必设置左右left、right值，只需多添加一个子元素包含，相应的padding换成margin。总的说来简单不少。 双飞翼布局的好处：主要的内容先加载的优化；兼容目前所有的主流浏览器，包括IE6在内；衍生布局：http://www.cnblogs.com/lyzg/p/5160570.htmlCSS布局面试：http://developer.51cto.com/art/201504/473284.htm","path":"2019/08/03/CSS总结/"},{"title":"HTML总结","text":"秋招季，总结一下HTML部分面经~ 一. 行内元素、块级元素、空元素举例 空元素没有内容的HTML元素。空元素在开始标签中关闭的。（单标签）如：br、hr、img、input、param、meta、link 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote 块级元素和行内元素区别 占据空间块级元素总是单独占一行，并从新的一行开始；行内元素和其他同为行内元素占据同一行。 Width,height,Margin-padding是否可设置块级可以，行内不可以。通过改变元素的display可改变此属性。 宽度行内元素宽度与内容相关；块级元素不设置则与浏览器同宽。 容纳内容块级元素可容纳内联元素和其他块元素；行内元素只可容纳文本和其他行内元素。 二. Repaint（重绘）和Reflow（重排|回流） repaint：重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。 reflow：重排是更明显的一种改变，可以理解为渲染树需要重新计算。重排一定会引起浏览器的重绘，会影响排版。 常见的引起重排的具体操作： 调整窗口大小； 改变字体大小； 样式表改动； 元素内容变化，尤其是输入控件； CSS伪类激活； DOM操作； offsetWidth, width, clientWidth, scrollTop/scrollHeight的计算， 会使浏览器将渐进回流队Flush，立即执行回流 减少重排次数和缩小重排方法： 将多次改变样式属性的操作合并成一次操作。 将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 在内存中多次操作节点，完成后再添加到文档中去。 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个素进行复杂的操作时，可以先隐藏它，操作完成后再显示。 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。 三. H5新增标签和删除标签删除的标签：纯表现的元素：basefont、big、center、font等对可用性产生负面影响的元素：frame、frameset、noframes 新增标签主要是语义化的标签如：&lt;header&gt;&lt;/header&gt; &lt;!--头部--&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!--导航栏--&gt; &lt;section&gt;&lt;/section&gt; &lt;!--区块（有语义化的div）--&gt; &lt;main&gt;&lt;/main&gt; &lt;!--主要区域--&gt; &lt;article&gt;&lt;/article&gt; &lt;!--主要内容--&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!--侧边栏--&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!--底部--&gt; 除此之外新增 &lt;video&gt;&lt;audio&gt;&lt;Progress&gt;(进度条) 标签语义化概念及语义化好处：标签语义化就是让标签有含义，给某块内容用上一个最恰当最合适的标签，使页面有良好的结构，页面元素有含义，不论是谁，都能看懂这块内容是什么，并且有利于搜索引擎。 语义化标签好处 ：HTML结构清晰可读性较好无障碍阅读有利于搜索引擎根据标签内容确定上下文和权重问题移动设备可以完美展现页面（CSS支持较弱的设备）有利于团队维护和开发代码 四. H5新增事件H5新的Web应用API，许多API都定义了事件。如：http://blog.csdn.net/charlene0824/article/details/52165429 Audio.video触发网络事件、数据缓冲状况、播放状态。Canpaly\\durationchange\\loadstart\\play\\playing\\waiting 拖放API，（抓取一种对象后拖到另一个位置）如:dragstart,drag,dragenter,dragdrop,dragover在拖放源和放置目标上设置 历史管理机制Hashchange（location.hash，获取片段标识符） 表单验证机制当验证失败会触发invalid 离线web应用缓存支持(manifest)Offline，online 异步通信使用message事件通信如websocket，webworker，server-sent Web存储两种（前两种，cookies本来就有）Localstorage、sessionStorage、cookies 五. sessionStorage、localStorage和 cookie 之间的区别 三者都是在浏览器端存储数据。 数据存储大小限制不同。cookies：数据始终在同源的http请求中携带，即cookie在服务器和浏览器间回传。故存储的数据大小最小，一般为4k。sessionStorage和localStorage：数据在本地保存，不会自动把数据发给服务器。所以一般5M或者更大。 数据有效期不同cookies：数据在cookie设置的有效期之前都有效，即使窗口和浏览器关闭。sessionStorage：数据在关闭浏览器窗口后自动清除。存储的数据仅在同源同窗口内有效，即使在不同浏览器相同页面也是无效的。一般用于存储会话数据。localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 数据作用域不同Cookies和localStorage：在所有同源窗口敏感词享。sessionStorage：不在不同浏览器窗口敏感词享。 请你谈谈Cookie的弊端 每个特定的域名下最多生成的cookie个数有限制 IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。 web storage和cookie的区别 Cookie的大小是受限的 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽 cookie还需要指定作用域，不可以跨域调用 Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage 六. a的href有几种 超链接目标的 URL； 有效文档的相对或绝对 URL； 伪协议： JavaScript 代码段(javascript:伪协议[通过一个链接调用js函数或者表达式等]void(0)指定无返回值[没有返回值的函数真正返回的都是 undefined]，若有返回值，会覆盖掉a的内容如： &lt;a href=&quot;javascript:void(window.open(&apos;about:blank&apos;))&quot;&gt;Click me&lt;/a&gt;) 其他的伪协议还有mailto:(邮件地址)[点击链接会打开outlook进行邮件发送]tel:(电话)[会打开弹窗选择程序拨打电话，如skype]file:本机文件地址 七. 浏览器内核IE: trident内核Firefox(Mozilla)：gecko内核Safari：webkit内核Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核Chrome：Blink(基于webkit，Google与Opera Software共同开发) 前缀对应：-moz-对应 Firefox,-webkit-对应 Safari and Chrome-o- for Opera-ms- for Internet Explorer 八. 列举IE与其他浏览器不一样的特性？ IE的排版引擎是Trident （又称为MSHTML） Trident内核曾经几乎与W3C标准脱节（2005年） Trident内核的大量 Bug等安全性问题没有得到及时解决 JS方面，有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等 CSS方面，也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式 九. Meta 响应式metawidth,height：宽度高度initial-scale：初始比例maximum-scale：允许用户缩放到的最大比例，minimum-scale：允许用户缩放到的最小比例,user-scalable：用户是否可以手动缩放,no,yes） &lt;meta name = “viewport” content = “width = device-width, initial-scale = 1, maximum-scale = 1, user-scale = no”&gt; 防止搜索引擎爬取页面 &lt;meta name = “robots” content = “noindex”&gt; 只防止Google &lt;meta name = “googlebot” content = “noindex”&gt; 防止爬取连接指向的页面 &lt;a href = “privatepage.html” rel = “nofollow”&gt;link to pricate page&lt;/&gt; 十. 加快HTML页面加载速度1. 页面减肥删除不必要的空格、注释；将inline的script和css移到外部文件；可以使用HTML Tidy来给HTML减肥，还可以使用一些压缩工具（uglify）来给JavaScript减肥 2. 减少文件数量减少页面上引用的文件数量可以减少HTTP连接数；许多JavaScript、CSS文件可以合并最好 3. 减少域名查询DNS查询和解析域名也是消耗时间的，所以要减少对外部JavaScript、CSS、图片等资源的引用，不同域名的使用越少越好 4. 缓存重用数据使用缓存吧 5. 优化页面元素加载顺序首先加载页面最初显示的内容和与之相关的JavaScript和CSS；然后加载DHTML相关的东西；图片、flash、视频等很肥的资源就最后加载 6. 减少inline JavaScript的数量浏览器parser会假设inline JavaScript会改变页面结构，所以使用inline JavaScript开销较大不使用document.write()这种输出内容的方法，使用W3C DOM方法来为现代浏览器处理页面 7. 指定图像和tables的大小如果浏览器可以立即决定图像或tables的大小，那么它就可以马上显示页面而不要重新做一些布局安排的工作；这不仅加快了页面的显示，也预防了页面完成加载后布局的一些不当的改变；image使用height和width；table使用table-layout: fixed并使用col和colgroup标签指定columns的width，少用table，table的渲染很耗时间(table是解析完成后加载，div是读到一句就开始加载) 8. CDN加速 详情参考：https://www.cnblogs.com/larennani/p/6741289.html 十一. Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? &lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 标签之前。告知浏览器以何种模式来渲染文档。 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 你知道多少种Doctype文档类型？该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 十二. HTML与XHTML——二者有什么区别区别： 所有的标记都必须要有一个相应的结束标记 所有标签的元素和属性的名字都必须使用小写 所有的XML标记都必须合理嵌套 所有的属性必须用引号””括起来 把所有&lt;和&amp;特殊符号用编码表示 给所有属性赋一个值 不要在注释内容中使“–” 图片必须有说明文字 十三. 文档加载、渲染过程1. 浏览器加载和渲染html的顺序 IE下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。 在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完） 如果遇到语义解释性的标签嵌入文件（JS脚本，CSS样式），那么此时IE的下载过程会启用单独连接进行下载。 并且在下载后进行解析，解析过程中，停止页面所有往下元素的下载。阻塞加载 样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前经渲染的）重新进行渲染。 JS、CSS中如有重定义，后定义函数将覆盖前定义函数 2. JS的加载 不能并行下载和解析（阻塞下载） 当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，比如使用document.write或appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现.","path":"2019/07/23/HTML总结/"},{"title":"使用flex布局来搭建基本的页面布局","text":"我们的目的是为了实现这样的布局： 源码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;template&gt; &lt;h-page-container&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;p&gt;标题栏&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;左侧栏&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;内容一&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;内容二&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;内容三&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;内容四&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;右侧栏&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/h-page-container&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot; scoped&gt;.container &#123; display: flex; display: -webkit-flex; /* Safari */ height: 600px; flex: 1&#125;.main &#123; flex: 6; border: 2px solid red; display: flex; display: -webkit-flex; /* Safari */ flex-direction: column&#125;.right &#123; flex: 2; border: 2px solid red&#125;.header &#123; flex: 1; border: 2px solid red&#125;.content &#123; flex: 9; border: 2px solid red; display: flex; display: -webkit-flex /* Safari */&#125;.left &#123; flex: 2; border: 2px solid red&#125;.box &#123; flex: 8; border: 2px solid red; display: flex; display: -webkit-flex /* Safari */&#125;.column &#123; flex: 1; border: 2px solid red; display: flex; display: -webkit-flex; /* Safari */ flex-direction: column&#125;.item &#123; flex: 1; border: 2px solid red; display: flex; display: -webkit-flex /* Safari */&#125;&lt;/style&gt;&lt;script&gt;import EchartsPie from &apos;@/components/EchartsPie.vue&apos;export default &#123; name: &apos;Recognition&apos;, props: &#123; breadcrumbObj: &#123; type: Object, default: () =&gt; null &#125; &#125;, components: &#123; EchartsPie &#125; &#125;&lt;/script&gt; 结果展示：接下来就可以插入各种组件来填充我们的页面了例如，把上上上篇博客刚刚讲完用Echarts构建的饼图组件放入页面中！","path":"2019/06/19/使用flex布局来搭建基本的页面布局/"},{"title":"Vue_CLI脚手架学习与搭建","text":"今天我们来学习一下Vue CLI脚手架，本文主要是总结Vue CLI脚手架搭建过程及总结遇到的问题，跟着我一起来学习吧~ 1.node.js安装与环境配置1.1 node.js安装 安装包下载地址：https://nodejs.org/en/ 下载完成后，双击node-v10.16.0-x64.msi，开始安装Node.js，全程默认一直点击下一步（注意：安装地址最后不要默认选择C盘，选择D盘），安装完毕后点击finish结束安装进程，然后在VS code终端，依次输入命令： 12node -vnpm -v 如果正确输出版本号，说明我们的NodeJS和NPM就安装好了，如下图所示： 此处说明下：新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西 1.2 node.js环境配置 说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到C:\\Users\\用户名\\AppData\\Roaming\\npm路径中，占C盘空间。 例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹D:\\software\\nodejs下创建两个文件夹node_global及node_cache如下图： 创建完两个空文件夹之后，打开终端窗口，输入12npm config set prefix \"D:\\software\\nodejs\\node_global\"npm config set cache \"D:\\software\\nodejs\\node_cache\" 接下来设置环境变量，控制面板-系统和安全-系统-高级系统设置-高级-环境变量 进入环境变量对话框，在系统变量下新建NODE_PATH，输入D:\\software\\nodejs\\node_global\\node_modules 将用户变量下的Path修改为D:\\software\\nodejs\\node_global修改前:修改后: 配置完后，安装个module测试下，我们就安装最常用的express模块，打开终端窗口， 输入如下命令进行模块的全局安装：npm install express - # -g是全局安装的意思修改后 可以看到express被安装到我们刚刚设置的路径下，就说明配置成功 2.Vue CLI安装与配置2.1 Vue CLI安装 可以使用下列任一命令安装这个新的包： 12npm install -g @vue/cliyarn global add @vue/cli 你还可以用这个命令来检查其版本是否正确 (3.x)：vue --version 2.2Vue CLI项目搭建2.2.1Vue CLI &gt;= 3时进行项目构建 我们安装的Vue CLI &gt;= 3，所以直接运行以下命令来创建一个新项目： 1vue create hello-world 你会被提示选取一个 preset。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性，这个默认的设置非常适合快速创建一个新项目的原型，而手动设置则提供了更多的选项，它们是面向生产的项目更加需要的。 在项目创建的过程中，你也会被提示选择喜欢的包管理器或使用淘宝 npm 镜像源以更快地安装依赖。这些选择也将会存入 ~/.vuerc 直接选取默认的设置就可以快速进行创建，就可以看到在安装各种插件，我们的项目正在下载搭建中： 再来试一个自定义安装的项目搭建，方向键上下移动，空格选中，Enter确定 再根据刚刚的选择会弹出来以下选框，按照自己需求进行选择 123456? Use history mode for router? //是否使用history模式的路由? Pick a CSS pre-processor //CSS预处理器选择? Pick a linter / formatter config: (Use arrow keys) //选择哪个ESLint自动化代码格式化检测? Pick additional lint features //选择语法检查的时期? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? //配置文件的存放位置? Save this as a preset for future projects? (y/N) //是否保存此预设(选择yes的话下次就可以不用进行配置) 出现以下界面说明项目搭建成功 安装后移动到目录 并启动，启动完毕后会提示我们浏览器访问地址12cd mydemo npm run serve // 这里和版本2不一样了。2是npm run dev 而版本3 是npm run serve 浏览器访问：http://localhost:8080/，效果如下： 2.2.2Vue CLI &lt; 3时，拉取 2.x 模板 (旧版本)进行项目构建 Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： 12npm install -g @vue/cli-init # `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同vue init webpack mydemo 然后终端会出现下图“一问一答”模式，如图： 这里有几个需要说明一下，没说明的直接回车选择默认就好，对项目没多大影响，很傻瓜式：Project name：这个是项目名称，默认是输入时的那个名称，想改的话直接输入修改，也可以直接回车Install vue-router:是否需要vue-router，默认选择使用，这样生成好的项目就会有相关的路由配置文件Use ESLint to lint your code:是否使用ESLint，刚才说了我们这个项目需要使用所以也是直接回车，默认使用，这样会生成相关的ESLint配置Setup unit tests with Karma + Moch?: 是否安装单元测试。由于我们现在还没有单元测试，所以这里选择的是”N”，而不是直接回车哦Setup e2e tests with Nightwatch：是否安装e2e测试，这里我也同样选择的是“N”这几个配置选择yes 或者 no 对于我们项目最大的影响就是，如果选择了yes 则生成的项目会自动有相关的配置，有一些loader我们就要配套下载。所以如果我们确定不用的话最好不要yes，要么下一步要下很多没有用的loader 全部选择好回车就进行了生成项目，现在打开之前说过的package.json文件，找到devDependencies 和 dependencies ，在这里面可以删掉我们不需要的，其他就则都需要使用 npm install 下载安装，例如vue： npm install vue –save-dev 1npm install 依赖包 运行mydemo，输入命令 1npm run dev 在浏览器输入地址http://localhost:8080，看到页面，说明大功告成，一个Vue项目已经初始化完成 2.2.3使用图形化界面进行项目构建 你也可以通过 vue ui 命令以图形化界面创建和管理项目： 1vue ui 上述命令会打开一个浏览器窗口，并以图形化界面将你引导至项目创建的流程。 2.3项目目录结构 通过vue-cli搭建一个vue项目，会自动生成一系列文件，而这些文件具体是怎样的结构、文件对应起什么作用，可以参考网上的解释，有了这个框架，接下来就可以根据自己的喜好来重新制定网站了 2.4修改端口号 vue-cli构建的项目，在控制台npm run dev启动后，默认的调试地址是8080端口的。但是大部分时候，我们都要并行几个项目开发，很有可能已经占用了8080端口，所以就涉及到如何去更改调试地址的端口号了 修改路径：2.x：config --&gt; index.js3.0+：node_modules--&gt;@vue--&gt;cli-service--&gt;lib--&gt;commands--&gt;build--&gt;serve.j","path":"2019/06/18/Vue-CLI脚手架学习与搭建/"},{"title":"自定义构建Echarts问题描述","text":"今天我们来学习一下Echarts，本文主要是总结自定义构建Echarts遇到的问题，跟着我一起来学习吧~ 1.使用命令行，创建自己的工程：12mkdir myProjectcd myProject 2.在 myProject 目录下使用命令行，初始化工程的 npm 环境并安装 echarts（这里前提是您已经安装了 npm）：12npm initnpm install echarts --save 3.使用 echarts 提供的构建脚本自定义构建在这个例子中，我们要创建一个饼图，并且想自定义构建一个只含有饼图的 echarts 文件，从而能使 echarts 文件的大小比较小一些。echarts 已经提供了构建脚本 echarts/build/build.js，基于 Node.js 运行。我们可以在 myProject 目录下使用命令行，看到它的使用方式：1node node_modules/echarts/build/build.js --help 注意：这里会出现报错1Error: Cannot find module 'XXX' 翻译出来就是找不到 ‘XXX’ 组件，我也是通过查找的方法，进行实践，缺啥就安装啥，可能会有很多的模块找不到，就一个一个进行安装就行，执行12npm install XXX --save//这里的 XXX 指的是报错中缺少的模块名 以上几个模块安装成功就会显示如下，你可以输入–help指令查看参数的含义：其中我们在这个例子里会用到的参数有： -i：代码入口文件，可以是绝对路径或者基于当前命令行路径的相对路径。 -o：生成的 bundle 文件，可以是绝对路径或者基于当前命令行路径的相对路径。 –min：是否压缩文件（默认不压缩），并且去多余的打印错误信息的代码，形成生产环境可用的文件。 –lang ：是否使用其他语言版本，默认是中文。例如：–lang en 表示使用英文，–lang my/langXX.js 表示构建时使用 /my/langXX.js 替代 echarts/lib/lang.js 文件。 –sourcemap：是否输出 source map，以便于调试。 –format：输出的格式，可选 ‘umb’（默认）、’amd’、’iife’、’cjs’、’es’。 4.既然我们想自定义构建一个只含有饼图的 echarts 文件，我们需要创建一个入口文件，可以命名为 myProject/echarts.custom.js，文件里会引用所需要的 echarts 模块：123456// 引入 echarts 主模块。export * from 'echarts/src/echarts';// 引入饼图。import 'echarts/src/chart/pie';// 在这个场景下，可以引用 `echarts/src` 或者 `echarts/lib` 下的文件（但是不可混用），// 参见下方的解释：“引用 `echarts/lib/**` 还是 `echarts/src/**`”。 5.然后我们可以在 myProject 目录下使用命令行，这样开始构建：1node node_modules/echarts/build/build.js --min -i echarts.custom.js -o lib/echarts.custom.min.js 注意：这里会出现报错1TypeError: uglifyPlugin is not a function 出错原因是依赖插件rollup-plugin-uglify版本过高，查看当前版本：1npm view rollup-plugin-uglify versions 重新npm install特定的版本：1npm install rollup-plugin-uglify@3.0.0 --save 这回就能构建成功了这样，myProject/lib/echarts.custom.min.js 就生成了。 6.我们可以创建 myProject/pie.html 来使用它：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;myProject&lt;/title&gt; &lt;!-- 引入 lib/echarts.custom.min.js --&gt; &lt;script src=\"lib/echarts.custom.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt; &lt;script&gt; // 绘制图表。 echarts.init(document.getElementById('main')).setOption(&#123; series: &#123; type: 'pie', data: [ &#123;name: 'A', value: 1212&#125;, &#123;name: 'B', value: 2323&#125;, &#123;name: 'C', value: 1919&#125; ] &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.运行程序，这样一个饼图就出来啦","path":"2019/06/15/自定义构建Echarts问题描述/"},{"title":"Echarts的学习与使用","text":"今天我们来学习一下Echarts，ECharts是一个纯JavaScript图表库，底层依赖于轻量级的Canvas类库ZRender，基于BSD开原协议，是一款非常优秀的可视化前端框架，本文基于Vue CLI脚手架，来实现Echarts的引用，跟着我一起来学习吧~ 一.引入一个简单的图表首先npm安装Echarts1npm install echarts --save 接下来打开public-&gt;src-&gt;main.js来引入echarts12import myCharts from './comm/js/myCharts.js'Vue.use(myCharts) 绘制一个简单的容器12345&lt;template&gt;&lt;h-page-content&gt;&lt;div id=\"myChart\" :style=\"&#123;width: '600px', height: '400px'&#125;\"&gt;&lt;/div&gt;&lt;/h-page-content&gt;&lt;/template&gt; 创建一个简单的图表你可以在这里查找样例echarts图表，注意：我们要在mounted生命周期函数中实例化echarts对象。因为我们要确保dom元素已经挂载到页面中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script&gt;export default &#123; name: 'EchartsIndex', mounted () &#123; this.drawLine() &#125;, methods: &#123; drawLine () &#123; // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption(&#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123; trigger: 'item', formatter: \"&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)\" &#125;, legend: &#123; orient: 'vertical', x: 'left', data:['直接访问','邮件营销','联盟广告','视频广告','搜索引擎'] &#125;, series: [&#123; name:'访问来源', type:'pie', radius: ['50%', '70%'], avoidLabelOverlap: false, label: &#123; normal: &#123; show: false, position: 'center' &#125;, emphasis: &#123; show: true, textStyle: &#123; fontSize: '30', fontWeight: 'bold' &#125; &#125; &#125;, labelLine: &#123; normal: &#123; show: false &#125; &#125;, data:[ &#123;value:335, name:'直接访问'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:234, name:'联盟广告'&#125;, &#123;value:135, name:'视频广告'&#125;, &#123;value:1548, name:'搜索引擎'&#125; ] &#125;] &#125;) &#125; &#125;&#125;&lt;/script&gt; 这样你的第一个图表就诞生了！ 接下来就可以根据自己的需求来自定义图表了 二.图表参数配置学习更多可以查看Echarts配置项手册 1.title标题组件，包含主标题和副标题。在 ECharts 2.x 中单个 ECharts 实例最多只能拥有一个标题组件。但是在 ECharts 3 中可以存在任意多个标题组件，这在需要标题进行排版，或者单个实例中的多个图表都需要标题时会比较有用。1234title: &#123; text: '金融资产详情', //主标题 subtext: '金融资产次级标题' //副标题&#125; 2.tooltip提示框组件。提示框组件的通用介绍：提示框组件可以设置在多种地方： 可以设置在全局，即 tooltip 可以设置在坐标系中，即 grid.tooltip、polar.tooltip、single.tooltip 可以设置在系列中，即 series.tooltip 可以设置在系列的每个数据项中，即 series.data.tooltip123456789tooltip: &#123; trigger: 'item', //数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用 backgroundColor: 'rgb(245,245,245,0.9)', //设置提示框背景颜色 padding: [15, 20], //设置提示框内边距 textStyle: &#123; color: '#4F4F4F' //设置提示框内字体颜色 &#125;, extraCssText: 'box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);' //额外附加到浮层的 css 样式，如为浮层添加阴影&#125; 3.legend图例组件。图例组件展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。ECharts 3 中单个 echarts 实例中可以存在多个图例组件，会方便多个图例的布局。当图例数量过多时，可以使用 滚动图例（垂直） 或 滚动图例（水平）。1234567891011legend: &#123; bottom: 0, //设置图例组件离容器下侧的距离 left: 'center', //设置图例组件离容器左侧的距离 icon: 'circle', //设置图例组件图标为圆形 textStyle: &#123; color: '#4F4F4F', //设置图例组件字体颜色 fontSize: '14' //设置图例组件字体大小 &#125;, hoverAnimation: false, //是否开启 hover 在扇区上的放大动画效果 data: ['存款余额', '活期余额', '定期余额', '通知存款余额', '贷款余额', '理财余额', '国债余额', '基金余额'] //图例的数据数组&#125; 4.color设置数据区域颜色。1color: ['#1E90FF', '#40E0D0', '#43CD80', '#EEC900', '#FF6A6A', '#9B30FF', '#3A5FCD', '#27408B'] 5.series系列列表。每个系列通过 type 决定自己的图表类型。123456789101112131415161718192021222324252627282930313233343536373839404142series: [&#123; // name: '', type: 'pie', radius: ['30%', '50%'], //设置饼图半径 selectedMode: 'single', //选中模式，表示是否支持多个选中，默认关闭 hoverAnimation: false, //是否开启 hover 在扇区上的放大动画效果 label: &#123; normal: &#123; textStyle: &#123; fontSize: '14', //设置饼图文字格式 color: '#4F4F4F' //设置饼图文字颜色 &#125;, formatter: function (data) &#123; return data.name + ' : ' + data.percent.toFixed(2) + ' % ' //用来格式化引出文字文本，支持字符串模板和回调函数两种形式，保留两位小数 &#125; &#125; &#125;, labelLine: &#123; smooth: true //是否平滑视觉引导线，默认不平滑 &#125;, data: [ //系列中的数据内容数组 &#123; value: 982, name: '存款余额' &#125;, &#123; value: 968, name: '活期余额' &#125;, &#123; value: 1332, name: '定期余额' &#125;, &#123; value: 2034, name: '通知存款余额' &#125;, &#123; value: 2582, name: '贷款余额' &#125;, &#123; value: 1403, name: '理财余额' &#125;, &#123; value: 0, name: '国债余额' &#125;, &#123; value: 701, name: '基金余额' &#125; ], itemStyle: &#123; normal: &#123; borderWidth: 2, //设置描边线宽 borderColor: 'white' //设置描边颜色 &#125;, emphasis: &#123; //图形的高亮样式 shadowColor: 'rgba(0, 0, 0, 0.5)' //文字块的背景阴影颜色 &#125; &#125;&#125;] 详细的学习教程可以参考Echarts学习网址","path":"2019/06/08/Echarts的学习与使用/"},{"title":"flex布局排布","text":"作为前端必备知识点，flex为我们页面布局提供了灵活性，今天我们来学一下flex布局吧~ 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局，行内元素也可以使用Flex布局， Webkit内核的浏览器，必须加上-webkit前缀。123.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125;注意：设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、Flex布局基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end； 交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上： flex-direction：决定主轴的方向 flex-wrap：定义如果一条轴线排不下，如何换行 flex-flow：是flex-direction属性和flex-wrap属性的简写形式 justify-content：定义了项目在主轴上的对齐方式 align-items：定义项目在交叉轴上如何对齐 align-content：定义了多根轴线的对齐方式。 3.1 flex-direction属性决定主轴的方向（即项目的排列方向）123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 3.2 flex-wrap属性决定如何换行123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认）：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 3.3 flex-flow属性是flex-direction和flex-wrap的简写形式，默认值为row nowrap123.box &#123;flex-flow: &amp;lt;flex-direction&amp;gt; &amp;lt;flex-wrap&amp;gt;;&#125; 3.4 justify-content属性定义了项目在主轴上的对齐方式123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性定义项目在交叉轴上如何对齐12.box &#123;align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性定义了多根轴线的对齐方式，会以多行作为整体进行对齐，容器必须开启换行，若项目只有一根轴线，该属性不起作用12.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上： order：定义项目的排列顺序 flex-grow：定义项目的放大比例 flex-shrink：定义了项目的缩小比例 flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size） flex：是flex-grow, flex-shrink 和 flex-basis的简写 align-self：允许单个项目有与其他项目不一样的对齐方式 4.1 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0；值相同时，以dom中元素排列为准123.item &#123; order: &amp;lt;integer&amp;gt;;&#125; 4.2 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &amp;lt;number&amp;gt;; /* default 0 */&#125; 元素放大的计算方法放大的计算方法将元素大小纳入考虑。仅仅按flex-grow声明的份数算出每个需分配多少，叠加到原来的尺寸上。 容器剩余宽度：50px 分成每份：50px / (3+2) = 10px 元素1放大为：50px + 3 * 10 = 80px所以如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。当弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论flex-grow是什么值都不会生效 4.3 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。12.item &#123; flex-shrink: &amp;lt;number&amp;gt;; /* default 1 */&#125; 元素收缩的计算方法来看下以下场景，弹性容器#container宽度是200px，一共有三个弹性元素，宽度分别是50px、100px、120px。 真的是等比缩小(每个元素各减去70/3的宽度)吗？ 弹性元素1：50px→37.03px 弹性元素2：100px→74.08px 弹性元素3：120px→88.89px 先抛结论：flex-shrink: 1并非严格等比缩小，它还会考虑弹性元素本身的大小。 容器剩余宽度：-70px 缩小因子的分母：1*50 + 1*100 + 1*120 = 270 (1为各元素flex-shrink的值) 元素1的缩小因子：1*50/270 元素1的缩小宽度为缩小因子乘于容器剩余宽度：1*50/270 * (-70) 元素1最后则缩小为：50px + (1*50/270 *(-70)) = 37.03px 加入弹性元素本身大小作为计算方法的考虑因素，主要是为了避免将一些本身宽度较小的元素在收缩之后宽度变为0的情况出现。所以如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &amp;lt;length&amp;gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 与width/height的区别： (1)两者都为0：width: 0 —— 完全没显示；flex-basis: 0 —— 根据内容撑开宽度 (2) 两者非0： 数值相同时两者等效； 同时设置，flex-basis优先级高 (3) flex-basis为auto：flex-basis为auto时，如设置了width则元素尺寸由width决定；没有设置则由内容决定 (4) flex-basis == 主轴上的尺寸 != width：将主轴方向改为：上→下，此时主轴上的尺寸是元素的height，flex-basis == height 4.5 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &amp;lt;&apos;flex-grow&apos;&amp;gt; &amp;lt;&apos;flex-shrink&apos;&amp;gt;? || &amp;lt;&apos;flex-basis&apos;&amp;gt; ]&#125; 一些简写：flex: 1 = flex: 1 1 0%flex: 2 = flex: 2 1 0%flex: auto = flex: 1 1 auto;flex: none = flex: 0 0 auto; // 常用于固定尺寸 不伸缩 flex:1 和 flex:auto 的区别其实可以归结于flex-basis:0和flex-basis:auto的区别。flex-basis是指定初始尺寸，当设置为0时（绝对弹性元素），此时相当于告诉flex-grow和flex-shrink在伸缩的时候不需要考虑我的尺寸；相反当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。因此从下图（转自W3C）可以看到绝对弹性元素如果flex-grow值是一样的话，那么他们的尺寸一定是一样的。两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。更多内容参考：https://www.runoob.com/w3cnote/flex-grammar.htmlhttps://www.cnblogs.com/qcloud1001/p/9848619.htmlhttp://www.ruanyifeng.com/blog/2015/07/flex-examples.html","path":"2019/05/25/flex布局排布/"},{"title":"VScode快捷键及常用插件","text":"VScode快捷键：https://blog.csdn.net/hypon2016/article/details/80831266 VScode快捷键： Auto Close Tag ：自动闭合 HTML/XML 标签 Auto Rename Tag ：自动重命名成对的 HTML/XML 标签 Babel ES6/ES7 ： 添加 ES6/ES7 语法的颜色提醒 Canvas Snippets ：Canvas 代码片段提示 Bracket Pair Colorizer ：多层括号颜色匹配 CSS peek ：可直接在 HTML 中查看 class、id 对应的 CSS 样式，并可以直接跳转 Document This ： JSDoc comments for both TypeScript and JavaScript filesize ：编辑器左下角显示文件大小 git history、gitlens ： git 使用必备，能够图形化显示 git 历史、编辑人物等 HTML CSS support ： HTML、CSS 快捷操作 HTML Snippets ： HTML 代码片段 Htmltagwrap ： 选中代码快速增加 html 标签 - alt + w Image Preview ： 代码中直接显示图片缩略图 Import Cost ：显示 import、require 引用的包的大小 JavaScript (ES6) snippets ：ES6 代码片段 JavaScript Snippet Pack ：ES5 代码片段 npm ：npm 支持 one dark pro ：主题风格 Open in Browser ：alt + B, 直接在浏览器打开文件 Prettier formatter ：超好用的格式化插件 Vetur、vue 2 snippets、vscode-element-helper ：提高 vue 效率的插件 vscode-icons ：给各个文件类型增加图标 Indenticator ： 高亮当前代码层级 Bracket Pair Colorizer ： 括号匹配颜色提示 Color Info ：CSS 颜色显示 Comment V ：添加 JS 注释（个性版） Background ：编辑区域背景萌萌哒 File peek ： 直接在 javascript、typescript 中查看选中区域的缩略图，并可以直接跳转 Log File Highlighter ：控制台输出信息美化 vscode-fileheader ：在文件头部添加注释信息，可在 setting.json 中自定义信息 Markdown Preview Enhanced ：markdown 直接显示 Node.js Modules Intellisense ：自动补充 node modules 输入路径","path":"2019/05/21/VScode快捷键及常用插件/"},{"title":"如何禁止chrome浏览器http自动转成https【转】","text":"转载自：https://www.cnblogs.com/zhanglianghhh/p/9706852.html Chrome浏览器阻止跨域配置：–disable-web-security –user-data-dir=C:\\ChromeDebug 自动跳转原因将HTTP请求自动转为HTTPS请求是浏览器的默认策略。当浏览器访问过某个HTTPS的网站后，再访问该网站时，一切HTTP请求会自动转为HTTPS请求。HTTP转为HTTPS的主要原因是为了安全。 Chrome 浏览器1. 地址栏中输入 chrome://net-internals/#hsts 2. 在 Delete domain security policies 中输入项目的域名，并 Delete 删除 3. 可以在 Query domain 测试是否删除成功 这里如果还是不行， 请清除浏览器缓存！ 参考文章 :如何关闭浏览器的HSTS功能 Safari 浏览器1. 完全关闭 Safari 2. 删除 ~/Library/Cookies/HSTS.plist 这个文件 3. 重新打开 Safari 即可 4. 极少数情况下，需要重启系统 Opera 浏览器和 Chrome 方法一样Firefox 浏览器 1. 关闭所有已打开的页面 2. 清空历史记录和缓存 3. 地址栏输入 about:permissions 4. 搜索项目域名，并点击 Forget About This Site","path":"2019/05/21/如何禁止chrome浏览器http自动转成https【转】/"},{"title":"Vue.js学习笔记Day5-5.08","text":"Vue.js学习笔记Day5-5.08今日主要学习内容： 复习父子组件传值问题； watch、computed和methods之间的对比； nrm的安装使用； Webpack的概念； 使用vue实例的render方法渲染组件； 在普通页面中使用render函数渲染组件； export default 和 export 使用方式； 在vue组件页面中，集成vue-router路由模块； 组件中css作用域问题（scoped属性） 开始Vue框架的学习吧～ 一、复习父子组件传值问题&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;com1 v-bind:parentmsg=&quot;msg&quot; @func=&quot;getMsgFromSon&quot;&gt;&lt;/com1&gt; &lt;/div&gt; &lt;template id=&quot;tmp1&quot;&gt; &lt;div&gt; &lt;h1&gt;这是子元素---{{parentmsg}}&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;向父组件传递消息&quot; @click=&quot;sendMsg&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var com1 = { template: &apos;#tmp1&apos;, data(){ return { msg:&apos;孝顺的孩子&apos; } }, props: [&apos;parentmsg&apos;], methods:{ sendMsg(){ this.$emit(&apos;func&apos;,this.msg) } } } //创建Vue实例，得到ViewModel var vm = new Vue({ el: &apos;#app&apos;, data:{ msg: &apos;父组件中的数据&apos;, msgFromSon: &apos;&apos; }, methods:{ getMsgFromSon(data){ this.msgFromSon = data console.log(this.msgFromSon) } }, components:{ com1 } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 二、名称案例2.1使用keyup事件实现&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 分析 --&gt; &lt;!-- 1.我们要监听到文本框数据的改变，这样才知道什么时候去拼接出一个fullname --&gt; &lt;!-- 2.如何监听到文本框的数据改变 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot; @keyup=&quot;getFullName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot; @keyup=&quot;getFullName&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { firstname:&apos;&apos;, lastname:&apos;&apos;, fullname:&apos;&apos; }, methods: { getFullName(){ this.fullname = this.firstname + &apos;-&apos; + this.lastname } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.2、watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { firstname:&apos;&apos;, lastname:&apos;&apos;, fullname:&apos;&apos; }, methods: {}, watch: { // 使用这个属性，可以监视data中指定数据的变化，然后触发这个watch中对应的function处理函数 &apos;firstname&apos;:function(newVal,oldVal){ this.fullname = newVal + &apos;-&apos; + this.lastname }, &apos;lastname&apos;:function(newVal,oldVal){ this.fullname = this.firstname + &apos;-&apos; + newVal } }, }); &lt;/script&gt; 监听路由对象的改变： &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登陆&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; // 2.创建子组件 var login = { template:&apos;&lt;h3&gt;登陆子组件&lt;/h3&gt;&apos; } var register = { template:&apos;&lt;h3&gt;注册子组件&lt;/h3&gt;&apos; } // 3.创建一个路由对象 var router = new VueRouter({ routes:[ //路由规则数组 {path:&apos;/&apos;,redirect:&apos;/login&apos;}, {path:&apos;/login&apos;,component: login}, {path:&apos;/register&apos;,component: register}, ], linkActiveClass:&apos;myactive&apos; // 激活相关的类 }) var vm = new Vue({ el:&apos;#app&apos;, data:{}, methods:{}, // router: router router, watch:{ &apos;$route.path&apos;:function(newVal,oldVal){ console.log(newVal + &apos;---&apos; + oldVal) if (newVal === &apos;/login&apos;) { console.log(&apos;欢迎进入登陆界面&apos;); } else if (newVal === &apos;/register&apos;) { console.log(&apos;欢迎进入注册界面&apos;); } } } }) &lt;/script&gt; 2.3、computed计算属性的使用 默认只有getter的计算属性： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; = &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;p&gt;{{ fullname }}&lt;/p&gt; &lt;p&gt;{{ fullname }}&lt;/p&gt; &lt;p&gt;{{ fullname }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { firstname:&apos;&apos;, lastname:&apos;&apos; }, methods: {}, computed: { &apos;fullname&apos;:function(){ console.log(&apos;ok&apos;); return this.firstname + &apos;-&apos; + this.lastname } } }); &lt;/script&gt; 注意：在computed中可以定义一些计算属性，计算属性的本质就是一个方法，只不过我们在使用这些计算属性的时候，是把他们的名称直接当作属性来使用的，并不会把计算属性当作方法来调用 计算属性再引用的时候，不要加()去调用，直接把它当普通属性去调用 只要计算属性function内部所用到的任何data中的数据发生变化，就会重新计算这个计算属性的值 计算属性的求职结果，会被缓存起来，方便下次直接使用，如果计算属性方法中，所有来的任何数据，都没有发生过变化，则不会对计算属性求值，如上例，虽然引用了三次fullname，但只输出一次‘ok’ 定义有getter和setter的计算属性： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt; &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { firstName: &apos;jack&apos;, lastName: &apos;chen&apos; }, methods: { changeName() { this.fullName = &apos;TOM - chen2&apos;; } }, computed: { fullName: { get: function () { return this.firstName + &apos; - &apos; + this.lastName; }, set: function (newVal) { var parts = newVal.split(&apos; - &apos;); this.firstName = parts[0]; this.lastName = parts[1]; } } } }); &lt;/script&gt; 2.4、watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； 三、nrm的安装使用 作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址； 什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 注意：nrm只是提供了几个常用的下载包的URL，并能够让我们在这几个地址间很方便地进行切换，但是我们每次装包的时候，使用的工具都是npm 四、Webpack的概念4.1 Webpack引入原因1. 在网页中会引用哪些常见的静态资源？ JS.js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS.css .less .sass .scss Images.jpg .png .gif .bmp .svg 字体文件（Fonts）.svg .ttf .eot .woff .woff2 模板文件.ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 2. 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系（比如bootstrap依赖于jQuery） 3. 如何解决上述两个问题合并、压缩、精灵图、图片的Base64编码可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 4.2 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程webpack官网 webpack安装的两种方式 运行cnpm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行cnpm i webpack --save-dev安装到项目依赖中 4.3 初步使用webpack打包构建列表隔行变色案例 创建项目基本的目录结构 运行cnpm init初始化项目，使用npm管理项目中的依赖包 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑： // 1.导入Jquery import $ from &apos;jquery&apos; const $ = require(&apos;jquery&apos;) $(function(){ $(&apos;li:odd&apos;).css(&apos;backgroundColor&apos;,&apos;lightblue&apos;) $(&apos;li:even&apos;).css(&apos;backgroundColor&apos;,function(){ return&apos;#&apos; + &apos;FF6900&apos; }) }) 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；运行webpack 入口文件路径 输出文件路径对main.js进行处理： webpack .\\src\\main.js .\\dist\\bundle.js 问题处理： 警告 警告：WARNING in configuration The &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for this value. Set &apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults for each environment. You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ 原因是：没有设置webpack的模式，是生产还是开发（production or development） 执行命令：webpack –mode=production 或者 webpack –mode=development 也可以在package.json中进行修改 &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack –mode development&quot;, &quot;build&quot;: &quot;webpack –mode production&quot; } 错误 错误：ERROR in multi ./src/main.js ./dist/bundle.js Module not found: Error: Can&apos;t resolve &apos;.\\dist\\bundle.js&apos; in &apos;D:\\lichang\\Vue_CLI\\Vue\\Day5\\webpack-study&apos; @ multi ./src/main.js ./dist/bundle.js main[1] 原因：目前使用的的webpack版本过高,原来的命令已经不适用了，换成指令 webpack .\\src\\main.js -o .\\dist\\bundle.js --mode development 总结：经过演示，webpack可以做哪些事情 webpack能够处理js间互相依赖关系 webpack能够处理js兼容问题，把高级的浏览器不识别的语法转为低级的浏览器能识别的语法 刚才运行的命令格式：webpack 要打包的文件路径 打包好要输出的文件路径 4.4 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径： 经过配置文件设置、直接使用命令webpack即可进行打包 // 导入处理路径的模块 const path = require(&apos;path&apos;) // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理 module.exports = { entry: path.join(__dirname, &apos;./src/main.js&apos;), // 项目入口文件 output: { // 配置输出选项 path: path.join(__dirname, &apos;./dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 } } 总结：当我们在控制台执行webpack命令时，webpack做了以下几步： 首先，我们并没有通过命令的形式，给它指定入口和出口 webpack就回去项目的根目录中，查找一个叫做webpack.config.js的配置文件 当找到配置文件后，webpack会去执行解析这个配置文件，当解析完这个配置文件后，就得到了配置文件中导出的配置对象 当webpack拿到配置对象后，就拿到了配置对象中指定的入口和出口，然后进行打包构建 4.5 使用webpack-dev-serve实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server -D安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在package.json文件的scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令 接下来运行npm run dev即可进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 此时在http://localhost:8080/ 网站是无法看到bundle.js文件的，说明webpack-dev-server并没有将打包好的bundle.js存放到实际的物理磁盘上，而是托管到电脑的内存中，所以我们在项目根目录中，根本找不到打包好的bundle.js 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为: 4.6 webpack-dev-serve常用命令参数方式1： 修改package.json的script节点如下，其中 –open表示自动打开浏览器 –port 4321表示打开的端口号为4321 –hot表示启用浏览器热更新 –contentBase src指定启动的根目录 &quot;dev&quot;: &quot;webpack-dev-server --contentBase src --hot --port 4321 --open&quot; 注意：热更新用来进行减少不必要的代码更新，每次重新编译只会更新修改过的文件（相当于打补丁）热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明 方式2： 修改webpack.config.js文件，新增devServer节点如下： devServer:{ //相对来说方法2麻烦一些，了解即可 hot:true, //启用热更新第一步 open:true, port:4321, contentBase:&apos;src&apos; } 在头部引入webpack模块： var webpack = require(&apos;webpack&apos;); // 启用热更新第二步 在plugins节点下新增： plugins:[ //配置插件的节点 new webpack.HotModuleReplacementPlugin() //启用热更新第三步 ] 4.7使用html-webpack-plugin插件配置启动页面由于使用–contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin -D安装到开发依赖 修改webpack.config.js配置文件如下： // 导入处理路径的模块 var path = require(&apos;path&apos;); // 导入自动生成HTMl文件的插件 var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); module.exports = { entry: path.resolve(__dirname, &apos;src/js/main.js&apos;), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, &apos;dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 }, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin({ template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径 filename:&apos;index.html&apos;//自动生成的HTML文件的名称 }) ] } 修改package.json中script节点中的dev指令如下： &quot;dev&quot;: &quot;webpack-dev-server&quot; html-webpack-plugin插件两个作用： 自动在内存中根据指定页面生成一个内存的页面 自动把打包好的bundle.js文件追加到页面中去，我们不再需要手动处理bundle.js的引用路径了，所以可以将index.html中script标签注释掉！ 4.8使用webpack处理第三方类型webpack默认只能处理js类型的文件，无法处理其他的非js类型的文件，如果需要非JS类型的文件，我们需要手动安装一些合适的第三方loader加载器 webpack处理第三方文件类型的过程： 发现这个要处理的文件不是js文件，然后就去配置文件中，查找有没有对应的第三方loader规则 如果能找到对应的规则，就会调用相应的loader处理这种文件类型 在调用loader的时候，是从后往前调用的 当最后一个loader调用完毕，会把处理结果，交给webpack进行打包合并，最终输出到bundle.js中去 4.8.1使用webpack打包css文件 新建index.css文件 在main.js引入index.css import &apos;./css/index.css&apos; 如果要打包处理css文件，需要安装cnpm i style-loader css-loader -D 打开webpack.config.js这个配置文件，在里面新增一个配置节点叫module，它是一个对象，在这个module对象上有一个rules属性，是个数组，这个数组中存放了所有第三方文件的匹配和处理规则 module: { // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 { test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] }//处理css文件的规则 ] } 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的 4.8.2使用webpack打包less文件 新建index.less文件 在main.js引入index.less import &apos;./css/index.less&apos; 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件的module节点： { test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] }, 4.8.3使用webpack打包sass文件 新建index.scss文件 在main.js引入index.scss import &apos;./css/index.scss&apos; 运行cnpm i sass-loader node-sass -D 在webpack.config.js中添加处理sass文件的loader模块： { test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] } 4.8.4使用webpack处理css中的路径 运行cnpm i url-loader file-loader -D 在webpack.config.js中添加处理url路径的loader模块： { test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader&apos; } 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码；通过[hash:8]来设置留八位hash编码，[name]用来保留原来的照片名，[ext]用来保留原来的后缀名 { test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=43960&amp;name=[hash:8]-[name].[ext]&apos; }, 4.8.5使用webpack处理字体文件 在main.js引入bootstrap.css import &apos;bootstrap/dist/css/bootstrap.css&apos; 运行安装cnpm i bootstrap -S 在webpack.config.js中添加处理字体文件的loader模块： { test: /\\.(svg|ttf|eot|woff|woff2)$/, use: &apos;url-loader&apos; } 注意：遇到安装完bootstrap无法显示字体的现象，原因是版本问题，默认安装最新版本4.3.1，手动改为3.4.1版本即可 cnpm i bootstrap@3.4.1-D 4.8.6使用babel处理高级JS语法 在 webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中，通过 Babel ，可以帮我们将 高级的语法转换为低级的语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime -D安装babel的相关loader包 运行cnpm i babel-preset-env babel-preset-stage-0 -D安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项： { test: /\\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ } 注意： 在配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉：原因有俩： 如果 不排除 node_modules， 则Babel 会把 node_modules 中所有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢； 哪怕，最终，Babel 把 所有 node_modules 中的JS转换完毕了，但是，项目也无法正常运行！ 在项目根目录中添加.babelrc文件，并修改这个配置文件如下： { &quot;presets&quot;:[&quot;env&quot;, &quot;stage-0&quot;], &quot;plugins&quot;:[&quot;transform-runtime&quot;] } 了解： 目前，我们安装的 babel-preset-env, 是比较新的ES语法， 之前， 我们安装的是 babel-preset-es2015, 现在，出了一个更新的 语法插件，叫做 babel-preset-env ，它包含了 所有的 和 es***相关的语法 问题描述： Error: Cannot find module &apos;@babel/core&apos; babel-loader@8 requires Babel 7.x (the package &apos;@babel/core&apos;). If you&apos;d like to use Babel 6.x (&apos;babel-core&apos;), you should install &apos;babel-loader@7&apos;. 最初以为是babel-core没有安装上。重装了好几遍babel-core还是不行。对照以前的项目,发现babel-loader的版本不一样,之前的是@7.1.5版本,而现在是@8.0.0版本。 cnpm install babel-loader@7.1.5 -D 五、使用vue实例的render方法渲染组件 在页面中渲染基本的组件 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;33333&lt;/p&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;这是登录组件&lt;/h1&gt;&apos; } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, components: { login } }); &lt;/script&gt; &lt;/body&gt; 在页面中使用render函数渲染组件 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;444444&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;这是登录组件&lt;/h1&gt;&apos; } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, render: function (createElements) { // createElements 是一个 方法，调用它，能够把 指定的 组件模板，渲染为 html 结构 return createElements(login) // 注意：这里 return 的结果，会 替换页面中 el 指定的那个 容器 } }); &lt;/script&gt; &lt;/body&gt; 两者区别：使用render函数渲染的组件直接替换整个div模块，所以不会再显示p标签444444，而在页面中直接导入组件则不会替换掉div整个模块的内容，两者区别相当于v-text和差值表达式的区别 六、在普通页面中使用render函数渲染组件在webpack中配置.vue组件页面的解析 运行cnpm i vue -S将vue安装为运行依赖； 注意： 在 webpack 中， 使用 import Vue from &#39;vue&#39;导入的 Vue 构造函数，功能不完整，只提供了 runtime-only 的方式，并没有提供 像网页中那样的使用方式； 在使用webpack构建的Vue项目中使用模板对象解决方法： 在main.js中引入import Vue from &#39;vue&#39;，查看node_modules-vue-package.json文件，可以看到我们目前引入的是vue.runtime.common.js，把这个路径换成指向vue.js文件（不提倡） 直接在main.js引入import Vue from ‘../node_modules/vue/dist/vue.js’（不提倡） 在main.js中引入import Vue from ‘vue’，在webpack.config.js中添加resolve属性 默认，webpack 无法打包 .vue 文件，需要安装 相关的loader，运行cnpm i vue-loader vue-template-compiler -D将解析转换vue的包安装为开发依赖； 运行cnpm i style-loader css-loader -D将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式； 在webpack.config.js配置文件中，添加如下module规则： module: { rules: [ { test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] }, { test: /\\.vue$/, use: &apos;vue-loader&apos; } ] } 创建App.js组件页面： &lt;template&gt; &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt; &lt;div&gt; &lt;h1&gt;这是APP组件 - {{msg}}&lt;/h1&gt; &lt;h3&gt;我是h3&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象 export default { data() { return { msg: &apos;OK&apos; } } } &lt;/script&gt; &lt;style scoped&gt; h1 { color: red; } &lt;/style&gt; 创建main.js入口文件： // 导入 Vue 组件 import Vue from &apos;vue&apos; // 导入 App组件 import App from &apos;./components/App.vue&apos; // 创建一个 Vue 实例，使用 render 函数，渲染指定的组件 var vm = new Vue({ el: &apos;#app&apos;, render: c =&gt; c(App) }); 注意：render: c =&gt; c(App)是下式的缩写 render: function (createElements) { return createElements(App) } 复习 在普通网页中如何使用vue：1. 使用 script 标签 ，引入 vue 的包 2. 在 index 页面中，创建 一个 id 为 app div 容器 3. 通过 new Vue 得到一个 vm 的实例 回顾 包的查找规则：1. 找 项目根目录中有没有 node_modules 的文件夹 2. 在 node_modules 中 根据包名，找对应的 vue 文件夹 3. 在 vue 文件夹中，找 一个叫做 package.json 的包配置文件 4. 在 package.json 文件中，查找 一个 main 属性【main属性指定了这个包在被加载时候，的入口文件】 七、export default 和 export 使用方式 ES6中导入模块，使用 import 模块名称 from ‘模块标识符’ import ‘表示路径’，使用 export default 和 export 向外暴露成员；在Node中 使用 var 名称 = require(‘模块标识符’)，module.exports 和 exports 来暴露成员，两套方法不可混用 export default 和 export的区别： var info = { name: &apos;zs&apos;, age: 20 } export default info /* export default { address: &apos;北京&apos; } */ // 注意： export default 向外暴露的成员，可以使用任意的变量来接收 // 注意： 在一个模块中，export default 只允许向外暴露1次 // 注意： 在一个模块中，可以同时使用 export default 和 export 向外暴露成员 export的引用方式： export var title = &apos;小星星&apos; export var content = &apos;哈哈哈&apos; // 注意： 使用 export 向外暴露的成员，只能使用 { } 的形式来接收，这种形式，叫做 【按需导出】 // 注意： export 可以向外暴露多个成员， 同时，如果某些成员，我们在 import 的时候，不需要，则可以 不在 {} 中定义 // 注意： 使用 export 导出的成员，必须严格按照 导出时候的名称，来使用 {} 按需接收； // 注意： 使用 export 导出的成员，如果 就想 换个 名称来接收，可以使用 as 来起别名； 使用 import from 和 import ‘路径’ 还有 import {a, b} from ‘模块标识’ 导入其他模块 import m222, { title as title123, content } from &apos;./test.js&apos; console.log(m222) console.log(title123 + &apos; --- &apos; + content) 八、在vue组件页面中，集成vue-router路由模块vue-router官网 cnpm install vue-router 导入路由模块： import Vue from &apos;vue&apos; import VueRouter from &apos;vue-router&apos; 安装路由模块： Vue.use(VueRouter); 导入需要展示的组件: import login from &apos;./components/account/login.vue&apos; import register from &apos;./components/account/register.vue&apos; 创建路由对象: var router = new VueRouter({ routes: [ { path: &apos;/&apos;, redirect: &apos;/login&apos; }, { path: &apos;/login&apos;, component: login }, { path: &apos;/register&apos;, component: register } ] }); 将路由对象，挂载到 Vue 实例上: var vm = new Vue({ el: &apos;#app&apos;, // render: c =&gt; { return c(App) } render(c) { return c(App); }, router // 将路由对象，挂载到 Vue 实例上 }); 改造App.vue组件，在 template 中，添加router-link和router-view： &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; 九、组件中css作用域问题（scoped属性） 普通的style标签，只支持普通的样式，如果想要启用scss或者less，需要为style元素设置lang属性 &lt;style lang=&quot;scss&quot; scoped&gt; 只要是style标签，是在.vue组件中定义的，那么推荐都为style开启scoped属性，可以防止组件间样式相互干扰，样式的scoped属性是通过css的属性选择器实现的","path":"2019/05/08/Vue-js学习笔记Day5-5-08/"},{"title":"Vue.js学习笔记Day4-5.06","text":"Vue.js学习笔记Day4-5.06今日主要学习内容： 使父组件向子组件传值； 子组件向父组件传值； 评论列表案例； 使用 this.$refs 来获取元素和组件； 什么是路由； 设置路由高亮； 设置路由高亮设置路由切换动效； 在路由规则中定义参数； 使用 children 属性实现路由嵌套； 命名视图实现经典布局； 开始Vue框架的学习吧～ 一、使父组件向子组件传值父组件向子组件传递数据：子组件在父组件的并作为标签引入，通过设置标签的属性传递数据，在子组件用props接受，例如下面这样，父组件parent.vue引入子组件child.vue，将父组件的数据name通过设置标签child的name属性传递给子组件，子组件通过props传递接受，接受后，在子组件内this.name就是父组件的name数据。 1. 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { msg: &apos;123 啊-父组件中的数据&apos; }, methods: {}, components: { // 结论：经过演示，发现，子组件中，默认无法访问到 父组件中的 data 上的数据 和 methods 中的方法 com1: { data() { // 注意： 子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上； // data 上的数据，都是可读可写的； return { title: &apos;123&apos;, content: &apos;qqq&apos; } }, template: &apos;&lt;h1 @click=&quot;change&quot;&gt;这是子组件 --- {{ parentmsg }}&lt;/h1&gt;&apos;, // 注意： 组件中的 所有 props 中的数据，都是通过 父组件传递给子组件的 // props 中的数据，都是只读的，无法重新赋值 props: [&apos;parentmsg&apos;], // 把父组件传递过来的 parentmsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据 directives: {}, filters: {}, components: {}, methods: { change() { this.parentmsg = &apos;被修改了&apos; } } } } }); &lt;/script&gt; data和props中数据的差别：1）子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上；props 中的数据，都是通过 父组件传递给子组件的2）data 上的数据，都是可读可写的；props 中的数据，都是只读的，无法重新赋值 2. 使用v-bind或简化指令，将数据传递到子组件中：父组件，可以在引用子组件的时候， 通过`属性绑定（v-bind:）`的形式, 把 需要传递给 子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 &lt;div id=&quot;app&quot;&gt; &lt;!-- 父组件，可以在引用子组件的时候， 通过 属性绑定（v-bind:） 的形式, 把 需要传递给 子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 --&gt; &lt;com1 v-bind:parentmsg=&quot;msg&quot;&gt;&lt;/com1&gt; &lt;/div&gt; 二、子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; 父组件向子组件 传递 方法，使用的是 事件绑定机制； v-on, 当我们自定义了一个事件属性之后，那么子组件就能够通过某些方式，来调用传递进去的这个方法了 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 &lt;div id=&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;com2 @func=&quot;show&quot;&gt;&lt;/com2&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是 子组件&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;这是子组件中的按钮 - 点击它，触发 父组件传递过来的 func 方法&quot; @click=&quot;myclick&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 定义了一个字面量类型的 子组件模板对象 var com2 = { template: &apos;#tmpl&apos;, // 通过指定了一个 Id, 表示 说，要去加载 这个指定Id的 template 元素中的内容，当作 组件的HTML结构 data() { return { sonmsg: { name: &apos;小头儿子&apos;, age: 6 } } }, methods: { myclick() { // 当点击子组件的按钮的时候，如何 拿到 父组件传递过来的 func 方法，并调用这个方法？？？ // emit 英文原意： 是触发，调用、发射的意思 // this.$emit(&apos;func123&apos;, 123, 456) this.$emit(&apos;func&apos;, this.sonmsg) } } } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { datamsgFormSon: null }, methods: { show(data) { // console.log(&apos;调用了父组件身上的 show 方法: --- &apos; + data) // console.log(data); this.datamsgFormSon = data } }, components: { com2 // com2: com2 } }); &lt;/script&gt; 兄弟组件传递数据eventBus同级传参或者隔级传参可以用eventBus（事件车），内部也是发布订阅模式实现的，适合于非常简单的小项目，一般不用(互相帮)中间键思想 :创建一个vue的实例,然后给每个子组件绑定一个方法(触发时候发布eventBus),在 每个子组件做一个订阅的监控,触发绑在created里的方法执行,靠传递参数的不同实现同步数据 (颜色) 三、评论列表案例目标：主要练习父子组件之间传值 发表评论的方法：分析：发表评论的业务逻辑 评论数据存到哪里去？？？ 存放到了 localStorage 中 localStorage.setItem(‘cmts’, ‘’) 先组织出一个最新的评论数据对象 想办法，把 第二步中，得到的评论对象，保存到 localStorage 中： localStorage 只支持存放字符串数据， 要先调用JSON.stringify 在保存最新的评论数据之前，要先从 localStorage 获取到之前的评论数据（string）， 转换为 一个 数组对象， 然后，把最新的评论， push 到这个数组 如果获取到的 localStorage 中的 评论字符串，为空不存在， 则 可以 返回一个 ‘[]’ 让 JSON.parse 去转换 把最新的评论列表数组，再次调用 JSON.stringify 转为数组字符串，然后调用 localStorage.setItem() &lt;div id=&quot;app&quot;&gt; &lt;cmt-box @func=&quot;loadComments&quot;&gt;&lt;/cmt-box&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot; v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;span class=&quot;badge&quot;&gt;评论人： {{ item.user }}&lt;/span&gt; {{ item.content }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; // 定义一个模版定义 &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论人：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论内容：&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; v-model=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;发表评论&quot; class=&quot;btn btn-primary&quot; @click=&quot;postComment&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var commentBox = { data() { return { user: &apos;&apos;, content: &apos;&apos; } }, template: &apos;#tmpl&apos;, methods: { postComment() { var comment = { id: Date.now(), user: this.user, content: this.content } // 从 localStorage 中获取所有的评论 var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) list.unshift(comment) // 重新保存最新的 评论数据 localStorage.setItem(&apos;cmts&apos;, JSON.stringify(list)) this.user = this.content = &apos;&apos; // this.loadComments() // ????? this.$emit(&apos;func&apos;) } } } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { list: [ { id: Date.now(), user: &apos;李白&apos;, content: &apos;天生我材必有用&apos; }, { id: Date.now(), user: &apos;江小白&apos;, content: &apos;劝君更尽一杯酒&apos; }, { id: Date.now(), user: &apos;小马&apos;, content: &apos;我姓马， 风吹草低见牛羊的马&apos; } ] }, beforeCreate(){ // 注意：这里不能调用 loadComments 方法，因为在执行这个钩子函数的时候，data 和 methods 都还没有被初始化好 }, created(){ this.loadComments() }, methods: { loadComments() { // 从本地的 localStorage 中，加载评论列表 var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) this.list = list } }, components: { &apos;cmt-box&apos;: commentBox } }); &lt;/script&gt; 四、使用 this.$refs 来获取元素和组件&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素&quot; @click=&quot;getElement&quot; ref=&quot;mybtn&quot;&gt; &lt;h3 id=&quot;myh3&quot; ref=&quot;myh3&quot;&gt;哈哈哈， 今天天气太好了！！！&lt;/h3&gt; &lt;hr&gt; &lt;login ref=&quot;mylogin&quot;&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; var login = { template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;, data() { return { msg: &apos;son msg&apos; } }, methods: { show() { console.log(&apos;调用了子组件的方法&apos;) } } } // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: { getElement() { // console.log(document.getElementById(&apos;myh3&apos;).innerText) // ref 是 英文单词 【reference】 值类型 和 引用类型 referenceError // console.log(this.$refs.myh3.innerText) // console.log(this.$refs.mylogin.msg) // this.$refs.mylogin.show() } }, components: { login } }); &lt;/script&gt; 五、什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；#的意义：代表网页中的一个位置，其右边的字符，就是该位置的标识符URL中的hash（井号） 路由的使用： 导入 vue-router 组件类库： &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt; 使用 router-link 组件来导航，用来切换组件 &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 router-view 组件是 vue-router 提供的元素，专门用来当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 &lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 // 4.1 使用 Vue.extend 来创建登录组件 var login = Vue.extend({ template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos; }); // 4.2 使用 Vue.extend 来创建注册组件 var register = Vue.extend({ template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; }); 创建一个路由 router 实例，通过 routes 属性来定义路由匹配规则 创建一个路由对象， 当 导入 vue-router 包之后，在 window 全局对象中，就有了一个 路由的构造函数，叫做 VueRouter 在 new 路由对象的时候，可以为 构造函数，传递一个配置对象 路由匹配规则： 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性： 属性1 是 path， 表示监听 哪个路由链接地址； 属性2 是 component， 表示，如果 路由是前面匹配到的 path ，则展示 component 属性对应的那个组件 注意： component 的属性值，必须是一个 组件的模板对象， 不能是 组件的引用名称； var routerObj = new VueRouter({ routes: [ { path: &apos;/login&apos;, component: login }, { path: &apos;/register&apos;, component: register } ] }); 使用 router 属性来使用路由规则 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 var vm = new Vue({ el: &apos;#app&apos;, router: routerObj // 使用 router 属性来使用路由规则 }); 使用redirect重定向URL路径 { path: &apos;/&apos;, redirect: &apos;/login&apos; }, // 这里的 redirect 和 Node 中的 redirect 完全是两码事 使用tag属性指定router-link渲染的标签类型 &lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;登录&lt;/router-link&gt; 示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;!-- 1.导入包 --&gt; &lt;script src=&quot;./lib/vue-router-3.0.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登陆&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; // 2.创建子组件 var login = { template:&apos;&lt;h3&gt;登陆子组件&lt;/h3&gt;&apos; } var register = { template:&apos;&lt;h3&gt;注册子组件&lt;/h3&gt;&apos; } // 3.创建一个路由对象 var router = new VueRouter({ routes:[ //路由规则数组 {path:&apos;/&apos;,redirect:&apos;/login&apos;}, {path:&apos;/login&apos;,component: login}, {path:&apos;/register&apos;,component: register}, ], linkActiveClass:&apos;myactive&apos; // 激活相关的类 }) var vm = new Vue({ el:&apos;#app&apos;, data:{}, methods:{}, // router: router router }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 六、设置路由高亮 给router-link-active自定义样式 &lt;style&gt; .router-link-active{ color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; } &lt;/style&gt; 设置自己的激活类 给routerObj设置linkActiveClass: ‘myactive’，然后自定义myactive的样式 &lt;style&gt; .myactive { color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; } &lt;/style&gt; 七、设置路由高亮设置路由切换动效 将路由用动画符包裹起来 &lt;transition mode=&quot;out-in&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; 自定义两组动画类 &lt;style&gt; .v-enter, .v-leave-to { opacity: 0; transform: translateX(140px); } .v-enter-active, .v-leave-active { transition: all 0.5s ease; } &lt;/style&gt; 八、在路由规则中定义参数 使用query方式传递参数：如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 &lt;router-link to=&quot;/login?id=10&amp;name=zs&quot;&gt;登录&lt;/router-link&gt; var login = { template: &apos;&lt;h1&gt;登录 --- {{ $route.query.id }} --- {{ $route.query.name }}&lt;/h1&gt;&apos; } 通过 this.$route.params来获取路由中的参数： {{ path: '/login/:id/:name', component: login }} var login = { template: &apos;&lt;h1&gt;登录 --- {{ $route.params.id }} --- {{ $route.params.name }}&lt;/h1&gt;&apos; } 九、使用 children 属性实现路由嵌套&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; //父路由的组件定义 &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to=&quot;/account/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/account/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; // 父路由中的组件 var account = { template: &apos;#tmpl&apos; } // 子路由中的 login 组件 var login = { template: &apos;&lt;h3&gt;登录&lt;/h3&gt;&apos; } // 子路由中的 register 组件 var register = { template: &apos;&lt;h3&gt;注册&lt;/h3&gt;&apos; } // 路由实例：使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址；不能和父组件设置同级，不然组件无法嵌套 var router = new VueRouter({ routes: [ { path: &apos;/account&apos;, component: account, children: [ { path: &apos;login&apos;, component: login }, { path: &apos;register&apos;, component: register } ] } // { path: &apos;/account/login&apos;, component: login }, // { path: &apos;/account/register&apos;, component: register } ] }) // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, router }); 十、命名视图实现经典布局 标签代码结构： &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;container&quot;&gt; &lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： &lt;script&gt; var header = { template: &apos;&lt;h1 class=&quot;header&quot;&gt;Header头部区域&lt;/h1&gt;&apos; } var leftBox = { template: &apos;&lt;h1 class=&quot;left&quot;&gt;Left侧边栏区域&lt;/h1&gt;&apos; } var mainBox = { template: &apos;&lt;h1 class=&quot;main&quot;&gt;mainBox主体区域&lt;/h1&gt;&apos; } // 创建路由对象 var router = new VueRouter({ routes: [ /* { path: &apos;/&apos;, component: header }, { path: &apos;/left&apos;, component: leftBox }, { path: &apos;/main&apos;, component: mainBox } */ { path: &apos;/&apos;, components: { &apos;default&apos;: header, &apos;left&apos;: leftBox, &apos;main&apos;: mainBox } } ] }) // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: {}, methods: {}, router }); &lt;/script&gt; CSS 样式： &lt;style&gt; html, body { margin: 0; padding: 0; } .header { background-color: orange; height: 80px; } h1 { margin: 0; padding: 0; font-size: 16px; } .container { display: flex; height: 600px; } .left { background-color: lightgreen; flex: 2; } .main { background-color: lightpink; flex: 8; } &lt;/style&gt;","path":"2019/05/06/Vue-js学习笔记Day4-5-06/"},{"title":"Vue.js学习笔记Day3-4.29","text":"Vue.js学习笔记Day3-4.29今日主要学习内容： 使用Vue-resource实现品牌的增删查功能； Vue中的动画； 使用过渡类名实现动画 使用第三方 CSS 动画库 使用动画钩子函数 v-for 的列表过渡 使用定义Vue组件； 什么是组件 组件化和模块化的不同 全局组件定义的三种方式 组件中展示数据和响应事件 使用components属性定义局部子组件 两种切换组件方法 开始和我一起Vue框架的学习吧～ 一、使用Vue-resource实现品牌的增删查功能&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/vue-resource-1.3.4.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/bootstrap-3.3.7.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body form-inline&quot;&gt; &lt;!-- &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; --&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot; class=&quot;form-control&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot; class=&quot;btn btn-primary&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=&quot;table table-bordered table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; // 全局配置数据接口的根域名 //注意每次单独发起http请求的时候，请求的URL路径应该以相对路径开头，前面不能带‘/’，否则不会启用根路径拼接 Vue.http.options.root = &apos;http://localhost:63342/vue/&apos;; //全局启用emulateJson选项，防止未添加的时候的情况 Vue.http.options.emulateJSON = true; var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 name: &apos;&apos;, list: [ //存放所有品牌列表的数组 {id: 1, name: &apos;奔驰&apos;, ctime: new Date() }, {id: 2, name: &apos;宝马&apos;, ctime: new Date() } ] }, created(){ //当vm实例的data和methods初始化完毕后，vm实例会自动执行created这个生命周期函数 this.getAllList(); }, methods:{ //methods指示我们要触发的方法 getAllList(){ //获取所有的品牌列表 // 分析： // 1. 由于已经导入了vue-resource这个包，所以可以直接通过this.$http来发起数据请求 // 2. 根据接口API文档，知道获取列表的时候，应该发起一个get请求 // 3. this.$http.get(&apos;url&apos;).then(function(result){}) // 4. 当通过then指定回调函数之后，在回调函数中，可以拿到数据服务器返回的result // 5. 先判断result.status是否等于0，如果等于0，可以吧result.message赋值给this.list；如果不等于0，可以弹框提醒，获取数据失败！ this.$http.get(&apos;http://vue.studyit.io/api/getprodlist&apos;).then(result =&gt; { //注意： 通过$http获取到的数据，都在 result.body中放着 var result = result.body; if(result.status === 0){ //成功了 this.list = result.message; }else{ //失败了 alert(&apos;获取数据失败！&apos;); } }) }, add(){ // 添加品牌列表到后台服务器 // 分析： // 1. 通过查看数据API接口，发现要发送一个post请求this.$http.post // 2. this.$http.post()中接受三个参数： // 2.1 第一个参数：要请求的URL地址 // 2.2 第二个参数：要提交给服务器的数据，要以对象形式提交给服务器（name：this.name） // 2.3 第三个参数：是一个配置对象，要以哪种表单数据类型提交过去（emulate JSON：true），以普通表单形式，将数据提交给服务器application/x-www-form-urlencoded // 3. 在post方法中，使用.then来设置成功的回调函数，如果想要拿到成功的结果，需要result.body this.$http.post(&apos;http://vue.studyit.io/api/addproduct&apos;,{name: this.name},{emulateJSON:true}).then(result =&gt; { //注意： 通过$http获取到的数据，都在 result.body中放着 //var result = result.body; if(result.body.status === 0){ //成功了，添加完成后，只需要手动调用getAllList（）就能刷新品牌列表 this.getAllList(); this.name = &apos;&apos;; }else{ //失败了 alert(&apos;添加失败！&apos;); } }) }, del(id){ //删除品牌列表 this.$http.get(&apos;http://vue.studyit.io/api/delproduct/&apos; + id).then(result=&gt;{ if(result.body.status === 0){ //成功了 this.getAllList(); }else{ //失败了 alert(&apos;删除失败！&apos;); } }) }, } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 二、Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果，包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 1.使用过渡类名实现动画 1.1设置HTML结构： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 需求： 点击按钮，让H3显示，再点击，让H3隐藏 --&gt; &lt;!-- 1.使用transition把需要被动画控制的元素包裹起来，transition是Vue官方提供--&gt; &lt;transition&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; 1.2创建VM 实例： &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 flag: false, }, methods:{ //methods指示我们要触发的方法 } }) &lt;/script&gt; 1.3定义两组类样式： &lt;!-- 2.自定义两组样式，来控制transition内部的元素实现动画 --&gt; &lt;style&gt; /*v-enter是一个时间点，进入之前，元素的起始状态，此时还没有开始进入*/ /*v-leave-to是一个时间点，是动画离开之后，离开的终止状态，此时元素动画已经结束*/ .v-enter,.v-leave-to{ opacity: 0; transform: translateX(150px); } /*v-enter-active是入场动画时间段,v-leave-active是离场动画时间段*/ .v-enter-active,.v-leave-active{ transition: all 0.8s ease; } &lt;/style&gt; 注意：当设置时，可以自定义动画前缀，动画类改为.my-enter.my-leave-to 2.使用第三方 CSS 动画库 2.1导入动画类库： &lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/animate.css&quot;&gt; &lt;!-- 注意：入场使用bounceIn 离场使用bounceOut --&gt; 2.2定义 transition 及属性： &lt;transition enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated bounceOut&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; 2.3使用:druation=”毫秒值”来统一设置入场时长和离场时长 &lt;!-- 使用:druation=&quot;毫秒值&quot;来统一设置入场时长和离场时长--&gt; &lt;!-- 使用:druation=&quot;{enter:200,leave:400}&quot;来分别设置入场时长和离场时长--&gt; &lt;transition enter-active-class=&quot;bounceIn&quot; leave-active-class=&quot;bounceOut&quot; :druation=&quot;{enter:200,leave:400}&quot;&gt; &lt;h3 v-if=&quot;flag&quot; class=&quot;animated&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; 3.使用动画钩子函数 3.1定义 transition 组件以及三个钩子函数： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;加入购物车&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 使用transition把小球包裹起来 --&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 3.2定义三个 methods 钩子方法： methods:{ //methods指示我们要触发的方法 // 注意：动画钩子函数的第一个参数：el，表示要执行动画的那个DOM元素，是个原生的JS DOM对象 //大家可以认为，el是通过 document.getElementById(&apos;&apos;) 方式获取到的原生的JS DOM对象 beforeEnter(el){ //beforeEnter表示动画入场之前，此时动画尚未开始，可以在beforeEnter中设置元素开始动画之前的起始样式 //设置小球开始动画之前的起始位置 el.style.transform = &quot;translate(0,0)&quot;; }, enter(el,done){ //这句话没有实际效用，但写了el.offsetWidth可以出现动画效果，可以认为它强制动画刷新 el.offsetWidth; //enter 表示动画开始之后的样式，这里可以设置小球完成动画之后的结束状态 el.style.transform = &quot;translate(150px, 450px)&quot;; el.style.transition = &apos;all 1s ease&apos; //这里的done()就是afterEnter函数，也就是：done是afterEnter函数的引用，不使用done会产生延迟 done(); }, afterEnter(el){ //动画完成之后会调用afterEnter //console.log(&apos;ok!&apos;); this.flag=!this.flag; }, } 3.3定义动画过渡时长和样式： &lt;style&gt; .ball{ width: 15px; height: 15px; border-radius: 50%; background-color: red; } &lt;/style&gt; 4.v-for 的列表过渡 4.1定义过渡样式： &lt;style&gt; li{ border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; } /* 用来实现鼠标滑动时显示粉色 */ li:hover{ background-color: hotpink; transition: all 0.4s ease; } /* 用来实现新加列表向上弹出显示 */ .v-enter, .v-leave-to{ opacity: 0; transform: translateY(80px); } .v-enter-active, .v-leave-active{ transition: all 0.6s ease; } /* .v-move和.v-leave-active配合使用，能够实现列表后续的元素渐渐地漂上来的效果，更加平缓柔和 */ .v-move{ transition: all 0.6s ease; } .v-leave-active{ position: absolute; } &lt;/style&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 4.2定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- 在实现列表过度的时候，如果需要过度的元素，是通过v-for循环渲染出来的，不能使用transition包裹，需要使用transitionGroup --&gt; &lt;!-- 如果要为v-for循环创建的元素设置动画，必须为每一个元素设置：key属性 --&gt; &lt;!-- appear用于实现刚进入页面时列表滑动显示效果 --&gt; &lt;!-- 通过为transition-group元素设置tag属性，指定它渲染为指定的元素，若不指定tag属性，则渲染为span标签，不符合语法规范 --&gt; &lt;transition-group appear tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;(item,i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; {{item.id}}---{{item.name}} &lt;/li&gt; &lt;/transition-group&gt; &lt;/ul&gt; &lt;/div&gt; 4.3定义 VM中的结构： &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 id: &apos;&apos;, name: &apos;&apos;, list: [ {id:1,name: &apos;张三&apos;}, {id:2,name: &apos;李四&apos;}, {id:3,name: &apos;王五&apos;}, {id:4,name: &apos;赵六&apos;}, ] }, methods:{ //methods指示我们要触发的方法 add(){ this.list.push({ id: this.id, name: this.name}); this.id=this.name=&apos;&apos;; }, del(i){ this.list.splice(i,1); }, } }) &lt;/script&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器 三、使用定义Vue组件1. 什么是组件：组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可； 2. 组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 3. 全局组件定义的三种方式1）使用 Vue.extend 配合 Vue.component 方法：注意：如果使用Vue.component定义全局组件的时候，组件名称使用了驼峰命名，则在引用组件的时候，需要把大写的驼峰改写为小写的字母，同时，两个单词之前用-连接；如果不使用驼峰命名，则直接拿该名称来使用即可 // 1.1使用vue.extend来创建全局的Vue组件 var com1 = Vue.extend({ //通过template属性，指定了组件要展示的HTML结构 template:&apos;&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;&apos; }) // 1.2使用Vue.component(&apos;组件的名称&apos;，创建出来的组件模板对象) Vue.component(&apos;myCom1&apos;,com1) Vue.component： 第一个参数：组件的名称，将来在引用组件的时候，就是一个标签形式来引入它 第二个参数：通过Vue.extend创建的组件，其中template就是组件将来要展示的HTML内容 Vue.component(&apos;myCom1&apos;,Vue.extend({ template:&apos;&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;&apos; })) 2）直接使用 Vue.component 方法： 注意：无论是哪种方式创建出来的组件，组件的template属性指向的模板内容，必须有且只能有唯一的一个根元素 用这种方法更简单，但是html语句书写起来没有提示更不方便书写 Vue.component(&apos;mycom2&apos;, { template: &apos;&lt;div&gt;&lt;h3&gt;这是直接使用Vue.component创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;&apos; }); 3）将模板字符串，定义到script标签种： 这是通过template元素在外部定义的组件结构，这个方式有代码的智能提示和高亮 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ &lt;!-- 在被控制的#app外面，使用template元素，定义组件的HTML模板结构 --&gt; &lt;template id=&quot;temp1&quot;&gt; &lt;div&gt; &lt;h3&gt;这是通过template元素在外部定义的组件结构&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; 同时，需要使用 Vue.component 来定义组件： Vue.component(&apos;mycom3&apos;, { template: &apos;#tmp1&apos; }); 4. 组件中展示数据和响应事件1）在组件中，data需要被定义为一个方法，例如： 组件可以有自己的data数据 组件的data和实例的data有点不一样，实例中的data可以作为一个对象，但是组件中的data必须是一个方法 组件中的data出了必须作为一个方法之外，这个方法内部，还必须返回一个对象才行 组件中的data数据和实例中的使用方式一模一样 Vue.component(&apos;mycom2&apos;, { template: &apos;&lt;h3&gt;这是全局组件 ---{{msg}}&lt;/h3&gt;&apos;, data:function(){ return{ msg: &apos;这是组件中data定义的数据&apos; }; }, methods:{ } }); 2）在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问；【重点】：为什么组件中的data属性必须定义为一个方法并返回一个对象：因为共用同一个dataObj导致几个计时器会相互干扰 // 这是一个计数器的组件，身上有个按钮，每当点击按钮，让data中的count值+1 Vue.component(&apos;counter&apos;, { template: &apos;#tmp1&apos;, data:function(){ // return dataObj; return{ count:0, }; }, methods:{ increment(){ this.count +=1 } } }); 5.使用components属性定义局部子组件1）组件实例定义方式：var vm2 = new Vue({ el:&apos;#app2&apos;, data: {}, methods: {}, filters: {}, directives: {}, components: { //用于定义实例内部私有组件的 login: { template: &apos;&lt;h1&gt;这是私有的login组件&lt;/h1&gt;&apos; } }, beforeCreate(){}, created(){}, beforeMount(){}, mounted(){}, beforeUpdate(){}, updated(){}, beforeDestroy(){}, destroyed(){}, }) 2）引用组件：&lt;div id=&quot;app2&quot;&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; 6.切换组件方法方法一：使用flag标识符结合v-if和v-else切换组件（仅用于两个组件间切换） 页面结构： &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=true&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=false&quot;&gt;注册&lt;/a&gt; &lt;login v-if=&quot;flag&quot;&gt;&lt;/login&gt; &lt;register v-else=&quot;flag&quot;&gt;&lt;/register&gt; &lt;/div&gt; Vue实例定义： &lt;script&gt; Vue.component(&apos;login&apos;, { template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; }); Vue.component(&apos;register&apos;, { template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; }); var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 flag: false, }, methods:{ //methods指示我们要触发的方法 } }) &lt;/script&gt; 缺陷：只能两个组件相互切换，更多组件无法使用v-if和v-else 方法二：使用:is属性来切换不同的子组件,并添加切换动画（可用于多个组件间切换） 组件实例定义方式： &lt;script&gt; // 组件名称是一个字符串，所以放到：is里要用引号引起来 Vue.component(&apos;login&apos;, { template: &apos;&lt;h3&gt;登录组件&lt;/h3&gt;&apos; }); Vue.component(&apos;register&apos;, { template: &apos;&lt;h3&gt;注册组件&lt;/h3&gt;&apos; }); var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 comName: &apos;&apos; //当前component中的：is绑定的组件名称 }, methods:{ //methods指示我们要触发的方法 } }) &lt;/script&gt; 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;login&apos;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&apos;register&apos;&quot;&gt;注册&lt;/a&gt; &lt;!-- Vue提供了component，来展示对应名称的组件 --&gt; &lt;!-- component是一个占位符，：is属性可以用来指定要展示的组件名称 --&gt; &lt;!-- 通过mode属性，设置组件切换时候的模式 --&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;!-- 总结：当前学习了几个Vue提供的标签 --&gt; &lt;!-- component，template,transition,transitionGroup --&gt; &lt;/div&gt; 注意： 通过mode属性，设置mode=”out-in”，设置组件切换时候先出后进的模式 –&gt; 添加切换样式： &lt;style&gt; .v-enter, .v-leave-to{ opacity: 0; transform: translateX(150px); } .v-enter-active, .v-leave-active{ transition: all 0.5s ease; } &lt;/style&gt;","path":"2019/04/29/Vue-js学习笔记Day3-4-29/"},{"title":"Vue.js学习笔记Day2-4.24","text":"Vue.js学习笔记Day2-4.24今日主要学习内容： 品牌列表案例； 全局过滤器和私有过滤器； 自定义按键修饰符； 自定义指令； Vue实例的生命周期； vue-resource 实现 get, post, jsonp请求； 配置本地数据库和数据接口API； 开始Vue框架的学习吧～ 一、品牌列表案例 1.x 版本中的filterBy指令，在2.x中已经被废除：filterBy - 指令 12345678&lt;tr v-for=\"item in list | filterBy searchName in 'name'\"&gt;&lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt;&lt;td&gt;&lt;a href=\"#\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 12&lt;hr&gt; 输入筛选名称：&lt;input type=\"text\" v-model=\"searchName\"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 12345678910&lt;tbody&gt;&lt;tr v-for=\"item in search(searchName)\"&gt;&lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt;&lt;td&gt;&lt;a href=\"#\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345search(name) &#123;return this.list.filter(x =&gt; &#123;return x.name.indexOf(name) != -1;&#125;);&#125; 二、过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 1.私有过滤器HTML元素：1&lt;td&gt;&#123;&#123;item.ctime | dataFormat()&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223filters:&#123; //定义私有过滤器，过滤器有两个条件，【过滤器名称和处理函数】 //注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ dateFormat:function(dateStr,pattern = '')&#123; var dt = new Date(dateStr); // yy-mm-dd var y = dt.getFullYear(); var m = (dt.getMonth()+1).toString().padStart(2,'0'); var d = dt.getDate().toString().padStart(2,'0'); if (pattern &amp;&amp; pattern.toLowerCase() === 'yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 else&#123; var hh = dt.getHours().toString().padStart(2,'0'); var mm = dt.getMinutes().toString().padStart(2,'0'); var ss = dt.getSeconds().toString().padStart(2,'0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;~~~`; &#125; &#125;&#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串,例如.toString().padStart(2,’0’)用于不满两位数字则向前补零。 2.全局过滤器HTML元素：1&lt;td&gt;&#123;&#123;item.ctime | dateFormat()&#125;&#125;&lt;/td&gt; 全局 filters 定义方式：1234567891011121314151617181920212223// 创建一个全局的过滤器，进行事件的格式化Vue.filter('dateFormat',function(dateStr,pattern)&#123;// 根据给定的字符串得到特定时间 var dt = new Date(dateStr); // yy-mm-dd var y = dt.getFullYear(); var m = dt.getMonth()+1; var d = dt.getDate(); // return y + '-' + m + '-' + d; // return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; if (pattern &amp;&amp; pattern.toLowerCase() === 'yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 else&#123; var hh = dt.getHours(); var mm = dt.getMinutes(); var ss = dt.getSeconds(); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;) 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 三、自定义按键修饰符1.直接使用按键码的别名1&lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.enter=\"add\"&gt; 2.使用js里面的键盘事件对应的键码1&lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.13=\"add\"&gt; js里面的键盘事件对应的键码：http://www.cnblogs.com/wuhua1/p/6686237.html 3.通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名：1&lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.f2=\"add\"&gt; 自定义键盘修饰符Vue.config.keyCodes.f2 = 113; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理 四、自定义指令1.传统使用DOM方法进行定义指令1&lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\"&gt; 在中使用DOM方法进行定义document.getElementById(‘search’).focus(); 2.使用 vue.directive()定义全局的指令 ，其中参数一是指令的名称使用 vue.directive()定义全局的指令注意：在定义的时候，指令的名称前面，不需要加v-前缀，但在调用的时候，必须在指令名称前加上v-前缀进行调用参数二是一个对象，在这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 1. 和JS行为有关的操作，最好在inserted中去执行，防止JS行为不生效，如v-focus在每一个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数，是一个原生的JS对象（DOM对象）在元素刚绑定指令的时候，还没有插入到DOM中去，这时候调用focus方法没有作用因为一个元素只有插入DOM之后，才能获得焦点，所以要用inserted 1&lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\" v-focus&gt; 12345678910Vue.directive('focus',&#123; bind:function(el)&#123; //每当指令绑定到元素上时，会立即执行这个bind指令，只执行一次 //el.focus() &#125;, inserted: function(el)&#123; //表示元素插入到DOM中的时候，会执行inserted函数，只触发一次 el.focus() ; &#125;, updated: function()&#123; //当vnode更新的时候会执行updated，可能会触发多次 &#125;,&#125;) 2. 和样式相关的操作，可以放在bind中去执行，如v-color样式：只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式将来元素肯定会显示到页面中，这时候浏览器的渲染引擎必然会解析样式，应用给这个元素 1&lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\" v-focus v-color=\"'blue'\"&gt; 12345678910//设置一个定义字体颜色的指令Vue.directive('color' ,&#123; bind:function(el,binding)&#123; //el.style.color='red'; console.log(binding.name); //输出的是样式名color console.log(binding.value); //输出的是计算后的参数blue console.log(binding.expression); //输出的是原本的参数'blue' el.style.color = binding.value; &#125;&#125;) 3. 函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:1&lt;h3 v-color=\"'pink'\" v-fontweight=\"900\" v-fontsize=\"'30px'\"&gt;&#123;&#123; dt |dateFormat() &#125;&#125;&lt;/h3&gt; 123456789101112directives:&#123; //定义私有过滤器，定义在vm2实例中 'fontweight':&#123; bind: function(el,binding)&#123; el.style.fontWeight = binding.value; &#125; &#125;, 'fontsize':function(el,binding)&#123; el.style.fontSize= parseInt(binding.value) + 'px'; &#125;&#125;parseInt(binding.value) + 'px';用于解析输入的字符串，将'30px'解析成数字30，增强代码的健壮性 五、Vue实例的生命周期什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！生命周期钩子：就是生命周期事件的别名而已；生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 六、vue-resource 实现 get, post, jsonp请求 除了 vue-resource 之外，还可以使用 axios 的第三方包实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址：get请求地址： http://vue.studyit.io/api/getlunbopost请求地址：http://vue.studyit.io/api/postjsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；带大家通过 Node.js ，来手动实现一个JSONP的请求例子； vue-resource 的配置步骤：直接在页面中，通过script标签，引入 vue-resource 的脚本文件；注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 12&lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;script src=\"./lib/vue-resource-1.3.4.js\"&gt;&lt;/script&gt; 七、配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root","path":"2019/04/24/Vue-js学习笔记Day2-4-24/"},{"title":"Vue.js学习笔记Day1-4.22","text":"Vue.js学习笔记Day1-4.22今日主要学习内容： 三大主流框架的区别； 框架和库的区别； MVC和MVVM的区别； Vue的基本代码结构、插值表达式、v-cloak、v-text、v-html、v-bind、v-on； 走马灯效果制作； 事件修饰符（.stop、.prevent、.capture、.self、.once）； v-model和实现表单元素的双向数据绑定； Vue中使用样式； v-for指令和key属性； v-if和v-show的使用和特点 今天开始和我一起Vue框架的学习吧～ 一、三大主流框架： Vue是目前最火的前端框架，用来构建用户界面，只关注与视图层，容易上手且方便与与第三方库整合，它由前谷歌员工Evan You创建，被阿里巴巴，GitLab，百度使用，并受到全球开发人员和设计师的赞赏。 React是最流行的前端框架，React由facebook维护，React被Facebook，Uber，Netflix，Twitter，Udemy，Paypal，Reddit，Tumblr，Walmart 等使用。（React除了开发网页还可以开发App，vue借助于weex也可以开发手机App） Angular是应用最广泛的前端框架，是一个由Google支持的基于TypeScript的JavaScript框架，Angular开发在全球开发人员中广泛流行，并被谷歌，福布斯，WhatsApp，Instagram，healthcare.gov和许多财富500强公司等大型组织使用。 二、框架和库的区别：框架：是一套完整的解决方案；对项目侵入性非常大，项目需要更换框架，则需要重新架构各个项目库：提供某一个小功能，对项目侵入性小，如果某个库无法完成某些需求，可以很容易切换其他库进行实现需求 三、MVC（后端）和MVVM（前端）间的区别：MVC：modal层负责数据的处理，view层负责前端显示页面，controller是业务逻辑层MVVM：是前端视图层的概念，主要关注视图层的分离，VM是最主要的部分，是整个环节的调度者 四、Vue之基本代码结构、插值表达式、v-cloak、v-text、v-html、v-bind、v-on1.Vue的基本代码结构：这是一个新建好的Vue项目结构 2.Vue的插值表达式：主要作用是进行数据绑定，最常见的形式是使用“Mustache”语法（双大括号）的文本插值。例如：&lt;span&gt;Message:&lt;/span&gt;Mustache标签将会被替代为对应数据对象上msg属性（msg定义在data对象中）的值。无论何时，绑定的数据对象上msg属性发生了改变，插值处的内容都会更新。 3.指令学习：v-cloak：解决插值闪烁问题 &lt;p v-clock&gt;{{ msg }}&lt;/p&gt; //可以解决插值闪烁问题 v-text： 操作元素中的纯文本&lt;p v-clock&gt;&lt;/p&gt;和&lt;h4 v-text=&quot;msg&quot;&gt;&lt;/h4&gt;区别：1&gt;默认v-text没有插值闪烁问题2&gt;v-text会覆盖元素中原本的内容，但插值表达式只会替换自己的占位符，不会吧整个元素内容清空 &lt;p v-clock&gt;+++{{ msg }}&lt;/p&gt; //可显示+++， &lt;h4 v-text=&quot;msg&quot;&gt;+++&lt;/h4&gt; //不能显示+++ v-html： 操作元素中的HTML标签 &lt;div v-html=&quot;msg2&quot;&gt;&lt;/div&gt; v-text会将元素当成纯文本输出，v-html会将元素当成HTML标签解析后输出 v-bind：用于提供绑定属性的指令，简写形式是： &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot;&gt; 简写形式：v-bind:title等同于:titlev-bind中可以写合法的JS表达式，可以将mytitle看做一个变量，为其添加表达式‘123’ v-on：事件绑定机制，可以替代DOM操作，简写形式是@ &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot; id=&quot;btn&quot;&gt; &lt;/div&gt; &lt;script&gt; document.getElementById(&apos;btn&apos;).onclick = function(){ alert(&apos;Hello&apos;) } &lt;/script&gt; 用vue框架可以简写为： &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot; v-on:click=&quot;alert(&apos;hello&apos;)&quot;&gt; &lt;/div&gt; 简写形式：v-on:click等同于@click如若发现alert未被定义，还需要用methods属性定义当前vue实例所有可用的方法 &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot; v-on:click=&quot;show&quot;&gt; &lt;/div&gt; &lt;script&gt; methods:{ show:function(){ alert(&apos;Hello&apos;) } } &lt;/script&gt; 五、走马灯效果制作制作步骤： 给【浪起来】按钮，绑定一个点击事件 v-on即@click 在按钮的事件处理函数中，写相关的业务逻辑代码，拿到msg字符串，然后调用字符串的substring来进行字符串的截取操作，把第一个字符截取出来，放到最后一个位置上即可 为了实现点击按钮自动截取的功能，需要把步骤2步骤中的代码，放到一个定时器中去 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;嗨起来&quot; @click=&quot;lang&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;低调&quot; @click=&quot;stop&quot;&gt; &lt;h4&gt;{{ msg }}&lt;/h4&gt; &lt;/div&gt; &lt;script&gt; //注意：在VM实例中，如果要获取data上的数据，或者想要调用methods中的方法，必须通过this.数据属性名或者this.方法名来进行访问，这里的this.就表示我们new出来的VM实例 var vm = new Vue({ el: &apos;#app&apos;, data: { msg: &apos;猥琐发育，别浪~~！&apos;, intervalId:null, //在data上面定义计时器Id }, methods:{ lang(){ if(this.intervalId != null) return; //console.log(this.msg); //var _this=this; this.intervalId = setInterval(() =&gt; { //也可以用箭头函数，解决this指向问题 //获取到头的第一个字符 var start = this.msg.substring(0,1); //获取到后面的字符 var end = this.msg.substring(1); //重新拼接得到新的字符串，并赋值给this.msg this.msg = end + start; },400) //vm实例会监听自己身上data中所有数据的改变，只要数据一发生变化，就会自动把最新的数据，从data、上同步到页面中去【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 }, stop(){ clearInterval(this.intervalId); //每当清除了定时器之后需要把intervalId重新设为null，否则无法重新开启定时器 this.intervalId = null; } } }) &lt;/Script&gt; &lt;/body&gt; &lt;/html&gt; 六、 事件修饰符.stop：用于阻止冒泡 &lt;div class=&quot;inner&quot; @click=&quot;divHander&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click.stop=&quot;btnHander&quot; &gt; &lt;/div&gt; .prevent：阻止默认行为 &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;linkClick&quot;&gt;有问题先去百度&lt;/a&gt; .capture：添加事件侦听器时使用事件捕获模式 &lt;div class=&quot;inner&quot; @click.capture=&quot;divHander&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click=&quot;btnHander&quot; &gt; &lt;/div&gt; .self：实现只有点击当前元素时，才会触发事件处理函数 &lt;div class=&quot;inner&quot; @click.self=&quot;divHander&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click=&quot;btnHander&quot; &gt; &lt;/div&gt; .once事件只触发一次,.prevent.once相当于只阻止一次默认行为 &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.once=&quot;linkClick&quot;&gt;有问题先去百度&lt;/a&gt; 注意：.stop和.self的区别：.stop是阻止所有冒泡行为的发生.self 只会阻止自己身上冒泡行为的发生，并不会真正阻止冒泡的行为 &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt; &lt;div class=&quot;inner&quot; @click=&quot;divHandler&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click.stop=&quot;btnHandler&quot; &gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;divHandler&quot; &gt; &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click=&quot;btnHandler&quot; &gt; &lt;/div&gt; &lt;/div&gt; 七、Vue指令之v-model和实现表单元素的双向数据绑定v-bind只能实现数据的单向绑定，从M自动绑定到V，无法实现数据的双向绑定 &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; style=&quot;width: 100%&quot;&gt; v-model指令可以实现表单元素和Mpdel中数据的双向数据绑定v-model只能运用在表单元素中：input（radio，text，address，email…）、select、checkbox、textarea等等 &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; style=&quot;width: 100%&quot;&gt; 使用v-model实现简易计算器的案例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;+&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;*&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;/&quot;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; @click=&quot;calc&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, //el指定vm要控制的元素 data: { //data指定vm中要展示的数据 n1: 0, n2: 0, result: 0, opt: &apos;+&apos;, }, methods:{ calc(){ //计算器算数的方法 switch(this.opt){ //逻辑 case &apos;+&apos;: this.result = parseInt(this.n1) + parseInt(this.n2) break; case &apos;-&apos;: this.result = parseInt(this.n1) - parseInt(this.n2) break; case &apos;*&apos;: this.result = parseInt(this.n1) * parseInt(this.n2) break; case &apos;/&apos;: this.result = parseInt(this.n1) / parseInt(this.n2) break; } // 注意eval是投机取巧的方式，正式开发中，尽量少用 // var codeStr = &apos; parseInt(this.n1) &apos; + this.opt + &apos; parseInt(this.n2) &apos; // this.result = eval(codeStr) } } }) &lt;/Script&gt; &lt;/body&gt; &lt;/html&gt; 八、Vue中使用样式使用class样式1. 数组 &lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;很大很大的标题&lt;/h1&gt; 2. 数组中使用三元表达式 &lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, flag?&apos;active&apos;:&apos;&apos;]&quot;&gt;很大很大的标题&lt;/h1&gt; 3. 数组中嵌套对象 &lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, {&apos;active&apos;:flag}]&quot;&gt;很大很大的标题&lt;/h1&gt; 4. 直接使用对象 &lt;h1 :class=&quot;{red:true,thin:true,italic:false,active:false}&quot;&gt;很大很大的标题&lt;/h1&gt; &lt;h1 :class=&quot;classObj&quot;&gt;很大很大的标题&lt;/h1&gt; data: { //data中定义样式对象 classObj:{red:true,thin:true,italic:false,active:false} }, 使用内联样式：1. 直接在元素上通过:style的形式书写样式对象 &lt;h1 :style=&quot;{color:&apos;red&apos;,&apos;font-weight&apos;:200 }&quot;&gt;这是一个标题&lt;/h1&gt; 2. 将样式对象定义到data中，并直接引用到:style中 &lt;h1 :style=&quot;styleObj1&quot;&gt;这是一个标题&lt;/h1&gt; data: { //data中定义样式对象 styleObj1:{color:&apos;red&apos;,&apos;font-weight&apos;:200 }, }, 3. 在:style中通过数组，引用多个data上的样式对象 &lt;h1 :style=&quot;[ styleObj1 , styleObj2 ]&quot;&gt;这是一个标题&lt;/h1&gt; data: { //data中定义样式对象 styleObj1: {color:&apos;red&apos;,&apos;font-weight&apos;:200 }, styleObj2: {&apos;font-style&apos;:&apos;italic&apos;} }, 九、Vue指令之v-for指令和key属性1. 迭代数组 &lt;p v-for=&quot;item in list&quot;&gt;{{ item }}&lt;/p&gt; &lt;p v-for=&quot;(item,i) in list&quot;&gt;索引值:{{ i }}---每一项:{{ item }}&lt;/p&gt; 2. 迭代对象数组 &lt;p v-for=&quot;(user,i) in list&quot;&gt;索引号:{{ i }}---序号:{{ user.id }}---姓名：{{ user.name}}&lt;/p&gt; 3. 迭代对象 &lt;p v-for=&quot;(value,key,i) in User&quot;&gt;索引号：{{i}}---键是:{{ key }}---值是:{{ value }}&lt;/p&gt; 4. 迭代数字 &lt;!-- in后面放置普通数组，对象数组，对象，还可以放置数字 --&gt; &lt;!-- 注意：如果使用v-for迭代数字，默认从1开始迭代 --&gt; &lt;p v-for=&quot;(count,i) in 10&quot;&gt;索引号：{{i}}---这是第 {{ count }} 次循环&lt;/p&gt; key属性的特性： 在2.20+的版本里，当在组件中使用v-for时，key现在是必须的 当vue.js用v-for正在更新已渲染过的元素列表时，它默认用“就地复原策略”，如果数据项的顺序被改变，vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保他在指定索引下显示已被渲染过的每个元素 为了给Vue一个提示，以便他能够跟踪每个节点的身份，从而重用和重新排序现有的元素，需要为每项提供一个唯一的key属性 注意：v-for循环的时候key属性只能使用number获取string 注意：key在使用时，必须使用v-bind属性绑定形式，指定key的值 在组件中使用v-for的时候，或者在一些特殊情况中，如果v-for有问题，必须在使用v-for的同时，指定唯一的字符串或数字类型：key值 &lt;p v-for=&quot;(user,i) in list&quot; :key=&quot;user.id&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; 索引号:{{ i }}---序号:{{ user.id }}---姓名：{{ user.name}} &lt;/p&gt; 十、v-if和v-show的使用和特点 v-if的特点：每次都会重新删除或创建元素 v-show的特点：每次不会重新进行DOM的删除和创建操作，只是切换了元素的display：none v-if有较高的切换性能，如果元素涉及到频繁的切换，最好不要使用v-if v-show有较高的初始渲染消耗，如果元素可能永远也不会显示出来被用户看到，则不推荐使用v-show &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;toggle&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是v-if控制的元素&lt;/h3&gt; &lt;h3 v-show=&quot;flag&quot;&gt;这是v-show控制的元素&lt;/h3&gt;","path":"2019/04/22/Vue-js学习笔记Day1-4-22/"},{"title":"十大排序算法","text":"今天我们来学习一下排序算法，排序算法是《数据结构与算法》中最基本的算法之一，虽说学过这门课，但几种排序总是讲述不清，今天来做一个系统的学习归纳，跟着我一起来学习吧~ 排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的十大内部排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。用一张图概括： 关于时间复杂度： O(n2) 平方阶排序: 插入排序、选择排序和冒泡排序；O(nlog2n) 线性对数阶排序: 快速排序、堆排序和归并排序；O(n1+§) 排序(§ 是介于 0 和 1 之间的常数): 希尔排序；O(n) 线性阶排序: 基数排序、桶、箱排序。 关于稳定性： 排序算法的稳定性:若待排序的序列中，存在多个具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 一.冒泡排序1.算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 二.选择排序1.算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 三.插入排序1.算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 2.动画演示 3.参考代码（JavaScript 代码实现）1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex+1] = arr[preIndex]; preIndex--; &#125; arr[preIndex+1] = current; &#125; return arr;&#125; 四.希尔排序1.算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 2.动画演示 3.参考代码（JavaScript 代码实现）123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len/3) &#123; //动态定义间隔序列 gap =gap*3+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; return arr;&#125; 五.归并排序1.算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516171819202122232425262728293031function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; 六.快速排序1.算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 2.动画演示 3.参考代码（JavaScript 代码实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr;&#125;function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function partition2(arr, low, high) &#123; let pivot = arr[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; arr[high] &gt; pivot) &#123; --high; &#125; arr[low] = arr[high]; while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123; ++low; &#125; arr[high] = arr[low]; &#125; arr[low] = pivot; return low;&#125;function quickSort2(arr, low, high) &#123; if (low &lt; high) &#123; let pivot = partition2(arr, low, high); quickSort2(arr, low, pivot - 1); quickSort2(arr, pivot + 1, high); &#125; return arr;&#125; 七.堆排序1.算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 2.动画演示 3.参考代码（JavaScript 代码实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest); &#125;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length-1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr;&#125; 八.计数排序1.算法步骤 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1) 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue+1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr;&#125; 九.桶排序1.算法步骤 设置固定数量的空桶。 把数据放到对应的桶中。 对每个不为空的桶中数据进行排序。 拼接不为空的桶中数据，得到结果。 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; //桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; //利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125; 十.基数排序1.算法步骤 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零 从最低位开始，依次进行一次排序 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 2.动画演示 3.参考代码（JavaScript 代码实现）12345678910111213141516171819202122232425//LSD Radix Sortvar counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125; 本文只是对十大排序算法进行了简要描述，本人着重于学习Web开发，所以摘取的是JavaScript的代码，如果还想进一步深入学习，可以参考菜鸟教程的 十大排序算法 的教学网站~","path":"2019/04/01/十大排序算法/"},{"title":"Markdown基本语法","text":"进行完博客搭建，让我们来学习一下怎么写博客吧，学习一下Markdown的基本语法~本站只是对Markdown语法进行简要叙述，如果想要加深一步学习，可以去Markdown官网上进行学习哦~ 什么是Markdown？ Markdown 的目标是实现「易读易写」。Markdown 语法的目标是：成为一种适用于网络的书写语言。Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 markdown的优点： 语法简单 更专注内容而非排版，排版只是为了更清楚的展现内容 md轻松转换html及pdf，网络友好 1.标题行首插入1到6个# ，对应到标题1到6阶，例如 # 这是 H1，一级标题 ## 这是 H2，二级标题 ###### 这是 H6，六级标题 2.段落一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。普通段落不该用空格或制表符来缩进。如果你确实想要依赖 Markdown 来插入 标签的话，在插入处先按入两个以上的空格然后回车。 3.列表Markdown 支持有序列表和无序列表。无序列表使用星号、加号或是减号作为列表标记，如： * 列表一 * 列表二 * 列表三 有序列表则使用数字接着一个英文句点，如： 1. 有序列表一 2. 有序列表二 3. 有序列表三 4.分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 5.链接要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，例如： [Lililich&apos;s Blog](https://lililich.work) 要建立一个自动链接，只要是用&lt;&gt;括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;https://lililich.work&gt; 6.图片Markdown 使用一种和链接很相似的语法来标记图片。行内式的图片语法详细叙述如下：1.一个惊叹号 !2.接着一个方括号，里面放上图片的替代文字3.接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 ![Lililich&apos;s photo](/path/to/img.jpg &quot;Optional title&quot;) 7.代码区要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落。 这是一个代码区块。 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： 这是一个 `行内` 代码。 如果用三个反引号（`）把它包起来即可在网页中显示为多行代码块，例如： 12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;这是一段文字&lt;/&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8.强调字体Markdown 使用星号( * )和底线( _ )作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong> ，例如： *这是斜体* **这是粗体** 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \\*这里的星号是普通符号，不会用作斜体显示\\* 9.区块引用Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式，在 Markdown 文件中建立一个区块引用，首先自己先断好行，然后在每行的最前面加上 &gt; ，例如： &gt;这是一段引用 &gt;这是另一段引用 好啦，常用的Markdown的语法学习就到这里啦，如果想要加深一步学习，可以去Markdown官网上进行学习哦~","path":"2019/03/31/Markdown基本语法/"},{"title":"Git基本用法","text":"Github是一个远程仓库，上传下载文件都需要运用到Git命令，让我们学习一下怎么运用Git吧~本站只是对Github进行简要概括，方便运用时查找，如果想要加深一步学习，可以去廖雪峰Git教学网站上进行学习哦~ 什么是Git命令？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。Git有什么特点？简单来说就是：高端大气上档次！ 集中式版本控制系统(如CVS和SVN) ：版本库是集中存放在中央服务器的，工作时从版本库下载，修改后重新上传版本库，完整的版本库保存在中央服务器，集中式版本控制系统最大的毛病就是必须联网才能工作。 分布式管理系统(如Git) ：每个人电脑里都会有完整的版本库，只推送修改即可，不必联网。Git的优势不单是不必联网这么简单，Git极其强大的分支管理，把SVN等远远抛在了后面。Git的工作描述图如下： 一.版本管理1）git init创建版本库,初始化本地仓库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。通过git init命令把这个目录变成Git可以管理的仓库： $ git init Initialized empty Git repository in /Users/michael/learngit/.git/ 2）git add 将修改好的文件上传到版本库$ git add readme.txt $ git add file2.txt file3.txt //可同时添加多个文件 3）git commit 将修改好的文件上传到仓库-m参数后面输入的是本次提交的说明 $ git commit -m &quot;wrote a readme file&quot; [master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 4）git status 命令可以让我们时刻掌握仓库当前的状态$ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 5）git diff 命令可以查看具体修改内容$ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. 6）git log 命令可以查看近期提交日志，可以获取commit id加上--pretty=oneline参数可省去多余的信息 $ git log commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) Author: Lililich &lt;lililich94@163.com&gt; Date: Fri May 18 21:06:15 2018 +0800 wrote a readme file 7）git reset 命令进行版本回退用HEAD表示当前版本，上一个版本就是HEAD^，往上100个版本写成HEAD~100；也可以用commit id来进行版本回退 $ git reset --hard HEAD^ HEAD is now at e475afc add distributed $ git reset --hard 1094a HEAD is now at 83b0afe append GPL 8）git relog 命令用来记录每一次命令，方便查找commit id$ git reflog e475afc HEAD@{1}: reset: moving to HEAD^ 1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL e475afc HEAD@{3}: commit: add distributed eaadf4e HEAD@{4}: commit (initial): wrote a readme file 9）git checkout 命令用来撤销修改--很重要，没有--，就变成了“切换到另一个分支”的命令 //若修改仅保存在工作区，可直接撤销修改 $ git checkout -- readme.txt //若已经git add到了暂存区，先将暂存区版本撤销再丢弃工作区修改 $ git reset HEAD readme.txt $ git checkout -- readme.txt //若已经git commit到了远程仓库，直接进行版本回退 $ git reset --hard HEAD^ 10）git rm 命令用来删除文件删除版本库文件先git rm再git commit提交 $ git rm test.txt rm &apos;test.txt&apos; $ git commit -m &quot;remove test.txt&quot; [master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt $ git checkout -- test.txt //还可以将误删的文件从版本库还原 11）git remote add 命令把本地仓库与GitHub远程仓库相关联$ git remote add origin git@github.com:lililich/learngit.git 12）git push命令把本地当前分支master推送到远程-u参数代表Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令 $ git push -u origin master Counting objects: 20, done. Delta compression using up to 4 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done. Total 20 (delta 5), reused 0 (delta 0) remote: Resolving deltas: 100% (5/5), done. To github.com:lililich/learngit.git * [new branch] master -&gt; master Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. 13）git clone命令用于从远程库克隆代码$ git clone git@github.com:lililich/gitskills.git Cloning into &apos;gitskills&apos;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3 Receiving objects: 100% (3/3), done. 二.分支管理1）git checkout命令用来创建并切换分支$ git checkout -b dev //用来创建并切换分支，相当于以下两条命令 Switched to a new branch &apos;dev&apos; $ git branch dev //创建分支 $ git checkout dev //切换分支 2）git branch命令用来命查看当前分支命令会列出所有分支，当前分支前面会标一个*号 $ git branch * dev master 3）git merge命令用于合并指定分支到当前分支$ git merge dev Updating d46f35e..b17d20e Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) 4）git branch命令也用于创建和操作分支不加参数git branch &lt;name&gt;表示创建分支，加上参数git branch -d &lt;name&gt;用于删除分支，git branch -D &lt;name&gt;用于删除一个还未被合并过的分支 $ git branch -d dev Deleted branch dev (was b17d20e). $ git branch -D feature-vulcan Deleted branch feature-vulcan (was 287773e). 5）git log --graph命令用于查看分之合并情况当Git无法自动合并分支时，就必须首先解决冲突。git status查看冲突文件，解决冲突后，再提交，合并完成。合并完成用git log --graph命令也用于查看分之合并情况 $ git log --graph --pretty=oneline --abbrev-commit * cf810e4 (HEAD -&gt; master) conflict fixed |\\ | * 14096d0 (feature1) AND simple * | 5dc6824 &amp; simple |/ * b17d20e branch test * d46f35e (origin/master) remove test.txt 6）git merge --no-ff命令用于表示禁用Fast forward,--no-ff参数表示使合并后的历史有分支，能看出曾做过合并通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 $ git merge --no-ff -m &quot;merge with no-ff&quot; dev Merge made by the &apos;recursive&apos; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 7）git stash命令用于处理Bug分支$ git stash //存储当前工作现场，等改完Bug再恢复 Saved working directory and index state WIP on dev: f52c633 add merge $ git stash list //查看stash内容列表 stash@{0}: WIP on dev: f52c633 add merge $ git stash pop //恢复现场的同时把stash内容也删了，相当于以下两条语句 $ git stash apply //恢复现场，但是恢复后，stash内容并不删除 $ git stash drop //删除stash内容 8）git remote命令用于处理多人协作问题$ git remote //查看远程库的信息 origin $ git remote -v //显示更详细的信息 9）git pull命令用于把最新的提交从origin/dev抓下来用于当你的小伙伴的最新提交和你试图推送的提交有冲突时，先用git pull命令用于把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 $ git branch --set-upstream-to=origin/dev dev //先建立本地dev分支与远程origin/dev分支的链接 Branch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;. $ git pull //将远程库最新更新抓取下来 Auto-merging env.txt CONFLICT (add/add): Merge conflict in env.txt Automatic merge failed; fix conflicts and then commit the result. 9）git rebase命令用于解决历史记录分叉的问题$ git rebase 三.标签管理1）git tag命令用来创建和删除标签$ git tag v1.0 //创建标签 $ git tag //查看标签 v1.0 $ git tag v0.9 f52c633 //给commit id已知的提交创建标签 $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb //创建带有说明的标签 $ git tag -d v0.1 //删除标签 Deleted tag &apos;v0.1&apos; (was f15b0dd) 2）git show命令用来查看标签信息$ git show v0.9 commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9) Author: Lililich &lt;lililich94@163.com&gt; Date: Fri May 18 21:56:54 2018 +0800 add merge diff --git a/readme.txt b/readme.txt ... 3）git push命令用来推送标签$ git push origin --tags //一次性推送全部尚未推送到远程的本地标签 Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 $ git tag -d v0.9 //先把标签从本地删除 Deleted tag &apos;v0.9&apos; (was f52c633) $ git push origin :refs/tags/v0.9 //再把标签从远程库删除 To github.com:michaelliao/learngit.git - [deleted] v0.9","path":"2019/03/28/Git基本用法/"},{"title":"Github+Hexo搭建个人博客","text":"作为一名技术小白，一直秉承着极高的热情向技术大佬们学习，可是学着学着就发现学过的东西很容易忘记，所以打算创建一个个人博客来进行记录总结，一方面可以总结学习过程中遇到的错误和困难，一方面也可以方便其他童鞋进行参考，接下来就和我一起学学怎么搭建个人博客吧！ 我们先来看一下大体的搭建步骤：• 获得个人网站域名• 安装Git和Node.js• GitHub创建个人仓库• 安装Hexo• 推送网站• 绑定域名• 更换主题 好啦，接下来就和我一起一步步进行操作吧~ 1. 获得个人网站域名首先进行域名注册的原因是，域名注册也需要审核哦，会耗费时间，所以我们先进行域名注册，在等待的时间里来进行接下来的其他操作，这样就省时省力啦！ 域名是网站的入口，也是网站的第一印象，比如饿了么的官网域名是：https://www.ele.me/，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀比如，我选择的是work后缀，原因很简单，因为在搞活动一年1块钱，所以果断下手。 申请域名的地方有很多，这里推荐阿里云：阿里云-为了无法计算的价值 ，申请入口：域名注册 购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用就好啦。 2. 安装Git和Node.js1) 安装Git什么是Git?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。Git下载地址：https://git-scm.com/download/win 现在大部分机子是64位的，选择64位的安装包下载安装，在命令行里输入git --version是否安装成功，若安装失败，参看其他详细的Git安装教程。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 2) 安装Node.jsHexo基于Node.js，Node.js下载地址：https://nodejs.org/en/download/ 下载安装包，注意安装Node.js会包含环境变量及npm的安装。检测Node.js是否安装成功，在命令行中输入node -v ；检测npm是否安装成功，在命令行中输入npm -v 。显示如下则安装成功哦！ 3. GitHub创建个人仓库登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号，创建并登录，点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：lililich.github.io。 接下来，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash。设置user.name和user.email配置信息：12$git config --global user.name \"你的GitHub用户名\"$git config --global user.email \"你的GitHub注册邮箱\" 生成ssh密钥文件,生成一个公钥和密钥，因为 GitHub 需要一个密钥才能与本地相连接。然后直接三个回车即可，默认不需要设置密码。1$ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" ssh key生成之后会默认保存在 C:/Users/电脑名用户名/.ssh目录中，打开这个目录，id_rsa.pub是公钥，id_rsa是密钥,接下来打印公钥信息：1$cat ~/.ssh/id_rsa.pub 打开 GitHub ，依次点击 头像--&gt;Settings--&gt;SSH and GPG keys--&gt;Add SSH key，Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key，SSH KEY 配置成功。在Git Bash中检测GitHub公钥设置是否成功，输入ssh git@github.com测试连接，显示如下则连接成功。 这里之所以设置GitHub密钥原因是：通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 4. 安装HexoHexo就是我们的个人博客网站的框架，这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。首先使用npm命令安装Hexo，输入：1$npm install -g hexo-cli 这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：1$hexo init blog 为了检测我们的网站雏形，分别按顺序输入以下三条命令：123$hexo new test_my_site //新建文章$hexo g //hexo generate生成$hexo s //hexo server启动服务预览 注意，当时直接在Blog文件夹中输入这三条指令一直报错，找了许久才找到了解决方法。https://www.jianshu.com/p/2f4aca924fdb这里形容得太贴切了，在大街上喊老婆肯定大海捞针啊哈哈哈，要进入相应的目录再喊指令就会成功了，就是说，我们要进入刚刚new初始化下的blog文件夹下运行上述三条指令。完成后，打开浏览器输入地址:localhost:4000就可以在本地看到我们写的第一篇博客啦！开不开心！兴不兴奋！ 5. 推送网站上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，两个网站不要搞混。 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改并保存为：1234deploy: type: gitrepo: https://github.com/lililich/lililich.github.io.git //这里填入你之前在GitHub上创建仓库的完整路径，记得加上.gitbranch: master 其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：1$npm install hexo-deployer-git --save 这时，我们分别输入三条命令：123$hexo clean //清除缓存，若是网页正常情况下可以忽略该条指令$hexo g //hexo generate生成网站$hexo d //hexo deploy部署网站 完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 http://xxxx.github.io (知乎排版可能会出现”http://“字样) 比如我的xxxx就是我的GitHub用户名：lililich你就会发现你的博客已经上线了，可以在网络上被访问了！访问网址为 http://xxxx.github.io 6. 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io (知乎排版可能会出现”http://“字样) 我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。第一步，登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析，然后添加解析。第一个记录类型是A，ping你的 http://xxxx.github.io 的ip地址，将ip地址填入记录值。第二个记录类型是CNAME，CNAME的记录值是：你的用户名.github.io,这里千万别弄错了。 第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名，如我的域名是lililich.work,保存添加。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。保存，命名为CNAME ，注意保存成所有文件而不是txt文件。完成这三步，进入blog目录中，按住shift键右击打开命令行，再依次输入：hexo clean hexo g hexo d这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 7. 更换主题如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes。 目前用的比较多的是Next主题，我自己使用的是cube主题。现在把默认主题更改成cube主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：1$https://github.com/ZEROKISEKI/hexo-theme-cube.git themes/cube //下载cube主题 这是将cube主题下载到blog目录的themes主题下的cube文件夹中。打开站点的_config.yml配置文件，修改主题theme：cube选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。接下来就去Markdown网站上学习一下写博客用到的语法吧,你就可以尽情的书写自己的博客啦！","path":"2019/03/22/Github+Hexo搭建个人博客/"},{"title":"Hexo基本语法","text":"让我们来学习下 Hexo 的基本语法。你也可以进入 documentation 来进行系统的学习。 如果在运用Hexo的时候出现疑问，你可以去 troubleshooting 上进行提问或者你可以上 GitHub 上寻求帮助。 Quick StartCreate a new post1$ hexo new \"My New Post\" //新建文章 More info: Writing Run server1$ hexo server //启动服务预览 More info: Server Generate static files1$ hexo generate //生成页面 More info: Generating Deploy to remote sites1$ hexo deploy //部署页面 More info: Deployment","path":"2019/03/20/hello-world/"}]}